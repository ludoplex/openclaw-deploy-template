{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"0abf7003-d51c-443b-9179-cb81fca5c8cc","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:59:35.198Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"f184cc37-a3e1-4d5e-b52c-84ce13b22f6e","codeBlocks":[{"uri":{"scheme":"file","authority":"","path":"/c:/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1","query":"","fragment":"","_formatted":"file:///c%3A/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1","_fsPath":"c:\\Users\\user\\Downloads\\Cursor_working_directory_misc\\USB-Inventory.ps1"},"codeblockId":"c032cac4-fb60-4bcd-b6c4-1957e2855d2c","codeBlockIdx":0,"content":"#requires -Version 5.1\n\u003c#\n.SYNOPSIS\n    USB-portable PC hardware inventory collection and analysis tool.\n\n.DESCRIPTION\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\n    script. Optionally runs health analysis to detect duplicates, stale assets,\n    low RAM, and missing monitor data.\n\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\n\n.PARAMETER OutputFile\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\n\n.PARAMETER IncludePciDevices\n    Include detailed PCI device enumeration (can produce large output).\n\n.PARAMETER Analyze\n    After collection, run health analysis on the CSV file.\n\n.PARAMETER AnalyzeOnly\n    Skip collection; only run health analysis on existing CSV.\n\n.PARAMETER StaleDays\n    Threshold in days for flagging stale assets. Default: 90.\n\n.PARAMETER MinRamGB\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\n\n.PARAMETER NoCsv\n    Do not output Inventory_Issues_Report.csv (text report only).\n\n.EXAMPLE\n    .\\USB-Inventory.ps1\n    Collect inventory from this PC into PC_Inventory_Master.csv.\n\n.EXAMPLE\n    .\\USB-Inventory.ps1 -IncludePciDevices -Analyze\n    Collect inventory with PCI devices, then run health analysis.\n\n.EXAMPLE\n    .\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\n    Analyze existing CSV with custom thresholds (no new collection).\n#\u003e\n\n[CmdletBinding()]\nparam(\n    [string]$OutputFile,\n    [switch]$IncludePciDevices,\n    [switch]$Analyze,\n    [switch]$AnalyzeOnly,\n    [int]$StaleDays = 90,\n    [int]$MinRamGB = 8,\n    [switch]$NoCsv\n)\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = \u0027Stop\u0027\n\n# Resolve script root (handles -File invocation where $PSScriptRoot may be empty)\n$ScriptDir = $PSScriptRoot\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\n    $ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition\n}\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\n    $ScriptDir = $PWD.Path\n}\n\n# Default OutputFile if not specified\nif ([string]::IsNullOrWhiteSpace($OutputFile)) {\n    $OutputFile = Join-Path -Path $ScriptDir -ChildPath \u0027PC_Inventory_Master.csv\u0027\n}\n\n# ============================================================================\n# HELPER FUNCTIONS - COLLECTION\n# ============================================================================\n\nfunction Clean-Cell {\n    param([AllowNull()][string]$Text)\n    if ($null -eq $Text) { return \u0027\u0027 }\n    return ($Text -replace \"(`r`n|`n|`r|`t)+\", \u0027 \u0027).Trim()\n}\n\nfunction Convert-UShortArrayToString {\n    param([AllowNull()]$Arr)\n    if ($null -eq $Arr) { return \u0027\u0027 }\n    $chars = foreach ($x in $Arr) {\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\n    }\n    return ( -join $chars ).Trim()\n}\n\nfunction Get-MonitorInventory {\n    \u003c#\n      Preferred: root\\wmi:WmiMonitorID (easy, consistent, usually no admin)\n      Fallback: registry EDID decode under HKLM:\\SYSTEM\\CCS\\Enum\\DISPLAY\n    #\u003e\n\n    $results = New-Object System.Collections.Generic.List[string]\n\n    # --- Preferred path: WmiMonitorID ---\n    try {\n        $wmiMons = Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorID -ErrorAction Stop\n        foreach ($m in $wmiMons) {\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\n\n            $label = @()\n            if ($mfg)  { $label += $mfg }\n            if ($name) { $label += $name }\n\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\n            $serialPart  = if ($sn) { \"SN:$sn\" } else { \u0027SN:(none)\u0027 }\n\n            $results.Add(\"$displayName ($serialPart)\")\n        }\n    } catch {\n        # WmiMonitorID not available; fall through to EDID fallback\n    }\n\n    if ($results.Count -gt 0) {\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n    }\n\n    # --- Fallback path: registry EDID decode ---\n    function Get-EdidDescriptorString {\n        param(\n            [byte[]]$Edid,\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\n        )\n\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\n\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\n\n        foreach ($offset in 54,72,90,108) {\n            if (($offset + 18) -gt $Edid.Length) { continue }\n\n            # Descriptor: 00 00 00 {tag} 00 ...\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\n\n                $bytes = $Edid[($offset+5)..($offset+17)]\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\n                $text = ($text -replace \"[`0`n`r]+\", \u0027\u0027).Trim()\n                if ($text) { return $text }\n            }\n        }\n\n        return \u0027\u0027\n    }\n\n    try {\n        $root = \u0027HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\DISPLAY\u0027\n        if (Test-Path -LiteralPath $root) {\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\n                    if (Test-Path -LiteralPath $params) {\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\n                        if ($edid -is [byte[]]) {\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\n\n                            # Numeric serial (bytes 12-15 LE) sometimes present\n                            $num = [BitConverter]::ToUInt32($edid, 12)\n                            $numStr = if ($num -ne 0) { \"NUM:$num\" } else { \u0027\u0027 }\n\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\n                            $serialPart  = if ($sn) { \"SN:$sn\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\n\n                            $results.Add(\"$displayName ($serialPart)\")\n                        }\n                    }\n                }\n            }\n        }\n    } catch {\n        # EDID fallback failed silently\n    }\n\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-NetworkInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\n\n    if ($hasNetAdapter -and $hasNetIpCfg) {\n        try {\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\n            foreach ($a in $adapters) {\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\n                $ipv4 = @()\n                if ($cfg -and $cfg.IPv4Address) {\n                    $ipv4 = $cfg.IPv4Address |\n                        ForEach-Object { $_.IPAddress } |\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\n                }\n                $gw = @()\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\n                }\n\n                $parts = @()\n                $parts += (Clean-Cell $a.Name)\n                if ($a.MacAddress) { $parts += \"MAC:$($a.MacAddress)\" }\n                if ($ipv4.Count -gt 0) { $parts += (\"IPv4:\" + ($ipv4 -join \u0027;\u0027)) }\n                if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n                $items.Add(($parts -join \u0027 \u0027))\n            }\n        } catch {\n            # Fall back to CIM below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\n            Where-Object { $_.IPEnabled -eq $true }\n\n        foreach ($n in $net) {\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\n            $mac  = $n.MACAddress\n            $ips  = @()\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\n            $gw   = @()\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\n\n            $parts = @()\n            $parts += (Clean-Cell $name)\n            if ($mac) { $parts += \"MAC:$mac\" }\n            if ($ips.Count -gt 0) { $parts += (\"IP:\" + ($ips -join \u0027;\u0027)) }\n            if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n            $items.Add(($parts -join \u0027 \u0027))\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-GpuInventory {\n    $gpus = New-Object System.Collections.Generic.List[string]\n\n    # CIM GPUs\n    try {\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\n        foreach ($g in $vc) {\n            $name = Clean-Cell $g.Name\n            $pnp  = Clean-Cell $g.PNPDeviceID\n            if ($name -or $pnp) {\n                $gpus.Add((\"{0}{1}\" -f $name, $(if ($pnp) { \" [ID:$pnp]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    # Optional NVIDIA serials if nvidia-smi exists\n    try {\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\n        if ($nvsmi) {\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\n            foreach ($line in @($raw)) {\n                $t = Clean-Cell $line\n                if ($t) { $gpus.Add(\"NVIDIA $t\") }\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-DiskInventory {\n    $disks = New-Object System.Collections.Generic.List[string]\n\n    # Prefer Storage module when available\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\n    if ($hasPhysicalDisk) {\n        try {\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\n                $name = Clean-Cell $d.FriendlyName\n                $sn   = Clean-Cell $d.SerialNumber\n                $mt   = Clean-Cell ([string]$d.MediaType)\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n                $parts = @()\n                if ($name) { $parts += $name }\n                if ($sn)   { $parts += \"SN:$sn\" }\n                if ($mt)   { $parts += \"Type:$mt\" }\n                if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n            }\n        } catch {\n            # Fall back below\n        }\n    }\n\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\n            $model = Clean-Cell $d.Model\n            $sn = \u0027\u0027\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\n            $devId = Clean-Cell $d.DeviceID\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n            $parts = @()\n            if ($model) { $parts += $model }\n            if ($sn)    { $parts += \"SN:$sn\" }\n            if ($devId) { $parts += \"Dev:$devId\" }\n            if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-PciDeviceInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\n    if ($hasGetPnpDevice) {\n        try {\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\n                Where-Object { $_.InstanceId -like \u0027PCI\\*\u0027 } |\n                Sort-Object -Property Class, FriendlyName, Name\n\n            foreach ($d in $devs) {\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\n                $name = Clean-Cell $name\n                $cls  = Clean-Cell $d.Class\n                $id   = Clean-Cell $d.InstanceId\n                if ($name -or $id) {\n                    $items.Add((\"{0}{1}{2}\" -f $name, $(if ($cls) { \" [Class:$cls]\" } else { \u0027\u0027 }), $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n                }\n            }\n        } catch {\n            # Fall back below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM Win32_PnPEntity\n    try {\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\*\u0027 } |\n            Sort-Object -Property Name\n\n        foreach ($d in $devs) {\n            $name = Clean-Cell $d.Name\n            $id   = Clean-Cell $d.PNPDeviceID\n            if ($name -or $id) {\n                $items.Add((\"{0}{1}\" -f $name, $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\n# ============================================================================\n# HELPER FUNCTIONS - ANALYSIS\n# ============================================================================\n\nfunction Get-ColumnMap {\n    param([string[]]$Headers)\n\n    $map = @{\n        Hostname        = \u0027Hostname\u0027\n        User            = \u0027User\u0027\n        System_Serial   = \u0027System_Serial\u0027\n        RAM_GB          = \u0027RAM_GB\u0027\n        Monitor_Serials = \u0027Monitor_Serials\u0027\n        Scan_Date       = \u0027Scan_Date\u0027\n    }\n\n    foreach ($k in @($map.Keys)) {\n        if ($Headers -notcontains $map[$k]) {\n            $alts = switch ($k) {\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\n                default           { @() }\n            }\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\n            if ($found) { $map[$k] = $found }\n        }\n    }\n\n    return $map\n}\n\nfunction Parse-ScanDate {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    $dt = $null\n\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\n\n    if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\n\n    return $null\n}\n\nfunction Normalize-Serial {\n    param([AllowNull()][string]$Serial)\n\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\n    $s = ($Serial.Trim())\n\n    $bad = @(\n        \u0027To Be Filled By O.E.M.\u0027,\n        \u0027To Be Filled By OEM\u0027,\n        \u0027Default string\u0027,\n        \u0027System Serial Number\u0027,\n        \u0027None\u0027,\n        \u0027N/A\u0027,\n        \u0027NA\u0027,\n        \u00270\u0027,\n        \u002700000000\u0027,\n        \u00270000000000\u0027,\n        \u00270000000000000000\u0027\n    )\n\n    if ($bad -contains $s) { return \u0027\u0027 }\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\n\n    return $s.ToUpperInvariant()\n}\n\nfunction Parse-RamGB {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    $m = [regex]::Match($s, \u0027(\\d+)(\\.\\d+)?\u0027)\n    if (-not $m.Success) { return $null }\n\n    $n = $null\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\n        return [int][math]::Round($n, 0)\n    }\n\n    return $null\n}\n\nfunction Is-MonitorMissing {\n    param([AllowNull()][string]$Value)\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\n    $t = $Value.Trim()\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\n}\n\n# ============================================================================\n# MAIN: COLLECTION\n# ============================================================================\n\nfunction Invoke-Collection {\n    param([string]$OutPath, [switch]$IncludePci)\n\n    $errors = New-Object System.Collections.Generic.List[string]\n\n    Write-Host \"`n========================================================\" -ForegroundColor Cyan\n    Write-Host \"   GATHERING HARDWARE SPECS... PLEASE WAIT\" -ForegroundColor Cyan\n    Write-Host \"========================================================\" -ForegroundColor Cyan\n\n    # --- Collect core system info ---\n    $sys  = $null\n    $bios = $null\n    $cpu  = $null\n    $os   = $null\n    $bb   = $null\n\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_ComputerSystem: $($_.Exception.Message)\") }\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\"Win32_BIOS: $($_.Exception.Message)\") }\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_Processor: $($_.Exception.Message)\") }\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_OperatingSystem: $($_.Exception.Message)\") }\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_BaseBoard: $($_.Exception.Message)\") }\n\n    # --- Derived values ---\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\n\n    $ramGB = $null\n    try {\n        if ($sys -and $sys.TotalPhysicalMemory) {\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\n        }\n    } catch {\n        $errors.Add(\"RAM calc: $($_.Exception.Message)\")\n    }\n\n    # --- Other sections ---\n    $netStr  = \u0027\u0027\n    $gpuStr  = \u0027\u0027\n    $diskStr = \u0027\u0027\n    $monStr  = \u0027\u0027\n    $pciStr  = \u0027\u0027\n\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\"Network: $($_.Exception.Message)\") }\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\"GPU: $($_.Exception.Message)\") }\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\"Disks: $($_.Exception.Message)\") }\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\"Monitors: $($_.Exception.Message)\") }\n\n    if ($IncludePci) {\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\"PCI devices: $($_.Exception.Message)\") }\n    }\n\n    # --- Build record ---\n    $record = [pscustomobject]@{\n        Hostname          = Clean-Cell $hostname\n        User              = Clean-Cell $env:USERNAME\n\n        Make_Model        = Clean-Cell ((\"{0} {1}\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\n\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\n        Baseboard_Product = Clean-Cell ($bb.Product)\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\n\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\n        BIOS_ReleaseDate  = Clean-Cell (try { ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027) } catch { \u0027\u0027 })\n\n        OS_Caption        = Clean-Cell ($os.Caption)\n        OS_Version        = Clean-Cell ($os.Version)\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\n\n        CPU               = Clean-Cell ($cpu.Name)\n        RAM_GB            = $ramGB\n\n        Network_Adapters  = Clean-Cell $netStr\n        GPUs              = Clean-Cell $gpuStr\n        Disk_Serials      = Clean-Cell $diskStr\n        Monitor_Serials   = Clean-Cell $monStr\n\n        PCI_Devices       = Clean-Cell $pciStr\n\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\n        Collector_Version = \u00272.0\u0027\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\n    }\n\n    # --- CSV append with header safety ---\n    $needHeader = $true\n    if (Test-Path -LiteralPath $OutPath) {\n        try {\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\n            if ($fi.Length -gt 0) { $needHeader = $false }\n        } catch { $needHeader = $true }\n    }\n\n    if ($needHeader) {\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\n    } else {\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\n    }\n\n    Write-Host \"`nSUCCESS!\" -ForegroundColor Green\n    Write-Host \"Data saved to: $OutPath\" -ForegroundColor Gray\n    if ($record.Errors) {\n        Write-Host (\"Warnings captured in Errors column: {0}\" -f $record.Errors) -ForegroundColor Yellow\n    }\n}\n\n# ============================================================================\n# MAIN: ANALYSIS\n# ============================================================================\n\nfunction Invoke-Analysis {\n    param(\n        [string]$InputPath,\n        [int]$StaleDaysThreshold,\n        [int]$MinRam,\n        [switch]$SkipCsv,\n        [string]$BaseDir\n    )\n\n    $ReportFile = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.txt\u0027\n    $IssuesCsv  = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.csv\u0027\n\n    if (-not (Test-Path -LiteralPath $InputPath)) {\n        Write-Warning \"Input file not found: $InputPath\"\n        Write-Warning \"Run the script without -AnalyzeOnly first to collect data.\"\n        return\n    }\n\n    $raw = Import-Csv -LiteralPath $InputPath\n    if (-not $raw -or $raw.Count -eq 0) {\n        Write-Warning \"Input file contains no rows: $InputPath\"\n        return\n    }\n\n    $headers = @()\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\n    $col = Get-ColumnMap -Headers $headers\n\n    $today = Get-Date\n\n    # Normalize data and add helper properties\n    $data = foreach ($r in $raw) {\n        $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\n        $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\n        $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\n        $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\n        $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\n        $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\n\n        $serialN = Normalize-Serial $serial\n        $scanDt  = Parse-ScanDate $scan\n        $ramGb   = Parse-RamGB $ram\n\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\n\n        # Asset key: prefer System Serial, fallback to Hostname\n        $assetKey = \u0027\u0027\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\n            $assetKey = $serialN\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\n            $assetKey = $h.Trim().ToUpperInvariant()\n        }\n\n        [pscustomobject]@{\n            Hostname        = $h.Trim()\n            User            = $u.Trim()\n            System_Serial   = $serialN\n            RAM_GB          = $ramGb\n            Monitor_Serials = $m.Trim()\n            Scan_Date       = $s.Trim()\n\n            ScanDateParsed  = $scanDt\n            AssetKey        = $assetKey\n            RawRow          = $r\n        }\n    }\n\n    # Latest record per asset\n    $latestByAsset = $data |\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\n        Group-Object -Property AssetKey |\n        ForEach-Object { $_.Group | Select-Object -First 1 }\n\n    $issues = New-Object System.Collections.Generic.List[object]\n\n    function Add-Issue {\n        param(\n            [Parameter(Mandatory)][string]$IssueType,\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\n            [string]$AssetKey,\n            [string]$Hostname,\n            [string]$User,\n            [string]$SystemSerial,\n            [string]$ScanDate,\n            [string]$Details\n        )\n\n        $issues.Add([pscustomobject]@{\n            IssueType     = $IssueType\n            Severity      = $Severity\n            AssetKey      = $AssetKey\n            Hostname      = $Hostname\n            User          = $User\n            System_Serial = $SystemSerial\n            Scan_Date     = $ScanDate\n            Details       = $Details\n        })\n    }\n\n    # 0) Data quality (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\n        }\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\n        }\n        if (-not $pc.ScanDateParsed) {\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\n        }\n    }\n\n    # 1) Duplicate serials (all rows; ignore blanks)\n    $dupeGroups = $data |\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\n        Group-Object -Property System_Serial |\n        Where-Object { $_.Count -gt 1 }\n\n    foreach ($g in $dupeGroups) {\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\n\n        $severity =\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\n            else { \u0027Info\u0027 }\n\n        $entries = $g.Group |\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\n            ForEach-Object {\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\n                \"{0} ({1})\" -f $_.Hostname, $d\n            }\n\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\n    }\n\n    # 2) Low RAM (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\"RAM_GB={0} (min {1})\" -f $pc.RAM_GB, $MinRam)\n        } elseif ($null -eq $pc.RAM_GB) {\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\n        }\n    }\n\n    # 3) Stale assets (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ($pc.ScanDateParsed) {\n            $ageDays = ($today - $pc.ScanDateParsed).Days\n            if ($ageDays -gt $StaleDaysThreshold) {\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\"Last seen {0} days ago (threshold {1})\" -f $ageDays, $StaleDaysThreshold)\n            }\n        }\n    }\n\n    # 4) Missing monitor serials (latest records)\n    foreach ($pc in $latestByAsset) {\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\n        }\n    }\n\n    # --- Build text report ---\n    $generated = Get-Date\n    $line = (\u0027=\u0027 * 70)\n\n    $txt = New-Object System.Collections.Generic.List[string]\n    $txt.Add($line)\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\n    $txt.Add(\"Generated: $generated\")\n    $txt.Add(\"Input:     $InputPath\")\n    $txt.Add((\"Assets:    {0} (latest per asset)\" -f $latestByAsset.Count))\n    $txt.Add((\"Rows:      {0} (raw rows in CSV)\" -f $data.Count))\n    $txt.Add((\"Settings:  MinRamGB={0}, StaleDays={1}\" -f $MinRam, $StaleDaysThreshold))\n    $txt.Add($line)\n    $txt.Add(\u0027\u0027)\n\n    if ($issues.Count -eq 0) {\n        $txt.Add(\u0027No issues found.\u0027)\n    } else {\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\n        foreach ($t in $byType) {\n            $txt.Add((\"--- {0} ({1}) ---\" -f $t.Name, $t.Count))\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\n\n                $txt.Add((\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\n            }\n            $txt.Add(\u0027\u0027)\n        }\n    }\n\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\n\n    if (-not $SkipCsv) {\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\n    }\n\n    # --- Console summary ---\n    Write-Host \"`n$line\" -ForegroundColor Cyan\n    Write-Host (\"Report saved: {0}\" -f $ReportFile) -ForegroundColor Green\n    if (-not $SkipCsv) { Write-Host (\"Issues CSV:   {0}\" -f $IssuesCsv) -ForegroundColor Green }\n    Write-Host (\"Issues found: {0}\" -f $issues.Count) -ForegroundColor Yellow\n    Write-Host $line -ForegroundColor Cyan\n\n    if ($issues.Count -gt 0) {\n        $sev = $issues | Group-Object Severity | Sort-Object Name\n        foreach ($s in $sev) {\n            $c = switch ($s.Name) {\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\n                default    { [ConsoleColor]::Gray }\n            }\n            Write-Host (\"{0}: {1}\" -f $s.Name, $s.Count) -ForegroundColor $c\n        }\n    }\n}\n\n# ============================================================================\n# ENTRY POINT\n# ============================================================================\n\nif (-not $AnalyzeOnly) {\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\n}\n\nif ($Analyze -or $AnalyzeOnly) {\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv\n}\n\nif (-not $AnalyzeOnly -and -not $Analyze) {\n    Write-Host \"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\" -ForegroundColor DarkGray\n}\n\n","languageId":"powershell"}],"capabilityType":15,"toolFormerData":{"tool":38,"toolCallId":"toolu_vrtx_01YMVmU8ZFMApkt3sxDVgYam","toolIndex":1,"modelCallId":"cc79b052-e7b8-4247-9dd5-abc3af1d5cf5","status":"completed","rawArgs":"{\"file_path\": \"USB-Inventory.ps1\", \"old_string\": \"function Invoke-Analysis {\\n    param(\\n        [string]$InputPath,\\n        [int]$StaleDaysThreshold,\\n        [int]$MinRam,\\n        [switch]$SkipCsv\\n    )\\n\\n    $ReportFile = Join-Path -Path $PSScriptRoot -ChildPath \u0027Inventory_Issues_Report.txt\u0027\\n    $IssuesCsv  = Join-Path -Path $PSScriptRoot -ChildPath \u0027Inventory_Issues_Report.csv\u0027\", \"new_string\": \"function Invoke-Analysis {\\n    param(\\n        [string]$InputPath,\\n        [int]$StaleDaysThreshold,\\n        [int]$MinRam,\\n        [switch]$SkipCsv,\\n        [string]$BaseDir\\n    )\\n\\n    $ReportFile = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.txt\u0027\\n    $IssuesCsv  = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.csv\u0027\"}","name":"search_replace","params":"{\"relativeWorkspacePath\":\"USB-Inventory.ps1\"}","additionalData":{"codeblockId":"c032cac4-fb60-4bcd-b6c4-1957e2855d2c"},"userDecision":"accepted","result":"{\"diff\":{\"chunks\":[{\"diffString\":\"          [int]$StaleDaysThreshold,\\n          [int]$MinRam,\\n-         [switch]$SkipCsv\\n+         [switch]$SkipCsv,\\n+         [string]$BaseDir\\n      )\\n  \\n-     $ReportFile = Join-Path -Path $PSScriptRoot -ChildPath \u0027Inventory_Issues_Report.txt\u0027\\n-     $IssuesCsv  = Join-Path -Path $PSScriptRoot -ChildPath \u0027Inventory_Issues_Report.csv\u0027\\n+     $ReportFile = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.txt\u0027\\n+     $IssuesCsv  = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.csv\u0027\\n  \\n      if (-not (Test-Path -LiteralPath $InputPath)) {\",\"oldStart\":610,\"newStart\":610,\"oldLines\":9,\"newLines\":10,\"linesRemoved\":3,\"linesAdded\":4}],\"editor\":\"EDITOR_AI\"},\"shouldAutoFixLints\":true,\"resultForModel\":\"The file USB-Inventory.ps1 has been updated.\",\"contentsAfterEdit\":\"#requires -Version 5.1\\n\u003c#\\n.SYNOPSIS\\n    USB-portable PC hardware inventory collection and analysis tool.\\n\\n.DESCRIPTION\\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\\n    script. Optionally runs health analysis to detect duplicates, stale assets,\\n    low RAM, and missing monitor data.\\n\\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\\n\\n.PARAMETER OutputFile\\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\\n\\n.PARAMETER IncludePciDevices\\n    Include detailed PCI device enumeration (can produce large output).\\n\\n.PARAMETER Analyze\\n    After collection, run health analysis on the CSV file.\\n\\n.PARAMETER AnalyzeOnly\\n    Skip collection; only run health analysis on existing CSV.\\n\\n.PARAMETER StaleDays\\n    Threshold in days for flagging stale assets. Default: 90.\\n\\n.PARAMETER MinRamGB\\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\\n\\n.PARAMETER NoCsv\\n    Do not output Inventory_Issues_Report.csv (text report only).\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1\\n    Collect inventory from this PC into PC_Inventory_Master.csv.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -IncludePciDevices -Analyze\\n    Collect inventory with PCI devices, then run health analysis.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\\n    Analyze existing CSV with custom thresholds (no new collection).\\n#\u003e\\n\\n[CmdletBinding()]\\nparam(\\n    [string]$OutputFile,\\n    [switch]$IncludePciDevices,\\n    [switch]$Analyze,\\n    [switch]$AnalyzeOnly,\\n    [int]$StaleDays = 90,\\n    [int]$MinRamGB = 8,\\n    [switch]$NoCsv\\n)\\n\\nSet-StrictMode -Version Latest\\n$ErrorActionPreference = \u0027Stop\u0027\\n\\n# Resolve script root (handles -File invocation where $PSScriptRoot may be empty)\\n$ScriptDir = $PSScriptRoot\\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n    $ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition\\n}\\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n    $ScriptDir = $PWD.Path\\n}\\n\\n# Default OutputFile if not specified\\nif ([string]::IsNullOrWhiteSpace($OutputFile)) {\\n    $OutputFile = Join-Path -Path $ScriptDir -ChildPath \u0027PC_Inventory_Master.csv\u0027\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - COLLECTION\\n# ============================================================================\\n\\nfunction Clean-Cell {\\n    param([AllowNull()][string]$Text)\\n    if ($null -eq $Text) { return \u0027\u0027 }\\n    return ($Text -replace \\\"(`r`n|`n|`r|`t)+\\\", \u0027 \u0027).Trim()\\n}\\n\\nfunction Convert-UShortArrayToString {\\n    param([AllowNull()]$Arr)\\n    if ($null -eq $Arr) { return \u0027\u0027 }\\n    $chars = foreach ($x in $Arr) {\\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\\n    }\\n    return ( -join $chars ).Trim()\\n}\\n\\nfunction Get-MonitorInventory {\\n    \u003c#\\n      Preferred: root\\\\wmi:WmiMonitorID (easy, consistent, usually no admin)\\n      Fallback: registry EDID decode under HKLM:\\\\SYSTEM\\\\CCS\\\\Enum\\\\DISPLAY\\n    #\u003e\\n\\n    $results = New-Object System.Collections.Generic.List[string]\\n\\n    # --- Preferred path: WmiMonitorID ---\\n    try {\\n        $wmiMons = Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorID -ErrorAction Stop\\n        foreach ($m in $wmiMons) {\\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\\n\\n            $label = @()\\n            if ($mfg)  { $label += $mfg }\\n            if ($name) { $label += $name }\\n\\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\\n            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } else { \u0027SN:(none)\u0027 }\\n\\n            $results.Add(\\\"$displayName ($serialPart)\\\")\\n        }\\n    } catch {\\n        # WmiMonitorID not available; fall through to EDID fallback\\n    }\\n\\n    if ($results.Count -gt 0) {\\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n    }\\n\\n    # --- Fallback path: registry EDID decode ---\\n    function Get-EdidDescriptorString {\\n        param(\\n            [byte[]]$Edid,\\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\\n        )\\n\\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\\n\\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\\n\\n        foreach ($offset in 54,72,90,108) {\\n            if (($offset + 18) -gt $Edid.Length) { continue }\\n\\n            # Descriptor: 00 00 00 {tag} 00 ...\\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\\n\\n                $bytes = $Edid[($offset+5)..($offset+17)]\\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\\n                $text = ($text -replace \\\"[`0`n`r]+\\\", \u0027\u0027).Trim()\\n                if ($text) { return $text }\\n            }\\n        }\\n\\n        return \u0027\u0027\\n    }\\n\\n    try {\\n        $root = \u0027HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Enum\\\\DISPLAY\u0027\\n        if (Test-Path -LiteralPath $root) {\\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\\n                    if (Test-Path -LiteralPath $params) {\\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\\n                        if ($edid -is [byte[]]) {\\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\\n\\n                            # Numeric serial (bytes 12-15 LE) sometimes present\\n                            $num = [BitConverter]::ToUInt32($edid, 12)\\n                            $numStr = if ($num -ne 0) { \\\"NUM:$num\\\" } else { \u0027\u0027 }\\n\\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\\n                            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\\n\\n                            $results.Add(\\\"$displayName ($serialPart)\\\")\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    } catch {\\n        # EDID fallback failed silently\\n    }\\n\\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-NetworkInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\\n\\n    if ($hasNetAdapter -and $hasNetIpCfg) {\\n        try {\\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\\n            foreach ($a in $adapters) {\\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\\n                $ipv4 = @()\\n                if ($cfg -and $cfg.IPv4Address) {\\n                    $ipv4 = $cfg.IPv4Address |\\n                        ForEach-Object { $_.IPAddress } |\\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\\n                }\\n                $gw = @()\\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\\n                }\\n\\n                $parts = @()\\n                $parts += (Clean-Cell $a.Name)\\n                if ($a.MacAddress) { $parts += \\\"MAC:$($a.MacAddress)\\\" }\\n                if ($ipv4.Count -gt 0) { $parts += (\\\"IPv4:\\\" + ($ipv4 -join \u0027;\u0027)) }\\n                if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n                $items.Add(($parts -join \u0027 \u0027))\\n            }\\n        } catch {\\n            # Fall back to CIM below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\\n            Where-Object { $_.IPEnabled -eq $true }\\n\\n        foreach ($n in $net) {\\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\\n            $mac  = $n.MACAddress\\n            $ips  = @()\\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\\n            $gw   = @()\\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\\n\\n            $parts = @()\\n            $parts += (Clean-Cell $name)\\n            if ($mac) { $parts += \\\"MAC:$mac\\\" }\\n            if ($ips.Count -gt 0) { $parts += (\\\"IP:\\\" + ($ips -join \u0027;\u0027)) }\\n            if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n            $items.Add(($parts -join \u0027 \u0027))\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-GpuInventory {\\n    $gpus = New-Object System.Collections.Generic.List[string]\\n\\n    # CIM GPUs\\n    try {\\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\\n        foreach ($g in $vc) {\\n            $name = Clean-Cell $g.Name\\n            $pnp  = Clean-Cell $g.PNPDeviceID\\n            if ($name -or $pnp) {\\n                $gpus.Add((\\\"{0}{1}\\\" -f $name, $(if ($pnp) { \\\" [ID:$pnp]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    # Optional NVIDIA serials if nvidia-smi exists\\n    try {\\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\\n        if ($nvsmi) {\\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\\n            foreach ($line in @($raw)) {\\n                $t = Clean-Cell $line\\n                if ($t) { $gpus.Add(\\\"NVIDIA $t\\\") }\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-DiskInventory {\\n    $disks = New-Object System.Collections.Generic.List[string]\\n\\n    # Prefer Storage module when available\\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasPhysicalDisk) {\\n        try {\\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\\n                $name = Clean-Cell $d.FriendlyName\\n                $sn   = Clean-Cell $d.SerialNumber\\n                $mt   = Clean-Cell ([string]$d.MediaType)\\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n                $parts = @()\\n                if ($name) { $parts += $name }\\n                if ($sn)   { $parts += \\\"SN:$sn\\\" }\\n                if ($mt)   { $parts += \\\"Type:$mt\\\" }\\n                if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\\n            $model = Clean-Cell $d.Model\\n            $sn = \u0027\u0027\\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\\n            $devId = Clean-Cell $d.DeviceID\\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n            $parts = @()\\n            if ($model) { $parts += $model }\\n            if ($sn)    { $parts += \\\"SN:$sn\\\" }\\n            if ($devId) { $parts += \\\"Dev:$devId\\\" }\\n            if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-PciDeviceInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasGetPnpDevice) {\\n        try {\\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\\n                Where-Object { $_.InstanceId -like \u0027PCI\\\\*\u0027 } |\\n                Sort-Object -Property Class, FriendlyName, Name\\n\\n            foreach ($d in $devs) {\\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\\n                $name = Clean-Cell $name\\n                $cls  = Clean-Cell $d.Class\\n                $id   = Clean-Cell $d.InstanceId\\n                if ($name -or $id) {\\n                    $items.Add((\\\"{0}{1}{2}\\\" -f $name, $(if ($cls) { \\\" [Class:$cls]\\\" } else { \u0027\u0027 }), $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n                }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM Win32_PnPEntity\\n    try {\\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\\\*\u0027 } |\\n            Sort-Object -Property Name\\n\\n        foreach ($d in $devs) {\\n            $name = Clean-Cell $d.Name\\n            $id   = Clean-Cell $d.PNPDeviceID\\n            if ($name -or $id) {\\n                $items.Add((\\\"{0}{1}\\\" -f $name, $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - ANALYSIS\\n# ============================================================================\\n\\nfunction Get-ColumnMap {\\n    param([string[]]$Headers)\\n\\n    $map = @{\\n        Hostname        = \u0027Hostname\u0027\\n        User            = \u0027User\u0027\\n        System_Serial   = \u0027System_Serial\u0027\\n        RAM_GB          = \u0027RAM_GB\u0027\\n        Monitor_Serials = \u0027Monitor_Serials\u0027\\n        Scan_Date       = \u0027Scan_Date\u0027\\n    }\\n\\n    foreach ($k in @($map.Keys)) {\\n        if ($Headers -notcontains $map[$k]) {\\n            $alts = switch ($k) {\\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\\n                default           { @() }\\n            }\\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\\n            if ($found) { $map[$k] = $found }\\n        }\\n    }\\n\\n    return $map\\n}\\n\\nfunction Parse-ScanDate {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    $dt = $null\\n\\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n\\n    if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\\n\\n    return $null\\n}\\n\\nfunction Normalize-Serial {\\n    param([AllowNull()][string]$Serial)\\n\\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\\n    $s = ($Serial.Trim())\\n\\n    $bad = @(\\n        \u0027To Be Filled By O.E.M.\u0027,\\n        \u0027To Be Filled By OEM\u0027,\\n        \u0027Default string\u0027,\\n        \u0027System Serial Number\u0027,\\n        \u0027None\u0027,\\n        \u0027N/A\u0027,\\n        \u0027NA\u0027,\\n        \u00270\u0027,\\n        \u002700000000\u0027,\\n        \u00270000000000\u0027,\\n        \u00270000000000000000\u0027\\n    )\\n\\n    if ($bad -contains $s) { return \u0027\u0027 }\\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\\n\\n    return $s.ToUpperInvariant()\\n}\\n\\nfunction Parse-RamGB {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    $m = [regex]::Match($s, \u0027(\\\\d+)(\\\\.\\\\d+)?\u0027)\\n    if (-not $m.Success) { return $null }\\n\\n    $n = $null\\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\\n        return [int][math]::Round($n, 0)\\n    }\\n\\n    return $null\\n}\\n\\nfunction Is-MonitorMissing {\\n    param([AllowNull()][string]$Value)\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\\n    $t = $Value.Trim()\\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\\n}\\n\\n# ============================================================================\\n# MAIN: COLLECTION\\n# ============================================================================\\n\\nfunction Invoke-Collection {\\n    param([string]$OutPath, [switch]$IncludePci)\\n\\n    $errors = New-Object System.Collections.Generic.List[string]\\n\\n    Write-Host \\\"`n========================================================\\\" -ForegroundColor Cyan\\n    Write-Host \\\"   GATHERING HARDWARE SPECS... PLEASE WAIT\\\" -ForegroundColor Cyan\\n    Write-Host \\\"========================================================\\\" -ForegroundColor Cyan\\n\\n    # --- Collect core system info ---\\n    $sys  = $null\\n    $bios = $null\\n    $cpu  = $null\\n    $os   = $null\\n    $bb   = $null\\n\\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_ComputerSystem: $($_.Exception.Message)\\\") }\\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\\\"Win32_BIOS: $($_.Exception.Message)\\\") }\\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_Processor: $($_.Exception.Message)\\\") }\\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_OperatingSystem: $($_.Exception.Message)\\\") }\\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_BaseBoard: $($_.Exception.Message)\\\") }\\n\\n    # --- Derived values ---\\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\\n\\n    $ramGB = $null\\n    try {\\n        if ($sys -and $sys.TotalPhysicalMemory) {\\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\\n        }\\n    } catch {\\n        $errors.Add(\\\"RAM calc: $($_.Exception.Message)\\\")\\n    }\\n\\n    # --- Other sections ---\\n    $netStr  = \u0027\u0027\\n    $gpuStr  = \u0027\u0027\\n    $diskStr = \u0027\u0027\\n    $monStr  = \u0027\u0027\\n    $pciStr  = \u0027\u0027\\n\\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\\\"Network: $($_.Exception.Message)\\\") }\\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\\\"GPU: $($_.Exception.Message)\\\") }\\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\\\"Disks: $($_.Exception.Message)\\\") }\\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\\\"Monitors: $($_.Exception.Message)\\\") }\\n\\n    if ($IncludePci) {\\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\\\"PCI devices: $($_.Exception.Message)\\\") }\\n    }\\n\\n    # --- Build record ---\\n    $record = [pscustomobject]@{\\n        Hostname          = Clean-Cell $hostname\\n        User              = Clean-Cell $env:USERNAME\\n\\n        Make_Model        = Clean-Cell ((\\\"{0} {1}\\\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\\n\\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\\n        Baseboard_Product = Clean-Cell ($bb.Product)\\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\\n\\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\\n        BIOS_ReleaseDate  = Clean-Cell (try { ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027) } catch { \u0027\u0027 })\\n\\n        OS_Caption        = Clean-Cell ($os.Caption)\\n        OS_Version        = Clean-Cell ($os.Version)\\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\\n\\n        CPU               = Clean-Cell ($cpu.Name)\\n        RAM_GB            = $ramGB\\n\\n        Network_Adapters  = Clean-Cell $netStr\\n        GPUs              = Clean-Cell $gpuStr\\n        Disk_Serials      = Clean-Cell $diskStr\\n        Monitor_Serials   = Clean-Cell $monStr\\n\\n        PCI_Devices       = Clean-Cell $pciStr\\n\\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\\n        Collector_Version = \u00272.0\u0027\\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\\n    }\\n\\n    # --- CSV append with header safety ---\\n    $needHeader = $true\\n    if (Test-Path -LiteralPath $OutPath) {\\n        try {\\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\\n            if ($fi.Length -gt 0) { $needHeader = $false }\\n        } catch { $needHeader = $true }\\n    }\\n\\n    if ($needHeader) {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\\n    } else {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\\n    }\\n\\n    Write-Host \\\"`nSUCCESS!\\\" -ForegroundColor Green\\n    Write-Host \\\"Data saved to: $OutPath\\\" -ForegroundColor Gray\\n    if ($record.Errors) {\\n        Write-Host (\\\"Warnings captured in Errors column: {0}\\\" -f $record.Errors) -ForegroundColor Yellow\\n    }\\n}\\n\\n# ============================================================================\\n# MAIN: ANALYSIS\\n# ============================================================================\\n\\nfunction Invoke-Analysis {\\n    param(\\n        [string]$InputPath,\\n        [int]$StaleDaysThreshold,\\n        [int]$MinRam,\\n        [switch]$SkipCsv,\\n        [string]$BaseDir\\n    )\\n\\n    $ReportFile = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.txt\u0027\\n    $IssuesCsv  = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.csv\u0027\\n\\n    if (-not (Test-Path -LiteralPath $InputPath)) {\\n        Write-Warning \\\"Input file not found: $InputPath\\\"\\n        Write-Warning \\\"Run the script without -AnalyzeOnly first to collect data.\\\"\\n        return\\n    }\\n\\n    $raw = Import-Csv -LiteralPath $InputPath\\n    if (-not $raw -or $raw.Count -eq 0) {\\n        Write-Warning \\\"Input file contains no rows: $InputPath\\\"\\n        return\\n    }\\n\\n    $headers = @()\\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\\n    $col = Get-ColumnMap -Headers $headers\\n\\n    $today = Get-Date\\n\\n    # Normalize data and add helper properties\\n    $data = foreach ($r in $raw) {\\n        $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\\n        $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\\n        $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\\n        $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\\n        $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\\n        $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\\n\\n        $serialN = Normalize-Serial $serial\\n        $scanDt  = Parse-ScanDate $scan\\n        $ramGb   = Parse-RamGB $ram\\n\\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\\n\\n        # Asset key: prefer System Serial, fallback to Hostname\\n        $assetKey = \u0027\u0027\\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\\n            $assetKey = $serialN\\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\\n            $assetKey = $h.Trim().ToUpperInvariant()\\n        }\\n\\n        [pscustomobject]@{\\n            Hostname        = $h.Trim()\\n            User            = $u.Trim()\\n            System_Serial   = $serialN\\n            RAM_GB          = $ramGb\\n            Monitor_Serials = $m.Trim()\\n            Scan_Date       = $s.Trim()\\n\\n            ScanDateParsed  = $scanDt\\n            AssetKey        = $assetKey\\n            RawRow          = $r\\n        }\\n    }\\n\\n    # Latest record per asset\\n    $latestByAsset = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\\n        Group-Object -Property AssetKey |\\n        ForEach-Object { $_.Group | Select-Object -First 1 }\\n\\n    $issues = New-Object System.Collections.Generic.List[object]\\n\\n    function Add-Issue {\\n        param(\\n            [Parameter(Mandatory)][string]$IssueType,\\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\\n            [string]$AssetKey,\\n            [string]$Hostname,\\n            [string]$User,\\n            [string]$SystemSerial,\\n            [string]$ScanDate,\\n            [string]$Details\\n        )\\n\\n        $issues.Add([pscustomobject]@{\\n            IssueType     = $IssueType\\n            Severity      = $Severity\\n            AssetKey      = $AssetKey\\n            Hostname      = $Hostname\\n            User          = $User\\n            System_Serial = $SystemSerial\\n            Scan_Date     = $ScanDate\\n            Details       = $Details\\n        })\\n    }\\n\\n    # 0) Data quality (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\\n        }\\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\\n        }\\n        if (-not $pc.ScanDateParsed) {\\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\\n        }\\n    }\\n\\n    # 1) Duplicate serials (all rows; ignore blanks)\\n    $dupeGroups = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\\n        Group-Object -Property System_Serial |\\n        Where-Object { $_.Count -gt 1 }\\n\\n    foreach ($g in $dupeGroups) {\\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\\n\\n        $severity =\\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\\n            else { \u0027Info\u0027 }\\n\\n        $entries = $g.Group |\\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\\n            ForEach-Object {\\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\\n                \\\"{0} ({1})\\\" -f $_.Hostname, $d\\n            }\\n\\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\\\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\\\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\\n    }\\n\\n    # 2) Low RAM (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\\\"RAM_GB={0} (min {1})\\\" -f $pc.RAM_GB, $MinRam)\\n        } elseif ($null -eq $pc.RAM_GB) {\\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\\n        }\\n    }\\n\\n    # 3) Stale assets (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($pc.ScanDateParsed) {\\n            $ageDays = ($today - $pc.ScanDateParsed).Days\\n            if ($ageDays -gt $StaleDaysThreshold) {\\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\\\"Last seen {0} days ago (threshold {1})\\\" -f $ageDays, $StaleDaysThreshold)\\n            }\\n        }\\n    }\\n\\n    # 4) Missing monitor serials (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\\n        }\\n    }\\n\\n    # --- Build text report ---\\n    $generated = Get-Date\\n    $line = (\u0027=\u0027 * 70)\\n\\n    $txt = New-Object System.Collections.Generic.List[string]\\n    $txt.Add($line)\\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\\n    $txt.Add(\\\"Generated: $generated\\\")\\n    $txt.Add(\\\"Input:     $InputPath\\\")\\n    $txt.Add((\\\"Assets:    {0} (latest per asset)\\\" -f $latestByAsset.Count))\\n    $txt.Add((\\\"Rows:      {0} (raw rows in CSV)\\\" -f $data.Count))\\n    $txt.Add((\\\"Settings:  MinRamGB={0}, StaleDays={1}\\\" -f $MinRam, $StaleDaysThreshold))\\n    $txt.Add($line)\\n    $txt.Add(\u0027\u0027)\\n\\n    if ($issues.Count -eq 0) {\\n        $txt.Add(\u0027No issues found.\u0027)\\n    } else {\\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\\n        foreach ($t in $byType) {\\n            $txt.Add((\\\"--- {0} ({1}) ---\\\" -f $t.Name, $t.Count))\\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\\n\\n                $txt.Add((\\\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\\\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\\n            }\\n            $txt.Add(\u0027\u0027)\\n        }\\n    }\\n\\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\\n\\n    if (-not $SkipCsv) {\\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\\n    }\\n\\n    # --- Console summary ---\\n    Write-Host \\\"`n$line\\\" -ForegroundColor Cyan\\n    Write-Host (\\\"Report saved: {0}\\\" -f $ReportFile) -ForegroundColor Green\\n    if (-not $SkipCsv) { Write-Host (\\\"Issues CSV:   {0}\\\" -f $IssuesCsv) -ForegroundColor Green }\\n    Write-Host (\\\"Issues found: {0}\\\" -f $issues.Count) -ForegroundColor Yellow\\n    Write-Host $line -ForegroundColor Cyan\\n\\n    if ($issues.Count -gt 0) {\\n        $sev = $issues | Group-Object Severity | Sort-Object Name\\n        foreach ($s in $sev) {\\n            $c = switch ($s.Name) {\\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\\n                default    { [ConsoleColor]::Gray }\\n            }\\n            Write-Host (\\\"{0}: {1}\\\" -f $s.Name, $s.Count) -ForegroundColor $c\\n        }\\n    }\\n}\\n\\n# ============================================================================\\n# ENTRY POINT\\n# ============================================================================\\n\\nif (-not $AnalyzeOnly) {\\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\\n}\\n\\nif ($Analyze -or $AnalyzeOnly) {\\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv\\n}\\n\\nif (-not $AnalyzeOnly -and -not $Analyze) {\\n    Write-Host \\\"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\\\" -ForegroundColor DarkGray\\n}\\n\\n\"}"},"checkpointId":"94f1f3f0-dfc8-471d-813e-3fa8db4b2e10"},"bubbleId":"0abf7003-d51c-443b-9179-cb81fca5c8cc"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"11750123-d527-47b2-9675-09aec8253cd9","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:01:27.821Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"7ad48635-4ff9-4fd8-b34c-b05c99042565","usageUuid":"de3d8dc5-4276-4970-be5b-c16afa5cc3c9","capabilityType":30,"thinking":{"text":"Let me run the test again.","signature":"EsQBCkgICxACGAIqQDXCdAj2EVRf37TKqcAsqCGN4lgIUivOXLzIKuNSTBSRq5HZx3Jv+sJu2bClpVqweOyU6asFY6PYratzwpqoLPsSDBR78s74sRiBimMRXxoMN8pMbYH5EoCQ+C26IjACpSPaPaCSUK/TKaReI0wHN7hEUugd5fw1d3LVEo1APrKMIOIR3XBbdhBUv9BdzNsqKkZE7jO1neDnjX06kkb5JUBHPw+oIA/TEEqLJqw7XLubq9mSoyg1tC4bYBgB"},"thinkingStyle":1,"thinkingDurationMs":701},"bubbleId":"11750123-d527-47b2-9675-09aec8253cd9"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"12596d01-2cf1-4f2e-80b9-17a5cd0e81d6","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:01:52.957Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"b86b7ff2-d732-404c-b869-8543e3c10e10","usageUuid":"452e6d02-2c74-4eea-bce2-e95facb54c88","capabilityType":30,"thinking":{"text":"The script is working well:\n\n1. **CSV Output**: Contains comprehensive data including:\n   - Hostname, User, Make_Model, System_Serial\n   - Baseboard info, BIOS Version\n   - OS details, CPU, RAM\n   - GPU with ID, Disk with SN and type\n   - Monitor with SN\n   - Timestamps and collector version\n\n2. **Analysis Report**: Correctly detected that the same serial number appears 4 times (from our test runs) but marked it as \"Info\" level since it\u0027s the same hostname/user (expected for re-scans).\n\nThe script is complete and working. Let me mark the test todo as complete.","signature":"EtgFCkgICxACGAIqQFPW9QxL1ZBLQSDCm+eiAaj9URlgrTslW30Pq7IJr3CF7Fyt+qeRPNXvQGQGJKkWtxcWynWZQVqrK2I10ydoSx4SDB87uq5Tjg11O1R+AhoMP5kl1DDBQem71+h6IjDCVJFQXq/0hXYRdXuA4Eog9zG3kQka4e+vYJmgadn0Xh0tiqOegYOreJp5V264MiIqvQRNYyL6cil58etfQ5Pl74pmGm5lTXSAiq3RN0nY0dOyMGtrx6RDCNYyEhBPvBOGLyClc82tNTQ8kY7Gvl4aNJ2glnnh+nhSL2cIRcx2RWJFfoU1/vkK6kYiMX3+ERaPHhbddGO2VnM/uYpkeEewo4oW19+zfL1htIxX79/aUhB14zCiOtYfIW06RImNgSW+fZ1+ywX+2NMPWNuy1W9HMQLsBbhe49qypnllZi0XyFwhAw7jUUBdYuKvF+zBXnuFVA0tHyAkFoXUCgnTL85M7z8MlFfHzajO5pUucFuCKTld9Zyi8wWOGyI1HYlaJeMVcpMgMGeI2rbXJhWc4VFKNTf58LGtD9tKAHi9TQN+RcxLk+MpTv4DXntPPyLws8YdR1sUcWvIqFpJOlMpChf3qh+CPXRU9jsyelUOCkV9tawr4eD9hFl5CV70kuMS17onspwXHtb1HxOrGNqJSzaQM0rp2HC7FDjENQa5/UIilhYH9V3c6Ta3jljV+efj3FuDoHvF2dJxjoJMp2y2ZPQtQklgr/+3zBl1UQ+/K/J3qMHuy3ZFPi76GWdiMS6CCP2r695RPJilh0G5gro3FJ7W+HMZ5cvbubH9xgVGdHP0LFIlxPIic5I5nBG5CUmxZhUBONJJex69SfA1c8T/vEuDT8IS6hQx6U0SfEPKLMvHbyAP9UvFmuVopbRZgiys7QGmujohC94a+aQPXK5fRPzxp+dO+eu3nlvjT38joORc/mehbjgzBgKCkhdVVUX18RIYAQ=="},"thinkingStyle":1,"thinkingDurationMs":4810},"bubbleId":"12596d01-2cf1-4f2e-80b9-17a5cd0e81d6"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"184676af-8599-4a45-85fc-c7a3ffc50b4a","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":["{\"content\":\"Create USB-Inventory.ps1 combining collection + analysis logic\",\"status\":\"completed\",\"id\":\"synth-script\"}","{\"content\":\"Test script execution on local machine\",\"status\":\"completed\",\"id\":\"test-local\"}"],"createdAt":"2025-12-29T01:02:00.185Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"452e6d02-2c74-4eea-bce2-e95facb54c88","codeBlocks":[],"capabilityType":15,"toolFormerData":{"tool":35,"toolCallId":"toolu_vrtx_01B9RYWuchfwTT86RpK2Dykq","toolIndex":1,"modelCallId":"dab4372d-ff11-4e4e-b1de-4a7f2a006aa5","status":"completed","rawArgs":"{\"todos\": [{\"id\": \"synth-script\", \"content\": \"Create USB-Inventory.ps1 combining collection + analysis logic\", \"status\": \"completed\"}, {\"id\": \"test-local\", \"content\": \"Test script execution on local machine\", \"status\": \"completed\"}], \"merge\": true}","name":"todo_write","params":"{\"todos\":[{\"content\":\"Create USB-Inventory.ps1 combining collection + analysis logic\",\"status\":\"completed\",\"id\":\"synth-script\"}]}","additionalData":{},"result":"{\"success\":true,\"finalTodos\":[{\"content\":\"Create USB-Inventory.ps1 combining collection + analysis logic\",\"status\":\"completed\",\"id\":\"synth-script\"},{\"content\":\"Test script execution on local machine\",\"status\":\"completed\",\"id\":\"test-local\"}],\"initialTodos\":[{\"content\":\"Create USB-Inventory.ps1 combining collection + analysis logic\",\"status\":\"completed\",\"id\":\"synth-script\"},{\"content\":\"Test script execution on local machine\",\"status\":\"in_progress\",\"id\":\"test-local\"}],\"wasMerge\":true}"}},"bubbleId":"184676af-8599-4a45-85fc-c7a3ffc50b4a"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"1ca70355-50a7-4ec0-9d99-39d52ede94b9","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:59:14.981Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"e9c16abc-6c1c-449d-b840-6078a84b45b4","codeBlocks":[],"capabilityType":15,"toolFormerData":{"tool":15,"toolCallId":"toolu_vrtx_01Pt9nZ1tqdHqPerKLx4Mhon","toolIndex":1,"modelCallId":"a7519ae0-34fe-4053-9b75-4e662c00bb06","status":"completed","rawArgs":"{\"command\": \"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\"\", \"is_background\": false, \"explanation\": \"Testing the USB-Inventory.ps1 script to collect hardware inventory from the local machine.\"}","name":"run_terminal_cmd","params":"{\"command\":\"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\"\",\"requireUserApproval\":true,\"parsingResult\":{\"executableCommands\":[{\"name\":\"powershell\",\"args\":[{\"type\":\"word\",\"value\":\"-ExecutionPolicy\"},{\"type\":\"word\",\"value\":\"Bypass\"},{\"type\":\"word\",\"value\":\"-File\"},{\"type\":\"string\",\"value\":\"\\\".\\\\USB-Inventory.ps1\\\"\"}],\"fullText\":\"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\"\"}]},\"fileOutputThresholdBytes\":\"20000\"}","additionalData":{"status":"success","reviewData":{"status":"Done","selectedOption":"run","isShowingInput":false,"candidatesForAllowlist":["powershell"],"approvalType":"allowlist"},"sessionId":"5dd745c9-3368-496b-b5ac-9b78458b05d4","startAtBufferLine":0,"previousAttempt":"{\"output\":\"Join-Path : Cannot bind argument to parameter \u0027Path\u0027 because it is an empty string.\\r\\nAt C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\USB-Inventory.ps1:50 char:44\\r\\n+     [string]$OutputFile = (Join-Path -Path $PSScriptRoot -ChildPath \u0027 ...\\r\\n+                                            ~~~~~~~~~~~~~\\r\\n    + CategoryInfo          : InvalidData: (:) [Join-Path], ParentContainsErrorRecordException\\r\\n    + FullyQualifiedErrorId : ParameterArgumentValidationErrorEmptyStringNotAllowed,Microsoft.PowerShell.Commands.Join \\r\\n   PathCommand\\r\\n \\r\\n\",\"rejected\":false,\"notInterrupted\":true,\"endedReason\":\"RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED\",\"exitCodeV2\":1,\"effectiveSandboxPolicy\":{\"type\":\"TYPE_INSECURE_NONE\"}}"},"result":"{\"output\":\"Join-Path : Cannot bind argument to parameter \u0027Path\u0027 because it is an empty string.\\r\\nAt C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\USB-Inventory.ps1:50 char:44\\r\\n+     [string]$OutputFile = (Join-Path -Path $PSScriptRoot -ChildPath \u0027 ...\\r\\n+                                            ~~~~~~~~~~~~~\\r\\n    + CategoryInfo          : InvalidData: (:) [Join-Path], ParentContainsErrorRecordException\\r\\n    + FullyQualifiedErrorId : ParameterArgumentValidationErrorEmptyStringNotAllowed,Microsoft.PowerShell.Commands.Join \\r\\n   PathCommand\\r\\n \\r\\n\",\"rejected\":false,\"notInterrupted\":true,\"endedReason\":\"RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED\",\"exitCodeV2\":1,\"effectiveSandboxPolicy\":{\"type\":\"TYPE_INSECURE_NONE\"}}"}},"bubbleId":"1ca70355-50a7-4ec0-9d99-39d52ede94b9"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"1da42da3-d111-4a52-a339-96c1afef1bc0","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:01:34.519Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"de3d8dc5-4276-4970-be5b-c16afa5cc3c9","codeBlocks":[],"capabilityType":15,"toolFormerData":{"tool":15,"toolCallId":"toolu_vrtx_01Hc2raV9gkBi7rGCk2DXwg4","toolIndex":1,"modelCallId":"897907ed-5af9-4ddb-b885-62aa7f584ef9","status":"completed","rawArgs":"{\"command\": \"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\" -Analyze\", \"is_background\": false, \"explanation\": \"Testing -Analyze after fixing .Count property access issues.\"}","name":"run_terminal_cmd","params":"{\"command\":\"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\" -Analyze\",\"requireUserApproval\":true,\"parsingResult\":{\"executableCommands\":[{\"name\":\"powershell\",\"args\":[{\"type\":\"word\",\"value\":\"-ExecutionPolicy\"},{\"type\":\"word\",\"value\":\"Bypass\"},{\"type\":\"word\",\"value\":\"-File\"},{\"type\":\"string\",\"value\":\"\\\".\\\\USB-Inventory.ps1\\\"\"},{\"type\":\"word\",\"value\":\"-Analyze\"}],\"fullText\":\"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\" -Analyze\"}]},\"fileOutputThresholdBytes\":\"20000\"}","additionalData":{"status":"success","reviewData":{"status":"Done","selectedOption":"run","isShowingInput":false,"candidatesForAllowlist":["powershell"],"approvalType":"allowlist"},"sessionId":"5dd745c9-3368-496b-b5ac-9b78458b05d4","startAtBufferLine":0,"previousAttempt":"{\"output\":\"\\n========================================================\\n   GATHERING HARDWARE SPECS... PLEASE WAIT\\n========================================================\\n\\nSUCCESS!\\nData saved to: C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\PC_Inventory_Master.csv\\n\\n======================================================================\\nReport saved: C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\Inventory_Issues_Report.txt\\nIssues CSV:   C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\Inventory_Issues_Report.csv\\nIssues found: 1\\n======================================================================\\nInfo: 1\\n\",\"rejected\":false,\"notInterrupted\":true,\"endedReason\":\"RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED\",\"exitCodeV2\":0,\"effectiveSandboxPolicy\":{\"type\":\"TYPE_INSECURE_NONE\"}}"},"result":"{\"output\":\"\\n========================================================\\n   GATHERING HARDWARE SPECS... PLEASE WAIT\\n========================================================\\n\\nSUCCESS!\\nData saved to: C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\PC_Inventory_Master.csv\\n\\n======================================================================\\nReport saved: C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\Inventory_Issues_Report.txt\\nIssues CSV:   C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\Inventory_Issues_Report.csv\\nIssues found: 1\\n======================================================================\\nInfo: 1\\n\",\"rejected\":false,\"notInterrupted\":true,\"endedReason\":\"RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED\",\"exitCodeV2\":0,\"effectiveSandboxPolicy\":{\"type\":\"TYPE_INSECURE_NONE\"}}"}},"bubbleId":"1da42da3-d111-4a52-a339-96c1afef1bc0"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"2605ca52-3b21-4912-b155-f4f27d4bfc1c","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:00:23.049Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"5c784ffe-c08e-4d4c-bf6d-deb5767c0302","usageUuid":"11f099f5-17f3-4a84-bdbf-9f242bbb6f14","capabilityType":30,"thinking":{"text":"The collection worked. Now let me verify the CSV content and also test with the -Analyze flag.","signature":"EogCCkgICxACGAIqQH+tk2m2y+dRJ3jSSCOcCYmJ1R7BArGRjNqCgYCAhDUEnRv+BarcIJtryfapcXX1ZrVvAA3MthIDnW9B8eqH5eoSDD1XjGEKs9qfYOFWERoM5vCDYS1XitUPTiFbIjBYThQePM5Jcqx3LazF3MT2euKaturUMbp97fNvZhRkl69ZXuGOnaRJXCILtj0Lfz4qbvbOkin6fx7FC+i0S2RWn80ypREIlqxiAliugHNWvc2rSA8y1uvGbGTROn3/3jHC7XI18j8+C/sI+oYoe4Kn/zpsuI4UCmr8ng6zpX4nZ8jOj5Xf18yw5ExX7x4+Y2b987ih2w6z0wVg2yV6gA1pGAE="},"thinkingStyle":1,"thinkingDurationMs":966},"bubbleId":"2605ca52-3b21-4912-b155-f4f27d4bfc1c"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"286215e2-8cb6-4977-8d86-6212eb8e9d3e","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:59:22.826Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"8b26a9e0-e5ce-42b4-b16a-fe4305c186ea","usageUuid":"f184cc37-a3e1-4d5e-b52c-84ce13b22f6e","capabilityType":30,"thinking":{"text":"Now I also need to update the references to `$PSScriptRoot` in the Invoke-Analysis function to use `$ScriptDir` instead.","signature":"EqMCCkgICxACGAIqQAk0tIYQm3jDEIOpvmhVekK2v6NgT/QdEDTXbDtbqefrTEeuEutr1yQCBRakw4xx0F/5t9Z0k2/uzldYm/W30LESDAgb/bSQDdjhWi0PUxoMdPIddfkk80Fb3FZcIjBdQAnV/7wNmbn2VaxKWlL5cdkDCEQcLTHOd1eO21J2CI32+TQHtROUOY8t/wWuAEIqiAHpb7HVJR6+Ai6vaCDoSAB02HNh20X9bWnxTAgYp7HkURX7AbSYBuCq3wa0G5DfK8JTRlaGXaKoneEkf/iHra4YhRpcVQ/5wXl1ircrmLs5tvNjCMbvQqwn4AMKQB07kSsjhvkKxdEuldW0oxm578p0wGLhgXVJCuN/chhm/LqBO/9W63gkFDBrGAE="},"thinkingStyle":1,"thinkingDurationMs":1338},"bubbleId":"286215e2-8cb6-4977-8d86-6212eb8e9d3e"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"28fc3779-8905-43fe-aaac-2b963a0f62dc","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"a9191b46-22da-4067-a6e4-b4d34407fb70","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:54:59.974Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":["file:///c%3A/Users/user/Downloads/Cursor_working_directory_misc"],"codeBlocks":[{"unregistered":true,"content":"USB-Inventory.ps1\nΓö£ΓöÇΓöÇ Parameters (switches for analysis, PCI devices, etc.)\nΓö£ΓöÇΓöÇ Helper Functions\nΓöé   Γö£ΓöÇΓöÇ Clean-Cell\nΓöé   Γö£ΓöÇΓöÇ Convert-UShortArrayToString\nΓöé   Γö£ΓöÇΓöÇ Get-MonitorInventory (WmiMonitorID + EDID fallback)\nΓöé   Γö£ΓöÇΓöÇ Get-NetworkInventory (NetTCPIP + CIM fallback)\nΓöé   Γö£ΓöÇΓöÇ Get-GpuInventory (CIM + nvidia-smi)\n\n\nΓöé   Γö£ΓöÇΓöÇ Get-DiskInventory (Storage + CIM fallback)\nΓöé   Γö£ΓöÇΓöÇ Get-PciDeviceInventory (optional)\nΓöé   ΓööΓöÇΓöÇ Analysis functions (Parse-ScanDate, Normalize-Serial, etc.)\nΓö£ΓöÇΓöÇ Main Collection Logic\nΓö£ΓöÇΓöÇ CSV Export\nΓööΓöÇΓöÇ Optional Analysis (if -Analyze switch)","needsUpdate":false,"languageId":"plaintext","isGenerating":false,"codeBlockIdx":0}],"text":"","modelInfo":{"modelName":"claude-4.5-opus-high-thinking"},"timingInfo":{"clientStartTime":10115926.800000012,"clientRpcSendTime":1766969699974,"clientSettleTime":1766969742001,"clientEndTime":1766969742001},"workspaceProjectDir":"c:\\Users\\user\\.cursor\\projects\\c-Users-user-Downloads-Cursor-working-directory-misc","serverBubbleId":"34f696ed-3d73-4197-af24-532819dfe1ea","usageUuid":"a9191b46-22da-4067-a6e4-b4d34407fb70","capabilityType":30,"thinking":{"text":"The user wants me to synthesize two PowerShell scripts into a single script that can be run from a USB drive to inventory the PC it\u0027s running on. Let me analyze what they\u0027ve provided:\n\n1. **Script 1: Collect-Inventory.ps1** - Collects hardware inventory (System, Network, GPU, Storage, Monitors) and appends to a CSV file\n2. **Script 2: Analyze-Inventory.ps1** - Audits the CSV file for duplicates, stale assets, low RAM, missing monitor data\n\nThe user provided two versions of the collection script - a simpler one and a more robust one (the second, longer version with better error handling, multiple fallback methods, etc.).\n\nThey want a **single script** that:\n- Can run from a USB drive\n- Inventories the PC it\u0027s running on\n- Presumably combines collection + optional analysis\n\nLet me think about what the synthesized script should do:\n\n1. Collect all hardware inventory (from the improved Collect-Inventory.ps1)\n2. Save to CSV on the USB drive (same folder as script)\n3. Optionally run analysis/health checks\n4. Be portable (no installation required)\n\nKey considerations:\n- Should work on PowerShell 5.1 (Windows 10/11 default)\n- Handle the USB path properly ($PSScriptRoot)\n- Combine the best parts of both collection scripts\n- Include the analysis functionality as an option\n\nI should create a plan for this. Let me think about the structure:\n\n```\nUSB-Inventory.ps1\nΓö£ΓöÇΓöÇ Parameters (switches for analysis, PCI devices, etc.)\nΓö£ΓöÇΓöÇ Helper Functions\nΓöé   Γö£ΓöÇΓöÇ Clean-Cell\nΓöé   Γö£ΓöÇΓöÇ Convert-UShortArrayToString\nΓöé   Γö£ΓöÇΓöÇ Get-MonitorInventory (WmiMonitorID + EDID fallback)\nΓöé   Γö£ΓöÇΓöÇ Get-NetworkInventory (NetTCPIP + CIM fallback)\nΓöé   Γö£ΓöÇΓöÇ Get-GpuInventory (CIM + nvidia-smi)\n\n\nΓöé   Γö£ΓöÇΓöÇ Get-DiskInventory (Storage + CIM fallback)\nΓöé   Γö£ΓöÇΓöÇ Get-PciDeviceInventory (optional)\nΓöé   ΓööΓöÇΓöÇ Analysis functions (Parse-ScanDate, Normalize-Serial, etc.)\nΓö£ΓöÇΓöÇ Main Collection Logic\nΓö£ΓöÇΓöÇ CSV Export\nΓööΓöÇΓöÇ Optional Analysis (if -Analyze switch)\n```\n\nThis is a straightforward synthesis task. I should present a plan to the user.","signature":"Er8RCkgICxACGAIqQH8vRnIVg4VSHwlzHCDpTmNlVXunUhkByk1w9Dl+JtsbaaothYyQcSEVBNAYJCNFKSabwVpw4at6vaz3LTcDjvASDG6T9MVs7b8Fg6BB3hoMDwLWjifHJxT1eEp1IjCDRWBDHPAob4bjnRwhrjGDKteBu1eVyBQPfEMMEQdx3TAADDuE8r3JQc0qNGeT1ocqpBAhz5a1EkGWS40sqe+oqxy4e1pSyf1UtFe2GtRvtXay2uQwswauMIHK7hOxFIr2gQy6TRcXnwyiSi4lMD1iM1/hNiYDYcZFMm8wDzDtWv2Nx40G/zO3zDo2jTxCI9kw7rMkWIphZOCfofZ6FYcN0+XmatBLOa4NZvykYgwOY/DrKorxDdet9QHUFcBAIZL7lN+YtXcZaXYrUdlLDwPlB3FPr/CajyPwltfdEEsUvNNgH1qFcmlfNaodwXaNarRvs5/0BsUis1pSYFfTrjoNJ30/pouPy3mfW3fZZ3n55FbnZlBMTSgLTb7np4e3BImG3RqDSDDZ2sdAdTx3BueFyYVQIfupdZ2XYC6A1YiIBeod1gL9QWQRrVAJtG2QMeG6/aIoqH5APW1RKLi+Q+WE3MOJg+W2ITZyIe1OpKfDkJLcg4KhlCdt0XP5Ar7GXuA4OcaylQQYGG6ph787P6NYlKveFDUiW8F4BMSYXGCpyCeOjiyHYE1mUve+49WxXC7OIssWRFZagQMAqCIu+DBnh55IAxrIJon/4bOHbDZrtCiQl4tEwBQahZheH7afufGsHd0vfXapxOA3ygrJ6aNxblwM00ECX0rKHHGAhMGDkXrBtfTrS+k3C+Yinw0hFWWvq6fEUYTU/c1FH23+BwELg5l9FuP1ky2qN2l/k3sQz0cWeytYEmnA7FV+IGkKFsMCTH0K8yW2+rqumDFQeEsEzpkV1hrXDdfvQWyoy/xqvonGT+IOsXXMRRcjPXBeEJr0/Xw/yYzyxQ+ldqCJfmgMIZNgkKuZNv1abC/kdmRyPR/plHy6voYNPuImRzLf/jVIRBaEhEsaBBTx9QovkMtwknHxMMGeTBsO+lDdvDIWKVNmHFUKM5fPKb8zAVPudQIxT2nRPqhC0lLbnWhzaxTVxu0IMwjBaL6eqjARGFDrGLmxH51Ah60I9HnT+x0pTLk//jjH1pGlOQWejTk/7KMBcwXjlCx0uvv9/U9q25p8hOTcS93XSini036/xRQjM0yqNSra7bBeAD4xSv8ONLiYL9GvB5ZqZSvaCHBRKdNvlyB8WXyeWF6I9Udfu3/JypYQqbtWJYlyh5RrKHFDu7ntGPuV+7s6TlFe3CpadKYXGSSwV2bvPQRU08XUlt7bEuvbxkosBSU4l9/ZpSHglsAVaX5tdKOC0XKmmqd/9DxVNKly5FnGVHxBjnjRj6a4Dom3TFTCB0TDxTfWV3OsQAF8trizzUa32T2kyTjz0C+Tc1hA5hAm/PfLGpLqNwc/SFvsXUNZcRF+/pXfAddr6zdVUnOBs2JltjLrAV5gCwswIVbSMeG2iYT1s2GqlKMvjTrS3+J0w326ECqBh/nMkFXZ7stRUodL14wFQ7suH0Sx7RjRUhbSlme4nygU+f5YRXoZgD9+gYiMkRE8plYOCR5eVNIumzGlVRjHQ3StUyxjDkh345kyvAB+LJlhnRWkERHXIjEV7c8PHfRkT8/9bhfAZSwCCxej5lxl7AeIYK1F9HvacYiYC0LB82bJo9A2VHS2XeaIK6ZAVp4NDkTyX8/RpqBrfSwrTolBLI4vrMmFdZLGGy0zZUwSNlNFp2qZy3LbtooZi41I/KEsa7ctnmvX2QzuUSUOtXi1ywUum4ps7LcM7WBZ+ZZgn7EtV7Of2nVwUU+iSUQ49fOwmIR7y9BwxDAMVNbRePfwgcaA59z2yjcBxELT8ZZyFdcs7acVXiDEXKxb4K4aT6KHYofOLwVYdpXP9TJ75F12KDGR/x9zNOLtUhk/YO+zvxQLcJuNwQ7wCzQLXcXjMG2+jd5YldTzpzlkM48Yz/qSXSaDATfC7MFu7rj6aE8BJSoGPimNUe6a+3xLk7QYojPec6u+nwsjJzXNyyxj6lho5lZJbH0B66vF31wp4aW3izptQ7cXuirIldhzVlVitkszwIpk0Sl+UaLK9UO8du7NI6fsIrdGp8b1WixMMrx6mk1bvedNdj+tBL0ITnMWZnWPWP0o9vAhvDMBQYaahWo7SEtvrH90pOwA1KTa2h9R5+jPGk1upw8/R5v66IC58s669We/0yosb9vwYYZBdPOmM8svOcS1+Nr80PmuIFqb3dm14Gr8S1gtD0kFtm+Kd92Uvdlw1sJEUXvZ4rI77vZ1L22qVM7+9B1tWLU3ZHIeN+VbLl9Jp8pKFJdgK851BsNhDsNGazfqrvYVnlhz9CEL7/vqXACVyvgGYVimfEbd7dBsjLAwQb4gaHcKODodk1o8Lg3dHit+WfbrqWPZ3B0A/c0hPYwQwsgyskomXEXX4EQLMj/euqF8/u4eWbRzKn89COy3rgNMCEVd7m3elNSiKzS1eXZNWkPpOzCeyqbIXcckE9/c/Rl8s3DtO8k5rzrcY0lBxnXsFwZS43Eug2pHXouTQjLAZgnWDwlyePLJEhTdnCgQUcoFJAebwFmpvUKcrGg1wYM/DM9Zr34yRDR8IXt/bXt1Ur+4iPYGOZR7kDXZ8OyrdwjtlH7z+Na5BvWcDRWrfhNaxxmb/mJPJ9y8FILrHbUClionKUX1l5ZgUKehnlERvQNdO4MA03gMlzt+hecO8R40AeN+47jWzOUIcDc5na5zRAL6Ae9usDr1h96BqvRncp5R9HLHBPh/5b5bujC7a73YtCYq0eWSpr1mzobPfmeCXzULOqpk9q6M2DTaAagUsYvzQWAO3f1nVdpLf14IHgjNYSsrBey9RW+6bBYJBsJrdNiX9qq5lkHQ6B9xQdOGA5h+UDoYonm506YZqk9lIhzt+uGl5cvhehgB"},"thinkingStyle":1,"thinkingDurationMs":15828,"toolFormerData":{"additionalData":{"status":"error"}}},"bubbleId":"28fc3779-8905-43fe-aaac-2b963a0f62dc"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"2a9812b1-ba87-4982-9f7b-beb9e49e0068","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:02:00.198Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"018f8ecc-2d5a-4cb7-a692-2fd7fe598bc5","usageUuid":"992ef4a3-aaaa-4b66-8d89-46dcc8b446d0","capabilityType":30,"thinking":{"text":"Let me clean up the test files and provide a summary to the user.","signature":"EusBCkgICxACGAIqQF4V0LEVzMXYczKR7HLAxDfkrpBpJq9AMa+trnhKIvBKheEzL1PajnGRQC8OgwkWoNoTG0/EKnZceMKfnOmq+kcSDLJqSTMbMMfVS3gtuxoMlhvA4XS8F3rjMVvsIjARieJrSgpCUjqjkPJ6WpCtrnuJqeweWU6HnMZSn1eB8PAH2uywb/pIIYzmxCiX6xAqUQTAcl+RdHt35L0anx9RgE1BidH9zChcvzi2XL8ie2p+b1nd7hDEufF33Wzv4kD6vNwlUzljhOfG5qR1rJbWb2+2nayeN5f/mNnyQl4eCf0+gBgB"},"thinkingStyle":1,"thinkingDurationMs":871},"bubbleId":"2a9812b1-ba87-4982-9f7b-beb9e49e0068"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"2da151f2-d40b-4ebc-9eb7-caa354d55c93","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:59:46.247Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"56a9543c-b8b5-4711-9d48-4a7ecfd7ffec","usageUuid":"72440367-d3eb-476a-adb8-eb99fdc7e0fe","capabilityType":30,"thinking":{"text":"The error indicates a problem with the script - likely a syntax issue. The error \"The term \u0027try\u0027 is not recognized\" suggests the script has a parsing issue. Let me look at the problematic area in the BIOS_ReleaseDate line where there\u0027s an inline try-catch that might be causing issues.","signature":"EsgDCkgICxACGAIqQKfrbV/yosVtySKsfNSm7KuRfnlBRPBrnxGf3/byBWV2GcsOhTc7f2/b/kobLaU4vipOvuYkG3oIJ6UPIGp3pwwSDEhiwsJ1zY5f4eq79xoM6XyoTXaiH5xK7hXJIjD2567x2SkwagIHX3/mmtaWqquKkqFOAlDHqYG8EGzCSzZ8W0c8+A2ptXEDJY0VqccqrQKjpBZduj498JKiBpw8rlCnWTzymqUZ9xCHsCN1+geZ0y7LRy+0c/TXfbm+q9BDdPsAT43pePrN80t4J9Y1zbuZAlPVmrVXT2TuN9a04v6q+2QTL+30gT6a8eohwf7pFSKZVhHLgQXpocCSNHB2JLTNA8cnFE5zk/PhCmJoBBb7PgkUmoctShDRXairoRIgIFQgj7/xRbcW0PC4S8sd4ovD4zPs3wQQ7EXLQvSDcEgiICXpS32laE6JGNzhPkfNdDyZMzU4U7qodkCYHpyfJAY2jmM+uSCfvD/Ds72XhzHaAAcn31UPsDoqmL20aNPVU3J1+CN/0RM6QdlMNFdzp6N4YCWsVWEt+6kruIxRVMHqxajmgY8RAgsB0zkxS/IYGqqOf8UpDLO8iIz66ZQhGAE="},"thinkingStyle":1,"thinkingDurationMs":2002},"bubbleId":"2da151f2-d40b-4ebc-9eb7-caa354d55c93"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"343e1019-d29b-47eb-a8e2-2f434cd0ff76","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:59:22.826Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[{"uri":{"scheme":"file","authority":"","path":"/c:/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1","query":"","fragment":"","_formatted":"file:///c%3A/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1","_fsPath":"c:\\Users\\user\\Downloads\\Cursor_working_directory_misc\\USB-Inventory.ps1"},"codeblockId":"213e6393-099f-4283-a5cc-8b47857da956","codeBlockIdx":0,"content":"#requires -Version 5.1\n\u003c#\n.SYNOPSIS\n    USB-portable PC hardware inventory collection and analysis tool.\n\n.DESCRIPTION\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\n    script. Optionally runs health analysis to detect duplicates, stale assets,\n    low RAM, and missing monitor data.\n\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\n\n.PARAMETER OutputFile\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\n\n.PARAMETER IncludePciDevices\n    Include detailed PCI device enumeration (can produce large output).\n\n.PARAMETER Analyze\n    After collection, run health analysis on the CSV file.\n\n.PARAMETER AnalyzeOnly\n    Skip collection; only run health analysis on existing CSV.\n\n.PARAMETER StaleDays\n    Threshold in days for flagging stale assets. Default: 90.\n\n.PARAMETER MinRamGB\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\n\n.PARAMETER NoCsv\n    Do not output Inventory_Issues_Report.csv (text report only).\n\n.EXAMPLE\n    .\\USB-Inventory.ps1\n    Collect inventory from this PC into PC_Inventory_Master.csv.\n\n.EXAMPLE\n    .\\USB-Inventory.ps1 -IncludePciDevices -Analyze\n    Collect inventory with PCI devices, then run health analysis.\n\n.EXAMPLE\n    .\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\n    Analyze existing CSV with custom thresholds (no new collection).\n#\u003e\n\n[CmdletBinding()]\nparam(\n    [string]$OutputFile,\n    [switch]$IncludePciDevices,\n    [switch]$Analyze,\n    [switch]$AnalyzeOnly,\n    [int]$StaleDays = 90,\n    [int]$MinRamGB = 8,\n    [switch]$NoCsv\n)\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = \u0027Stop\u0027\n\n# Resolve script root (handles -File invocation where $PSScriptRoot may be empty)\n$ScriptDir = $PSScriptRoot\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\n    $ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition\n}\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\n    $ScriptDir = $PWD.Path\n}\n\n# Default OutputFile if not specified\nif ([string]::IsNullOrWhiteSpace($OutputFile)) {\n    $OutputFile = Join-Path -Path $ScriptDir -ChildPath \u0027PC_Inventory_Master.csv\u0027\n}\n\n# ============================================================================\n# HELPER FUNCTIONS - COLLECTION\n# ============================================================================\n\nfunction Clean-Cell {\n    param([AllowNull()][string]$Text)\n    if ($null -eq $Text) { return \u0027\u0027 }\n    return ($Text -replace \"(`r`n|`n|`r|`t)+\", \u0027 \u0027).Trim()\n}\n\nfunction Convert-UShortArrayToString {\n    param([AllowNull()]$Arr)\n    if ($null -eq $Arr) { return \u0027\u0027 }\n    $chars = foreach ($x in $Arr) {\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\n    }\n    return ( -join $chars ).Trim()\n}\n\nfunction Get-MonitorInventory {\n    \u003c#\n      Preferred: root\\wmi:WmiMonitorID (easy, consistent, usually no admin)\n      Fallback: registry EDID decode under HKLM:\\SYSTEM\\CCS\\Enum\\DISPLAY\n    #\u003e\n\n    $results = New-Object System.Collections.Generic.List[string]\n\n    # --- Preferred path: WmiMonitorID ---\n    try {\n        $wmiMons = Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorID -ErrorAction Stop\n        foreach ($m in $wmiMons) {\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\n\n            $label = @()\n            if ($mfg)  { $label += $mfg }\n            if ($name) { $label += $name }\n\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\n            $serialPart  = if ($sn) { \"SN:$sn\" } else { \u0027SN:(none)\u0027 }\n\n            $results.Add(\"$displayName ($serialPart)\")\n        }\n    } catch {\n        # WmiMonitorID not available; fall through to EDID fallback\n    }\n\n    if ($results.Count -gt 0) {\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n    }\n\n    # --- Fallback path: registry EDID decode ---\n    function Get-EdidDescriptorString {\n        param(\n            [byte[]]$Edid,\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\n        )\n\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\n\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\n\n        foreach ($offset in 54,72,90,108) {\n            if (($offset + 18) -gt $Edid.Length) { continue }\n\n            # Descriptor: 00 00 00 {tag} 00 ...\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\n\n                $bytes = $Edid[($offset+5)..($offset+17)]\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\n                $text = ($text -replace \"[`0`n`r]+\", \u0027\u0027).Trim()\n                if ($text) { return $text }\n            }\n        }\n\n        return \u0027\u0027\n    }\n\n    try {\n        $root = \u0027HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\DISPLAY\u0027\n        if (Test-Path -LiteralPath $root) {\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\n                    if (Test-Path -LiteralPath $params) {\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\n                        if ($edid -is [byte[]]) {\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\n\n                            # Numeric serial (bytes 12-15 LE) sometimes present\n                            $num = [BitConverter]::ToUInt32($edid, 12)\n                            $numStr = if ($num -ne 0) { \"NUM:$num\" } else { \u0027\u0027 }\n\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\n                            $serialPart  = if ($sn) { \"SN:$sn\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\n\n                            $results.Add(\"$displayName ($serialPart)\")\n                        }\n                    }\n                }\n            }\n        }\n    } catch {\n        # EDID fallback failed silently\n    }\n\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-NetworkInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\n\n    if ($hasNetAdapter -and $hasNetIpCfg) {\n        try {\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\n            foreach ($a in $adapters) {\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\n                $ipv4 = @()\n                if ($cfg -and $cfg.IPv4Address) {\n                    $ipv4 = $cfg.IPv4Address |\n                        ForEach-Object { $_.IPAddress } |\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\n                }\n                $gw = @()\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\n                }\n\n                $parts = @()\n                $parts += (Clean-Cell $a.Name)\n                if ($a.MacAddress) { $parts += \"MAC:$($a.MacAddress)\" }\n                if ($ipv4.Count -gt 0) { $parts += (\"IPv4:\" + ($ipv4 -join \u0027;\u0027)) }\n                if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n                $items.Add(($parts -join \u0027 \u0027))\n            }\n        } catch {\n            # Fall back to CIM below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\n            Where-Object { $_.IPEnabled -eq $true }\n\n        foreach ($n in $net) {\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\n            $mac  = $n.MACAddress\n            $ips  = @()\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\n            $gw   = @()\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\n\n            $parts = @()\n            $parts += (Clean-Cell $name)\n            if ($mac) { $parts += \"MAC:$mac\" }\n            if ($ips.Count -gt 0) { $parts += (\"IP:\" + ($ips -join \u0027;\u0027)) }\n            if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n            $items.Add(($parts -join \u0027 \u0027))\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-GpuInventory {\n    $gpus = New-Object System.Collections.Generic.List[string]\n\n    # CIM GPUs\n    try {\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\n        foreach ($g in $vc) {\n            $name = Clean-Cell $g.Name\n            $pnp  = Clean-Cell $g.PNPDeviceID\n            if ($name -or $pnp) {\n                $gpus.Add((\"{0}{1}\" -f $name, $(if ($pnp) { \" [ID:$pnp]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    # Optional NVIDIA serials if nvidia-smi exists\n    try {\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\n        if ($nvsmi) {\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\n            foreach ($line in @($raw)) {\n                $t = Clean-Cell $line\n                if ($t) { $gpus.Add(\"NVIDIA $t\") }\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-DiskInventory {\n    $disks = New-Object System.Collections.Generic.List[string]\n\n    # Prefer Storage module when available\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\n    if ($hasPhysicalDisk) {\n        try {\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\n                $name = Clean-Cell $d.FriendlyName\n                $sn   = Clean-Cell $d.SerialNumber\n                $mt   = Clean-Cell ([string]$d.MediaType)\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n                $parts = @()\n                if ($name) { $parts += $name }\n                if ($sn)   { $parts += \"SN:$sn\" }\n                if ($mt)   { $parts += \"Type:$mt\" }\n                if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n            }\n        } catch {\n            # Fall back below\n        }\n    }\n\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\n            $model = Clean-Cell $d.Model\n            $sn = \u0027\u0027\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\n            $devId = Clean-Cell $d.DeviceID\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n            $parts = @()\n            if ($model) { $parts += $model }\n            if ($sn)    { $parts += \"SN:$sn\" }\n            if ($devId) { $parts += \"Dev:$devId\" }\n            if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-PciDeviceInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\n    if ($hasGetPnpDevice) {\n        try {\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\n                Where-Object { $_.InstanceId -like \u0027PCI\\*\u0027 } |\n                Sort-Object -Property Class, FriendlyName, Name\n\n            foreach ($d in $devs) {\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\n                $name = Clean-Cell $name\n                $cls  = Clean-Cell $d.Class\n                $id   = Clean-Cell $d.InstanceId\n                if ($name -or $id) {\n                    $items.Add((\"{0}{1}{2}\" -f $name, $(if ($cls) { \" [Class:$cls]\" } else { \u0027\u0027 }), $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n                }\n            }\n        } catch {\n            # Fall back below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM Win32_PnPEntity\n    try {\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\*\u0027 } |\n            Sort-Object -Property Name\n\n        foreach ($d in $devs) {\n            $name = Clean-Cell $d.Name\n            $id   = Clean-Cell $d.PNPDeviceID\n            if ($name -or $id) {\n                $items.Add((\"{0}{1}\" -f $name, $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\n# ============================================================================\n# HELPER FUNCTIONS - ANALYSIS\n# ============================================================================\n\nfunction Get-ColumnMap {\n    param([string[]]$Headers)\n\n    $map = @{\n        Hostname        = \u0027Hostname\u0027\n        User            = \u0027User\u0027\n        System_Serial   = \u0027System_Serial\u0027\n        RAM_GB          = \u0027RAM_GB\u0027\n        Monitor_Serials = \u0027Monitor_Serials\u0027\n        Scan_Date       = \u0027Scan_Date\u0027\n    }\n\n    foreach ($k in @($map.Keys)) {\n        if ($Headers -notcontains $map[$k]) {\n            $alts = switch ($k) {\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\n                default           { @() }\n            }\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\n            if ($found) { $map[$k] = $found }\n        }\n    }\n\n    return $map\n}\n\nfunction Parse-ScanDate {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    $dt = $null\n\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\n\n    if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\n\n    return $null\n}\n\nfunction Normalize-Serial {\n    param([AllowNull()][string]$Serial)\n\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\n    $s = ($Serial.Trim())\n\n    $bad = @(\n        \u0027To Be Filled By O.E.M.\u0027,\n        \u0027To Be Filled By OEM\u0027,\n        \u0027Default string\u0027,\n        \u0027System Serial Number\u0027,\n        \u0027None\u0027,\n        \u0027N/A\u0027,\n        \u0027NA\u0027,\n        \u00270\u0027,\n        \u002700000000\u0027,\n        \u00270000000000\u0027,\n        \u00270000000000000000\u0027\n    )\n\n    if ($bad -contains $s) { return \u0027\u0027 }\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\n\n    return $s.ToUpperInvariant()\n}\n\nfunction Parse-RamGB {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    $m = [regex]::Match($s, \u0027(\\d+)(\\.\\d+)?\u0027)\n    if (-not $m.Success) { return $null }\n\n    $n = $null\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\n        return [int][math]::Round($n, 0)\n    }\n\n    return $null\n}\n\nfunction Is-MonitorMissing {\n    param([AllowNull()][string]$Value)\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\n    $t = $Value.Trim()\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\n}\n\n# ============================================================================\n# MAIN: COLLECTION\n# ============================================================================\n\nfunction Invoke-Collection {\n    param([string]$OutPath, [switch]$IncludePci)\n\n    $errors = New-Object System.Collections.Generic.List[string]\n\n    Write-Host \"`n========================================================\" -ForegroundColor Cyan\n    Write-Host \"   GATHERING HARDWARE SPECS... PLEASE WAIT\" -ForegroundColor Cyan\n    Write-Host \"========================================================\" -ForegroundColor Cyan\n\n    # --- Collect core system info ---\n    $sys  = $null\n    $bios = $null\n    $cpu  = $null\n    $os   = $null\n    $bb   = $null\n\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_ComputerSystem: $($_.Exception.Message)\") }\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\"Win32_BIOS: $($_.Exception.Message)\") }\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_Processor: $($_.Exception.Message)\") }\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_OperatingSystem: $($_.Exception.Message)\") }\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_BaseBoard: $($_.Exception.Message)\") }\n\n    # --- Derived values ---\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\n\n    $ramGB = $null\n    try {\n        if ($sys -and $sys.TotalPhysicalMemory) {\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\n        }\n    } catch {\n        $errors.Add(\"RAM calc: $($_.Exception.Message)\")\n    }\n\n    # --- Other sections ---\n    $netStr  = \u0027\u0027\n    $gpuStr  = \u0027\u0027\n    $diskStr = \u0027\u0027\n    $monStr  = \u0027\u0027\n    $pciStr  = \u0027\u0027\n\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\"Network: $($_.Exception.Message)\") }\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\"GPU: $($_.Exception.Message)\") }\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\"Disks: $($_.Exception.Message)\") }\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\"Monitors: $($_.Exception.Message)\") }\n\n    if ($IncludePci) {\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\"PCI devices: $($_.Exception.Message)\") }\n    }\n\n    # --- Build record ---\n    $record = [pscustomobject]@{\n        Hostname          = Clean-Cell $hostname\n        User              = Clean-Cell $env:USERNAME\n\n        Make_Model        = Clean-Cell ((\"{0} {1}\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\n\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\n        Baseboard_Product = Clean-Cell ($bb.Product)\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\n\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\n        BIOS_ReleaseDate  = Clean-Cell (try { ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027) } catch { \u0027\u0027 })\n\n        OS_Caption        = Clean-Cell ($os.Caption)\n        OS_Version        = Clean-Cell ($os.Version)\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\n\n        CPU               = Clean-Cell ($cpu.Name)\n        RAM_GB            = $ramGB\n\n        Network_Adapters  = Clean-Cell $netStr\n        GPUs              = Clean-Cell $gpuStr\n        Disk_Serials      = Clean-Cell $diskStr\n        Monitor_Serials   = Clean-Cell $monStr\n\n        PCI_Devices       = Clean-Cell $pciStr\n\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\n        Collector_Version = \u00272.0\u0027\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\n    }\n\n    # --- CSV append with header safety ---\n    $needHeader = $true\n    if (Test-Path -LiteralPath $OutPath) {\n        try {\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\n            if ($fi.Length -gt 0) { $needHeader = $false }\n        } catch { $needHeader = $true }\n    }\n\n    if ($needHeader) {\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\n    } else {\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\n    }\n\n    Write-Host \"`nSUCCESS!\" -ForegroundColor Green\n    Write-Host \"Data saved to: $OutPath\" -ForegroundColor Gray\n    if ($record.Errors) {\n        Write-Host (\"Warnings captured in Errors column: {0}\" -f $record.Errors) -ForegroundColor Yellow\n    }\n}\n\n# ============================================================================\n# MAIN: ANALYSIS\n# ============================================================================\n\nfunction Invoke-Analysis {\n    param(\n        [string]$InputPath,\n        [int]$StaleDaysThreshold,\n        [int]$MinRam,\n        [switch]$SkipCsv\n    )\n\n    $ReportFile = Join-Path -Path $PSScriptRoot -ChildPath \u0027Inventory_Issues_Report.txt\u0027\n    $IssuesCsv  = Join-Path -Path $PSScriptRoot -ChildPath \u0027Inventory_Issues_Report.csv\u0027\n\n    if (-not (Test-Path -LiteralPath $InputPath)) {\n        Write-Warning \"Input file not found: $InputPath\"\n        Write-Warning \"Run the script without -AnalyzeOnly first to collect data.\"\n        return\n    }\n\n    $raw = Import-Csv -LiteralPath $InputPath\n    if (-not $raw -or $raw.Count -eq 0) {\n        Write-Warning \"Input file contains no rows: $InputPath\"\n        return\n    }\n\n    $headers = @()\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\n    $col = Get-ColumnMap -Headers $headers\n\n    $today = Get-Date\n\n    # Normalize data and add helper properties\n    $data = foreach ($r in $raw) {\n        $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\n        $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\n        $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\n        $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\n        $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\n        $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\n\n        $serialN = Normalize-Serial $serial\n        $scanDt  = Parse-ScanDate $scan\n        $ramGb   = Parse-RamGB $ram\n\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\n\n        # Asset key: prefer System Serial, fallback to Hostname\n        $assetKey = \u0027\u0027\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\n            $assetKey = $serialN\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\n            $assetKey = $h.Trim().ToUpperInvariant()\n        }\n\n        [pscustomobject]@{\n            Hostname        = $h.Trim()\n            User            = $u.Trim()\n            System_Serial   = $serialN\n            RAM_GB          = $ramGb\n            Monitor_Serials = $m.Trim()\n            Scan_Date       = $s.Trim()\n\n            ScanDateParsed  = $scanDt\n            AssetKey        = $assetKey\n            RawRow          = $r\n        }\n    }\n\n    # Latest record per asset\n    $latestByAsset = $data |\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\n        Group-Object -Property AssetKey |\n        ForEach-Object { $_.Group | Select-Object -First 1 }\n\n    $issues = New-Object System.Collections.Generic.List[object]\n\n    function Add-Issue {\n        param(\n            [Parameter(Mandatory)][string]$IssueType,\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\n            [string]$AssetKey,\n            [string]$Hostname,\n            [string]$User,\n            [string]$SystemSerial,\n            [string]$ScanDate,\n            [string]$Details\n        )\n\n        $issues.Add([pscustomobject]@{\n            IssueType     = $IssueType\n            Severity      = $Severity\n            AssetKey      = $AssetKey\n            Hostname      = $Hostname\n            User          = $User\n            System_Serial = $SystemSerial\n            Scan_Date     = $ScanDate\n            Details       = $Details\n        })\n    }\n\n    # 0) Data quality (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\n        }\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\n        }\n        if (-not $pc.ScanDateParsed) {\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\n        }\n    }\n\n    # 1) Duplicate serials (all rows; ignore blanks)\n    $dupeGroups = $data |\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\n        Group-Object -Property System_Serial |\n        Where-Object { $_.Count -gt 1 }\n\n    foreach ($g in $dupeGroups) {\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\n\n        $severity =\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\n            else { \u0027Info\u0027 }\n\n        $entries = $g.Group |\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\n            ForEach-Object {\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\n                \"{0} ({1})\" -f $_.Hostname, $d\n            }\n\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\n    }\n\n    # 2) Low RAM (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\"RAM_GB={0} (min {1})\" -f $pc.RAM_GB, $MinRam)\n        } elseif ($null -eq $pc.RAM_GB) {\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\n        }\n    }\n\n    # 3) Stale assets (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ($pc.ScanDateParsed) {\n            $ageDays = ($today - $pc.ScanDateParsed).Days\n            if ($ageDays -gt $StaleDaysThreshold) {\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\"Last seen {0} days ago (threshold {1})\" -f $ageDays, $StaleDaysThreshold)\n            }\n        }\n    }\n\n    # 4) Missing monitor serials (latest records)\n    foreach ($pc in $latestByAsset) {\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\n        }\n    }\n\n    # --- Build text report ---\n    $generated = Get-Date\n    $line = (\u0027=\u0027 * 70)\n\n    $txt = New-Object System.Collections.Generic.List[string]\n    $txt.Add($line)\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\n    $txt.Add(\"Generated: $generated\")\n    $txt.Add(\"Input:     $InputPath\")\n    $txt.Add((\"Assets:    {0} (latest per asset)\" -f $latestByAsset.Count))\n    $txt.Add((\"Rows:      {0} (raw rows in CSV)\" -f $data.Count))\n    $txt.Add((\"Settings:  MinRamGB={0}, StaleDays={1}\" -f $MinRam, $StaleDaysThreshold))\n    $txt.Add($line)\n    $txt.Add(\u0027\u0027)\n\n    if ($issues.Count -eq 0) {\n        $txt.Add(\u0027No issues found.\u0027)\n    } else {\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\n        foreach ($t in $byType) {\n            $txt.Add((\"--- {0} ({1}) ---\" -f $t.Name, $t.Count))\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\n\n                $txt.Add((\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\n            }\n            $txt.Add(\u0027\u0027)\n        }\n    }\n\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\n\n    if (-not $SkipCsv) {\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\n    }\n\n    # --- Console summary ---\n    Write-Host \"`n$line\" -ForegroundColor Cyan\n    Write-Host (\"Report saved: {0}\" -f $ReportFile) -ForegroundColor Green\n    if (-not $SkipCsv) { Write-Host (\"Issues CSV:   {0}\" -f $IssuesCsv) -ForegroundColor Green }\n    Write-Host (\"Issues found: {0}\" -f $issues.Count) -ForegroundColor Yellow\n    Write-Host $line -ForegroundColor Cyan\n\n    if ($issues.Count -gt 0) {\n        $sev = $issues | Group-Object Severity | Sort-Object Name\n        foreach ($s in $sev) {\n            $c = switch ($s.Name) {\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\n                default    { [ConsoleColor]::Gray }\n            }\n            Write-Host (\"{0}: {1}\" -f $s.Name, $s.Count) -ForegroundColor $c\n        }\n    }\n}\n\n# ============================================================================\n# ENTRY POINT\n# ============================================================================\n\nif (-not $AnalyzeOnly) {\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\n}\n\nif ($Analyze -or $AnalyzeOnly) {\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv\n}\n\nif (-not $AnalyzeOnly -and -not $Analyze) {\n    Write-Host \"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\" -ForegroundColor DarkGray\n}\n\n","languageId":"powershell"}],"text":"","capabilityType":15,"toolFormerData":{"tool":38,"toolIndex":1,"modelCallId":"25caa95b-bd26-439a-bd03-dc64fef1a6a1","toolCallId":"toolu_vrtx_018vW6XQ8CF1osGzWVuSNvoU","status":"completed","rawArgs":"{\"file_path\": \"USB-Inventory.ps1\", \"old_string\": \"[CmdletBinding()]\\nparam(\\n    [string]$OutputFile = (Join-Path -Path $PSScriptRoot -ChildPath \u0027PC_Inventory_Master.csv\u0027),\\n    [switch]$IncludePciDevices,\\n    [switch]$Analyze,\\n    [switch]$AnalyzeOnly,\\n    [int]$StaleDays = 90,\\n    [int]$MinRamGB = 8,\\n    [switch]$NoCsv\\n)\\n\\nSet-StrictMode -Version Latest\\n$ErrorActionPreference = \u0027Stop\u0027\", \"new_string\": \"[CmdletBinding()]\\nparam(\\n    [string]$OutputFile,\\n    [switch]$IncludePciDevices,\\n    [switch]$Analyze,\\n    [switch]$AnalyzeOnly,\\n    [int]$StaleDays = 90,\\n    [int]$MinRamGB = 8,\\n    [switch]$NoCsv\\n)\\n\\nSet-StrictMode -Version Latest\\n$ErrorActionPreference = \u0027Stop\u0027\\n\\n# Resolve script root (handles -File invocation where $PSScriptRoot may be empty)\\n$ScriptDir = $PSScriptRoot\\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n    $ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition\\n}\\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n    $ScriptDir = $PWD.Path\\n}\\n\\n# Default OutputFile if not specified\\nif ([string]::IsNullOrWhiteSpace($OutputFile)) {\\n    $OutputFile = Join-Path -Path $ScriptDir -ChildPath \u0027PC_Inventory_Master.csv\u0027\\n}\"}","name":"search_replace","params":"{\"relativeWorkspacePath\":\"USB-Inventory.ps1\"}","additionalData":{"codeblockId":"213e6393-099f-4283-a5cc-8b47857da956"},"userDecision":"accepted","result":"{\"diff\":{\"chunks\":[{\"diffString\":\"  [CmdletBinding()]\\n  param(\\n-     [string]$OutputFile = (Join-Path -Path $PSScriptRoot -ChildPath \u0027PC_Inventory_Master.csv\u0027),\\n+     [string]$OutputFile,\\n      [switch]$IncludePciDevices,\\n      [switch]$Analyze,\",\"oldStart\":48,\"newStart\":48,\"oldLines\":5,\"newLines\":5,\"linesRemoved\":1,\"linesAdded\":1},{\"diffString\":\"  Set-StrictMode -Version Latest\\n  $ErrorActionPreference = \u0027Stop\u0027\\n+ \\n+ # Resolve script root (handles -File invocation where $PSScriptRoot may be empty)\\n+ $ScriptDir = $PSScriptRoot\\n+ if ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n+     $ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition\\n+ }\\n+ if ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n+     $ScriptDir = $PWD.Path\\n+ }\\n+ \\n+ # Default OutputFile if not specified\\n+ if ([string]::IsNullOrWhiteSpace($OutputFile)) {\\n+     $OutputFile = Join-Path -Path $ScriptDir -ChildPath \u0027PC_Inventory_Master.csv\u0027\\n+ }\\n  \\n  # ============================================================================\",\"oldStart\":59,\"newStart\":59,\"oldLines\":4,\"newLines\":18,\"linesAdded\":14}],\"editor\":\"EDITOR_AI\"},\"shouldAutoFixLints\":true,\"resultForModel\":\"The file USB-Inventory.ps1 has been updated.\",\"contentsAfterEdit\":\"#requires -Version 5.1\\n\u003c#\\n.SYNOPSIS\\n    USB-portable PC hardware inventory collection and analysis tool.\\n\\n.DESCRIPTION\\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\\n    script. Optionally runs health analysis to detect duplicates, stale assets,\\n    low RAM, and missing monitor data.\\n\\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\\n\\n.PARAMETER OutputFile\\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\\n\\n.PARAMETER IncludePciDevices\\n    Include detailed PCI device enumeration (can produce large output).\\n\\n.PARAMETER Analyze\\n    After collection, run health analysis on the CSV file.\\n\\n.PARAMETER AnalyzeOnly\\n    Skip collection; only run health analysis on existing CSV.\\n\\n.PARAMETER StaleDays\\n    Threshold in days for flagging stale assets. Default: 90.\\n\\n.PARAMETER MinRamGB\\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\\n\\n.PARAMETER NoCsv\\n    Do not output Inventory_Issues_Report.csv (text report only).\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1\\n    Collect inventory from this PC into PC_Inventory_Master.csv.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -IncludePciDevices -Analyze\\n    Collect inventory with PCI devices, then run health analysis.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\\n    Analyze existing CSV with custom thresholds (no new collection).\\n#\u003e\\n\\n[CmdletBinding()]\\nparam(\\n    [string]$OutputFile,\\n    [switch]$IncludePciDevices,\\n    [switch]$Analyze,\\n    [switch]$AnalyzeOnly,\\n    [int]$StaleDays = 90,\\n    [int]$MinRamGB = 8,\\n    [switch]$NoCsv\\n)\\n\\nSet-StrictMode -Version Latest\\n$ErrorActionPreference = \u0027Stop\u0027\\n\\n# Resolve script root (handles -File invocation where $PSScriptRoot may be empty)\\n$ScriptDir = $PSScriptRoot\\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n    $ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition\\n}\\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n    $ScriptDir = $PWD.Path\\n}\\n\\n# Default OutputFile if not specified\\nif ([string]::IsNullOrWhiteSpace($OutputFile)) {\\n    $OutputFile = Join-Path -Path $ScriptDir -ChildPath \u0027PC_Inventory_Master.csv\u0027\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - COLLECTION\\n# ============================================================================\\n\\nfunction Clean-Cell {\\n    param([AllowNull()][string]$Text)\\n    if ($null -eq $Text) { return \u0027\u0027 }\\n    return ($Text -replace \\\"(`r`n|`n|`r|`t)+\\\", \u0027 \u0027).Trim()\\n}\\n\\nfunction Convert-UShortArrayToString {\\n    param([AllowNull()]$Arr)\\n    if ($null -eq $Arr) { return \u0027\u0027 }\\n    $chars = foreach ($x in $Arr) {\\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\\n    }\\n    return ( -join $chars ).Trim()\\n}\\n\\nfunction Get-MonitorInventory {\\n    \u003c#\\n      Preferred: root\\\\wmi:WmiMonitorID (easy, consistent, usually no admin)\\n      Fallback: registry EDID decode under HKLM:\\\\SYSTEM\\\\CCS\\\\Enum\\\\DISPLAY\\n    #\u003e\\n\\n    $results = New-Object System.Collections.Generic.List[string]\\n\\n    # --- Preferred path: WmiMonitorID ---\\n    try {\\n        $wmiMons = Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorID -ErrorAction Stop\\n        foreach ($m in $wmiMons) {\\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\\n\\n            $label = @()\\n            if ($mfg)  { $label += $mfg }\\n            if ($name) { $label += $name }\\n\\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\\n            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } else { \u0027SN:(none)\u0027 }\\n\\n            $results.Add(\\\"$displayName ($serialPart)\\\")\\n        }\\n    } catch {\\n        # WmiMonitorID not available; fall through to EDID fallback\\n    }\\n\\n    if ($results.Count -gt 0) {\\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n    }\\n\\n    # --- Fallback path: registry EDID decode ---\\n    function Get-EdidDescriptorString {\\n        param(\\n            [byte[]]$Edid,\\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\\n        )\\n\\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\\n\\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\\n\\n        foreach ($offset in 54,72,90,108) {\\n            if (($offset + 18) -gt $Edid.Length) { continue }\\n\\n            # Descriptor: 00 00 00 {tag} 00 ...\\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\\n\\n                $bytes = $Edid[($offset+5)..($offset+17)]\\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\\n                $text = ($text -replace \\\"[`0`n`r]+\\\", \u0027\u0027).Trim()\\n                if ($text) { return $text }\\n            }\\n        }\\n\\n        return \u0027\u0027\\n    }\\n\\n    try {\\n        $root = \u0027HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Enum\\\\DISPLAY\u0027\\n        if (Test-Path -LiteralPath $root) {\\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\\n                    if (Test-Path -LiteralPath $params) {\\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\\n                        if ($edid -is [byte[]]) {\\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\\n\\n                            # Numeric serial (bytes 12-15 LE) sometimes present\\n                            $num = [BitConverter]::ToUInt32($edid, 12)\\n                            $numStr = if ($num -ne 0) { \\\"NUM:$num\\\" } else { \u0027\u0027 }\\n\\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\\n                            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\\n\\n                            $results.Add(\\\"$displayName ($serialPart)\\\")\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    } catch {\\n        # EDID fallback failed silently\\n    }\\n\\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-NetworkInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\\n\\n    if ($hasNetAdapter -and $hasNetIpCfg) {\\n        try {\\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\\n            foreach ($a in $adapters) {\\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\\n                $ipv4 = @()\\n                if ($cfg -and $cfg.IPv4Address) {\\n                    $ipv4 = $cfg.IPv4Address |\\n                        ForEach-Object { $_.IPAddress } |\\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\\n                }\\n                $gw = @()\\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\\n                }\\n\\n                $parts = @()\\n                $parts += (Clean-Cell $a.Name)\\n                if ($a.MacAddress) { $parts += \\\"MAC:$($a.MacAddress)\\\" }\\n                if ($ipv4.Count -gt 0) { $parts += (\\\"IPv4:\\\" + ($ipv4 -join \u0027;\u0027)) }\\n                if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n                $items.Add(($parts -join \u0027 \u0027))\\n            }\\n        } catch {\\n            # Fall back to CIM below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\\n            Where-Object { $_.IPEnabled -eq $true }\\n\\n        foreach ($n in $net) {\\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\\n            $mac  = $n.MACAddress\\n            $ips  = @()\\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\\n            $gw   = @()\\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\\n\\n            $parts = @()\\n            $parts += (Clean-Cell $name)\\n            if ($mac) { $parts += \\\"MAC:$mac\\\" }\\n            if ($ips.Count -gt 0) { $parts += (\\\"IP:\\\" + ($ips -join \u0027;\u0027)) }\\n            if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n            $items.Add(($parts -join \u0027 \u0027))\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-GpuInventory {\\n    $gpus = New-Object System.Collections.Generic.List[string]\\n\\n    # CIM GPUs\\n    try {\\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\\n        foreach ($g in $vc) {\\n            $name = Clean-Cell $g.Name\\n            $pnp  = Clean-Cell $g.PNPDeviceID\\n            if ($name -or $pnp) {\\n                $gpus.Add((\\\"{0}{1}\\\" -f $name, $(if ($pnp) { \\\" [ID:$pnp]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    # Optional NVIDIA serials if nvidia-smi exists\\n    try {\\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\\n        if ($nvsmi) {\\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\\n            foreach ($line in @($raw)) {\\n                $t = Clean-Cell $line\\n                if ($t) { $gpus.Add(\\\"NVIDIA $t\\\") }\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-DiskInventory {\\n    $disks = New-Object System.Collections.Generic.List[string]\\n\\n    # Prefer Storage module when available\\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasPhysicalDisk) {\\n        try {\\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\\n                $name = Clean-Cell $d.FriendlyName\\n                $sn   = Clean-Cell $d.SerialNumber\\n                $mt   = Clean-Cell ([string]$d.MediaType)\\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n                $parts = @()\\n                if ($name) { $parts += $name }\\n                if ($sn)   { $parts += \\\"SN:$sn\\\" }\\n                if ($mt)   { $parts += \\\"Type:$mt\\\" }\\n                if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\\n            $model = Clean-Cell $d.Model\\n            $sn = \u0027\u0027\\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\\n            $devId = Clean-Cell $d.DeviceID\\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n            $parts = @()\\n            if ($model) { $parts += $model }\\n            if ($sn)    { $parts += \\\"SN:$sn\\\" }\\n            if ($devId) { $parts += \\\"Dev:$devId\\\" }\\n            if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-PciDeviceInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasGetPnpDevice) {\\n        try {\\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\\n                Where-Object { $_.InstanceId -like \u0027PCI\\\\*\u0027 } |\\n                Sort-Object -Property Class, FriendlyName, Name\\n\\n            foreach ($d in $devs) {\\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\\n                $name = Clean-Cell $name\\n                $cls  = Clean-Cell $d.Class\\n                $id   = Clean-Cell $d.InstanceId\\n                if ($name -or $id) {\\n                    $items.Add((\\\"{0}{1}{2}\\\" -f $name, $(if ($cls) { \\\" [Class:$cls]\\\" } else { \u0027\u0027 }), $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n                }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM Win32_PnPEntity\\n    try {\\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\\\*\u0027 } |\\n            Sort-Object -Property Name\\n\\n        foreach ($d in $devs) {\\n            $name = Clean-Cell $d.Name\\n            $id   = Clean-Cell $d.PNPDeviceID\\n            if ($name -or $id) {\\n                $items.Add((\\\"{0}{1}\\\" -f $name, $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - ANALYSIS\\n# ============================================================================\\n\\nfunction Get-ColumnMap {\\n    param([string[]]$Headers)\\n\\n    $map = @{\\n        Hostname        = \u0027Hostname\u0027\\n        User            = \u0027User\u0027\\n        System_Serial   = \u0027System_Serial\u0027\\n        RAM_GB          = \u0027RAM_GB\u0027\\n        Monitor_Serials = \u0027Monitor_Serials\u0027\\n        Scan_Date       = \u0027Scan_Date\u0027\\n    }\\n\\n    foreach ($k in @($map.Keys)) {\\n        if ($Headers -notcontains $map[$k]) {\\n            $alts = switch ($k) {\\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\\n                default           { @() }\\n            }\\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\\n            if ($found) { $map[$k] = $found }\\n        }\\n    }\\n\\n    return $map\\n}\\n\\nfunction Parse-ScanDate {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    $dt = $null\\n\\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n\\n    if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\\n\\n    return $null\\n}\\n\\nfunction Normalize-Serial {\\n    param([AllowNull()][string]$Serial)\\n\\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\\n    $s = ($Serial.Trim())\\n\\n    $bad = @(\\n        \u0027To Be Filled By O.E.M.\u0027,\\n        \u0027To Be Filled By OEM\u0027,\\n        \u0027Default string\u0027,\\n        \u0027System Serial Number\u0027,\\n        \u0027None\u0027,\\n        \u0027N/A\u0027,\\n        \u0027NA\u0027,\\n        \u00270\u0027,\\n        \u002700000000\u0027,\\n        \u00270000000000\u0027,\\n        \u00270000000000000000\u0027\\n    )\\n\\n    if ($bad -contains $s) { return \u0027\u0027 }\\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\\n\\n    return $s.ToUpperInvariant()\\n}\\n\\nfunction Parse-RamGB {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    $m = [regex]::Match($s, \u0027(\\\\d+)(\\\\.\\\\d+)?\u0027)\\n    if (-not $m.Success) { return $null }\\n\\n    $n = $null\\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\\n        return [int][math]::Round($n, 0)\\n    }\\n\\n    return $null\\n}\\n\\nfunction Is-MonitorMissing {\\n    param([AllowNull()][string]$Value)\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\\n    $t = $Value.Trim()\\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\\n}\\n\\n# ============================================================================\\n# MAIN: COLLECTION\\n# ============================================================================\\n\\nfunction Invoke-Collection {\\n    param([string]$OutPath, [switch]$IncludePci)\\n\\n    $errors = New-Object System.Collections.Generic.List[string]\\n\\n    Write-Host \\\"`n========================================================\\\" -ForegroundColor Cyan\\n    Write-Host \\\"   GATHERING HARDWARE SPECS... PLEASE WAIT\\\" -ForegroundColor Cyan\\n    Write-Host \\\"========================================================\\\" -ForegroundColor Cyan\\n\\n    # --- Collect core system info ---\\n    $sys  = $null\\n    $bios = $null\\n    $cpu  = $null\\n    $os   = $null\\n    $bb   = $null\\n\\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_ComputerSystem: $($_.Exception.Message)\\\") }\\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\\\"Win32_BIOS: $($_.Exception.Message)\\\") }\\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_Processor: $($_.Exception.Message)\\\") }\\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_OperatingSystem: $($_.Exception.Message)\\\") }\\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_BaseBoard: $($_.Exception.Message)\\\") }\\n\\n    # --- Derived values ---\\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\\n\\n    $ramGB = $null\\n    try {\\n        if ($sys -and $sys.TotalPhysicalMemory) {\\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\\n        }\\n    } catch {\\n        $errors.Add(\\\"RAM calc: $($_.Exception.Message)\\\")\\n    }\\n\\n    # --- Other sections ---\\n    $netStr  = \u0027\u0027\\n    $gpuStr  = \u0027\u0027\\n    $diskStr = \u0027\u0027\\n    $monStr  = \u0027\u0027\\n    $pciStr  = \u0027\u0027\\n\\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\\\"Network: $($_.Exception.Message)\\\") }\\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\\\"GPU: $($_.Exception.Message)\\\") }\\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\\\"Disks: $($_.Exception.Message)\\\") }\\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\\\"Monitors: $($_.Exception.Message)\\\") }\\n\\n    if ($IncludePci) {\\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\\\"PCI devices: $($_.Exception.Message)\\\") }\\n    }\\n\\n    # --- Build record ---\\n    $record = [pscustomobject]@{\\n        Hostname          = Clean-Cell $hostname\\n        User              = Clean-Cell $env:USERNAME\\n\\n        Make_Model        = Clean-Cell ((\\\"{0} {1}\\\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\\n\\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\\n        Baseboard_Product = Clean-Cell ($bb.Product)\\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\\n\\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\\n        BIOS_ReleaseDate  = Clean-Cell (try { ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027) } catch { \u0027\u0027 })\\n\\n        OS_Caption        = Clean-Cell ($os.Caption)\\n        OS_Version        = Clean-Cell ($os.Version)\\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\\n\\n        CPU               = Clean-Cell ($cpu.Name)\\n        RAM_GB            = $ramGB\\n\\n        Network_Adapters  = Clean-Cell $netStr\\n        GPUs              = Clean-Cell $gpuStr\\n        Disk_Serials      = Clean-Cell $diskStr\\n        Monitor_Serials   = Clean-Cell $monStr\\n\\n        PCI_Devices       = Clean-Cell $pciStr\\n\\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\\n        Collector_Version = \u00272.0\u0027\\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\\n    }\\n\\n    # --- CSV append with header safety ---\\n    $needHeader = $true\\n    if (Test-Path -LiteralPath $OutPath) {\\n        try {\\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\\n            if ($fi.Length -gt 0) { $needHeader = $false }\\n        } catch { $needHeader = $true }\\n    }\\n\\n    if ($needHeader) {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\\n    } else {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\\n    }\\n\\n    Write-Host \\\"`nSUCCESS!\\\" -ForegroundColor Green\\n    Write-Host \\\"Data saved to: $OutPath\\\" -ForegroundColor Gray\\n    if ($record.Errors) {\\n        Write-Host (\\\"Warnings captured in Errors column: {0}\\\" -f $record.Errors) -ForegroundColor Yellow\\n    }\\n}\\n\\n# ============================================================================\\n# MAIN: ANALYSIS\\n# ============================================================================\\n\\nfunction Invoke-Analysis {\\n    param(\\n        [string]$InputPath,\\n        [int]$StaleDaysThreshold,\\n        [int]$MinRam,\\n        [switch]$SkipCsv\\n    )\\n\\n    $ReportFile = Join-Path -Path $PSScriptRoot -ChildPath \u0027Inventory_Issues_Report.txt\u0027\\n    $IssuesCsv  = Join-Path -Path $PSScriptRoot -ChildPath \u0027Inventory_Issues_Report.csv\u0027\\n\\n    if (-not (Test-Path -LiteralPath $InputPath)) {\\n        Write-Warning \\\"Input file not found: $InputPath\\\"\\n        Write-Warning \\\"Run the script without -AnalyzeOnly first to collect data.\\\"\\n        return\\n    }\\n\\n    $raw = Import-Csv -LiteralPath $InputPath\\n    if (-not $raw -or $raw.Count -eq 0) {\\n        Write-Warning \\\"Input file contains no rows: $InputPath\\\"\\n        return\\n    }\\n\\n    $headers = @()\\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\\n    $col = Get-ColumnMap -Headers $headers\\n\\n    $today = Get-Date\\n\\n    # Normalize data and add helper properties\\n    $data = foreach ($r in $raw) {\\n        $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\\n        $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\\n        $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\\n        $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\\n        $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\\n        $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\\n\\n        $serialN = Normalize-Serial $serial\\n        $scanDt  = Parse-ScanDate $scan\\n        $ramGb   = Parse-RamGB $ram\\n\\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\\n\\n        # Asset key: prefer System Serial, fallback to Hostname\\n        $assetKey = \u0027\u0027\\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\\n            $assetKey = $serialN\\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\\n            $assetKey = $h.Trim().ToUpperInvariant()\\n        }\\n\\n        [pscustomobject]@{\\n            Hostname        = $h.Trim()\\n            User            = $u.Trim()\\n            System_Serial   = $serialN\\n            RAM_GB          = $ramGb\\n            Monitor_Serials = $m.Trim()\\n            Scan_Date       = $s.Trim()\\n\\n            ScanDateParsed  = $scanDt\\n            AssetKey        = $assetKey\\n            RawRow          = $r\\n        }\\n    }\\n\\n    # Latest record per asset\\n    $latestByAsset = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\\n        Group-Object -Property AssetKey |\\n        ForEach-Object { $_.Group | Select-Object -First 1 }\\n\\n    $issues = New-Object System.Collections.Generic.List[object]\\n\\n    function Add-Issue {\\n        param(\\n            [Parameter(Mandatory)][string]$IssueType,\\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\\n            [string]$AssetKey,\\n            [string]$Hostname,\\n            [string]$User,\\n            [string]$SystemSerial,\\n            [string]$ScanDate,\\n            [string]$Details\\n        )\\n\\n        $issues.Add([pscustomobject]@{\\n            IssueType     = $IssueType\\n            Severity      = $Severity\\n            AssetKey      = $AssetKey\\n            Hostname      = $Hostname\\n            User          = $User\\n            System_Serial = $SystemSerial\\n            Scan_Date     = $ScanDate\\n            Details       = $Details\\n        })\\n    }\\n\\n    # 0) Data quality (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\\n        }\\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\\n        }\\n        if (-not $pc.ScanDateParsed) {\\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\\n        }\\n    }\\n\\n    # 1) Duplicate serials (all rows; ignore blanks)\\n    $dupeGroups = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\\n        Group-Object -Property System_Serial |\\n        Where-Object { $_.Count -gt 1 }\\n\\n    foreach ($g in $dupeGroups) {\\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\\n\\n        $severity =\\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\\n            else { \u0027Info\u0027 }\\n\\n        $entries = $g.Group |\\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\\n            ForEach-Object {\\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\\n                \\\"{0} ({1})\\\" -f $_.Hostname, $d\\n            }\\n\\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\\\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\\\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\\n    }\\n\\n    # 2) Low RAM (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\\\"RAM_GB={0} (min {1})\\\" -f $pc.RAM_GB, $MinRam)\\n        } elseif ($null -eq $pc.RAM_GB) {\\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\\n        }\\n    }\\n\\n    # 3) Stale assets (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($pc.ScanDateParsed) {\\n            $ageDays = ($today - $pc.ScanDateParsed).Days\\n            if ($ageDays -gt $StaleDaysThreshold) {\\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\\\"Last seen {0} days ago (threshold {1})\\\" -f $ageDays, $StaleDaysThreshold)\\n            }\\n        }\\n    }\\n\\n    # 4) Missing monitor serials (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\\n        }\\n    }\\n\\n    # --- Build text report ---\\n    $generated = Get-Date\\n    $line = (\u0027=\u0027 * 70)\\n\\n    $txt = New-Object System.Collections.Generic.List[string]\\n    $txt.Add($line)\\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\\n    $txt.Add(\\\"Generated: $generated\\\")\\n    $txt.Add(\\\"Input:     $InputPath\\\")\\n    $txt.Add((\\\"Assets:    {0} (latest per asset)\\\" -f $latestByAsset.Count))\\n    $txt.Add((\\\"Rows:      {0} (raw rows in CSV)\\\" -f $data.Count))\\n    $txt.Add((\\\"Settings:  MinRamGB={0}, StaleDays={1}\\\" -f $MinRam, $StaleDaysThreshold))\\n    $txt.Add($line)\\n    $txt.Add(\u0027\u0027)\\n\\n    if ($issues.Count -eq 0) {\\n        $txt.Add(\u0027No issues found.\u0027)\\n    } else {\\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\\n        foreach ($t in $byType) {\\n            $txt.Add((\\\"--- {0} ({1}) ---\\\" -f $t.Name, $t.Count))\\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\\n\\n                $txt.Add((\\\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\\\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\\n            }\\n            $txt.Add(\u0027\u0027)\\n        }\\n    }\\n\\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\\n\\n    if (-not $SkipCsv) {\\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\\n    }\\n\\n    # --- Console summary ---\\n    Write-Host \\\"`n$line\\\" -ForegroundColor Cyan\\n    Write-Host (\\\"Report saved: {0}\\\" -f $ReportFile) -ForegroundColor Green\\n    if (-not $SkipCsv) { Write-Host (\\\"Issues CSV:   {0}\\\" -f $IssuesCsv) -ForegroundColor Green }\\n    Write-Host (\\\"Issues found: {0}\\\" -f $issues.Count) -ForegroundColor Yellow\\n    Write-Host $line -ForegroundColor Cyan\\n\\n    if ($issues.Count -gt 0) {\\n        $sev = $issues | Group-Object Severity | Sort-Object Name\\n        foreach ($s in $sev) {\\n            $c = switch ($s.Name) {\\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\\n                default    { [ConsoleColor]::Gray }\\n            }\\n            Write-Host (\\\"{0}: {1}\\\" -f $s.Name, $s.Count) -ForegroundColor $c\\n        }\\n    }\\n}\\n\\n# ============================================================================\\n# ENTRY POINT\\n# ============================================================================\\n\\nif (-not $AnalyzeOnly) {\\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\\n}\\n\\nif ($Analyze -or $AnalyzeOnly) {\\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv\\n}\\n\\nif (-not $AnalyzeOnly -and -not $Analyze) {\\n    Write-Host \\\"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\\\" -ForegroundColor DarkGray\\n}\\n\\n\"}"},"checkpointId":"61d57c84-754b-4e56-b01f-3e2a09b9fb46"},"bubbleId":"343e1019-d29b-47eb-a8e2-2f434cd0ff76"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"3861d26c-cc4f-4923-a9df-5bded37ccc1a","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:00:34.079Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"0baa2392-3e11-42e3-958d-aa033bc163ff","usageUuid":"73bfe74f-6573-4fc7-9989-82a92974fe96","capabilityType":30,"thinking":{"text":"There\u0027s an issue with the TryParseExact method call. In PowerShell 5.1, the signature is different - it expects a [ref] for the output parameter. Let me look at the Parse-ScanDate function.","signature":"EugCCkgICxACGAIqQFNOfNWVrzhnGs9E/lZ5HnnkszTrIkKqfqB0VQvCEleJ+iEMLHS00FS8FEseqXqVb+6nwO4naI1PgUEtYLyQBcMSDIOUdhRuoi0n1hzvvhoMw5992WbGoD7ktA2AIjBVSB4QCRmin+6MsDFTFuf1mXPWx4EBf6Q+A5aTGqjBpTDb3VzWfE3qKPJQObY71UgqzQFtGpr44rMqZO0gZP+P2tjW6GzohVWwFXurKpbsYzCFnqDhobW+ByDM8kA242x8vgeZSdW/RZAUTSefsgqGH0mtpYsnPJiwlYhbuYNheUzmqQlj7ZqcI5Y/d9YhnCIAvQQeqY/3PWHHnNvQZSiudg67xOS5eJcb+gSGVcTUrMwp8wUNlppKVdoW5gQx2A2OYHlEI+eKy+rLIZbKVBRTz0oQ0r3QUy20rEmtFFsCJcVY6+b9u3FPXI9HS35c+0R4VR6uDO13DiPWYW19NiJyGAE="},"thinkingStyle":1,"thinkingDurationMs":1497},"bubbleId":"3861d26c-cc4f-4923-a9df-5bded37ccc1a"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"387c27ba-fbdf-405a-8f0d-b200fd41085d","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:00:23.043Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"d83eee54-96f4-4e5d-a87d-5cddffabc34d","codeBlocks":[],"capabilityType":15,"toolFormerData":{"tool":15,"toolCallId":"toolu_vrtx_017im6gdYRQ37446TS3H9JPj","toolIndex":1,"modelCallId":"48834665-5269-468e-a8a0-8b102ffe54a5","status":"completed","rawArgs":"{\"command\": \"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\"\", \"is_background\": false, \"explanation\": \"Testing the USB-Inventory.ps1 script after fixing inline try-catch issue.\"}","name":"run_terminal_cmd","params":"{\"command\":\"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\"\",\"requireUserApproval\":true,\"parsingResult\":{\"executableCommands\":[{\"name\":\"powershell\",\"args\":[{\"type\":\"word\",\"value\":\"-ExecutionPolicy\"},{\"type\":\"word\",\"value\":\"Bypass\"},{\"type\":\"word\",\"value\":\"-File\"},{\"type\":\"string\",\"value\":\"\\\".\\\\USB-Inventory.ps1\\\"\"}],\"fullText\":\"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\"\"}]},\"fileOutputThresholdBytes\":\"20000\"}","additionalData":{"status":"success","reviewData":{"status":"Done","selectedOption":"run","isShowingInput":false,"candidatesForAllowlist":["powershell"],"approvalType":"allowlist"},"sessionId":"5dd745c9-3368-496b-b5ac-9b78458b05d4","startAtBufferLine":0,"previousAttempt":"{\"output\":\"\\n========================================================\\n   GATHERING HARDWARE SPECS... PLEASE WAIT\\n========================================================\\n\\nSUCCESS!\\nData saved to: C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\PC_Inventory_Master.csv\\n\\nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\\n\",\"rejected\":false,\"notInterrupted\":true,\"endedReason\":\"RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED\",\"exitCodeV2\":0,\"effectiveSandboxPolicy\":{\"type\":\"TYPE_INSECURE_NONE\"}}"},"result":"{\"output\":\"\\n========================================================\\n   GATHERING HARDWARE SPECS... PLEASE WAIT\\n========================================================\\n\\nSUCCESS!\\nData saved to: C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\PC_Inventory_Master.csv\\n\\nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\\n\",\"rejected\":false,\"notInterrupted\":true,\"endedReason\":\"RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED\",\"exitCodeV2\":0,\"effectiveSandboxPolicy\":{\"type\":\"TYPE_INSECURE_NONE\"}}","attachments":"{\"shouldShowTodoWriteReminder\":true,\"todoReminderType\":\"TODO_REMINDER_TYPE_EVERY_10_TURNS\"}"}},"bubbleId":"387c27ba-fbdf-405a-8f0d-b200fd41085d"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"3ea518f7-356d-41c5-b5b6-bb0bf7d22b0a","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:01:09.907Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"267670e9-91ab-44b8-8daa-0eb851a16703","codeBlocks":[],"capabilityType":15,"toolFormerData":{"tool":41,"toolCallId":"toolu_vrtx_011fK7Dfu9PWK2uzGqRoKtJr","toolIndex":1,"modelCallId":"d9671ece-6170-4c93-9755-6d4033da0ea9","status":"completed","rawArgs":"{\"pattern\": \"\\\\.Count\", \"path\": \"USB-Inventory.ps1\", \"-C\": 1}","name":"grep","params":"{\"pattern\":\"\\\\.Count\",\"path\":\"USB-Inventory.ps1\",\"outputMode\":\"content\",\"context\":1,\"caseInsensitive\":false}","additionalData":{},"result":"{\"success\":{\"pattern\":\"\\\\.Count\",\"path\":\"USB-Inventory.ps1\",\"outputMode\":\"content\",\"workspaceResults\":{\"c:/Users/user/Downloads/Cursor_working_directory_misc\":{\"content\":{\"matches\":[{\"file\":\"USB-Inventory.ps1\",\"matches\":[{\"lineNumber\":114,\"isContextLine\":true},{\"lineNumber\":115,\"content\":\"            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\"},{\"lineNumber\":116,\"content\":\"            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } else { \u0027SN:(none)\u0027 }\",\"isContextLine\":true},{\"lineNumber\":123,\"isContextLine\":true},{\"lineNumber\":124,\"content\":\"    if ($results.Count -gt 0) {\"},{\"lineNumber\":125,\"content\":\"        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\",\"isContextLine\":true},{\"lineNumber\":184,\"isContextLine\":true},{\"lineNumber\":185,\"content\":\"    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\"},{\"lineNumber\":186,\"content\":\"    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\",\"isContextLine\":true},{\"lineNumber\":213,\"content\":\"                if ($a.MacAddress) { $parts += \\\"MAC:$($a.MacAddress)\\\" }\",\"isContextLine\":true},{\"lineNumber\":214,\"content\":\"                if ($ipv4.Count -gt 0) { $parts += (\\\"IPv4:\\\" + ($ipv4 -join \u0027;\u0027)) }\"},{\"lineNumber\":215,\"content\":\"                if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\"},{\"lineNumber\":216,\"isContextLine\":true},{\"lineNumber\":223,\"isContextLine\":true},{\"lineNumber\":224,\"content\":\"    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\"},{\"lineNumber\":225,\"isContextLine\":true},{\"lineNumber\":241,\"content\":\"            if ($mac) { $parts += \\\"MAC:$mac\\\" }\",\"isContextLine\":true},{\"lineNumber\":242,\"content\":\"            if ($ips.Count -gt 0) { $parts += (\\\"IP:\\\" + ($ips -join \u0027;\u0027)) }\"},{\"lineNumber\":243,\"content\":\"            if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\"},{\"lineNumber\":244,\"isContextLine\":true},{\"lineNumber\":250,\"isContextLine\":true},{\"lineNumber\":251,\"content\":\"    if ($items.Count -eq 0) { return \u0027\u0027 }\"},{\"lineNumber\":252,\"content\":\"    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\",\"isContextLine\":true},{\"lineNumber\":285,\"isContextLine\":true},{\"lineNumber\":286,\"content\":\"    if ($gpus.Count -eq 0) { return \u0027\u0027 }\"},{\"lineNumber\":287,\"content\":\"    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\",\"isContextLine\":true},{\"lineNumber\":308,\"isContextLine\":true},{\"lineNumber\":309,\"content\":\"                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\"},{\"lineNumber\":310,\"content\":\"            }\",\"isContextLine\":true},{\"lineNumber\":315,\"isContextLine\":true},{\"lineNumber\":316,\"content\":\"    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\"},{\"lineNumber\":317,\"isContextLine\":true},{\"lineNumber\":332,\"isContextLine\":true},{\"lineNumber\":333,\"content\":\"            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\"},{\"lineNumber\":334,\"content\":\"        }\",\"isContextLine\":true},{\"lineNumber\":338,\"isContextLine\":true},{\"lineNumber\":339,\"content\":\"    if ($disks.Count -eq 0) { return \u0027\u0027 }\"},{\"lineNumber\":340,\"content\":\"    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\",\"isContextLine\":true},{\"lineNumber\":366,\"isContextLine\":true},{\"lineNumber\":367,\"content\":\"    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\"},{\"lineNumber\":368,\"isContextLine\":true},{\"lineNumber\":385,\"isContextLine\":true},{\"lineNumber\":386,\"content\":\"    if ($items.Count -eq 0) { return \u0027\u0027 }\"},{\"lineNumber\":387,\"content\":\"    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\",\"isContextLine\":true},{\"lineNumber\":644,\"content\":\"    $raw = Import-Csv -LiteralPath $InputPath\",\"isContextLine\":true},{\"lineNumber\":645,\"content\":\"    if (-not $raw -or $raw.Count -eq 0) {\"},{\"lineNumber\":646,\"content\":\"        Write-Warning \\\"Input file contains no rows: $InputPath\\\"\",\"isContextLine\":true},{\"lineNumber\":657,\"content\":\"    $data = foreach ($r in $raw) {\",\"isContextLine\":true},{\"lineNumber\":658,\"content\":\"        $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\"},{\"lineNumber\":659,\"content\":\"        $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\"},{\"lineNumber\":660,\"content\":\"        $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\"},{\"lineNumber\":661,\"content\":\"        $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\"},{\"lineNumber\":662,\"content\":\"        $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\"},{\"lineNumber\":663,\"content\":\"        $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\"},{\"lineNumber\":664,\"isContextLine\":true},{\"lineNumber\":745,\"content\":\"        Group-Object -Property System_Serial |\",\"isContextLine\":true},{\"lineNumber\":746,\"content\":\"        Where-Object { $_.Count -gt 1 }\"},{\"lineNumber\":747,\"isContextLine\":true},{\"lineNumber\":752,\"content\":\"        $severity =\",\"isContextLine\":true},{\"lineNumber\":753,\"content\":\"            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\"},{\"lineNumber\":754,\"content\":\"            else { \u0027Info\u0027 }\",\"isContextLine\":true},{\"lineNumber\":762,\"isContextLine\":true},{\"lineNumber\":763,\"content\":\"        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\\\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\\\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\"},{\"lineNumber\":764,\"content\":\"    }\",\"isContextLine\":true},{\"lineNumber\":800,\"content\":\"    $txt.Add(\\\"Input:     $InputPath\\\")\",\"isContextLine\":true},{\"lineNumber\":801,\"content\":\"    $txt.Add((\\\"Assets:    {0} (latest per asset)\\\" -f $latestByAsset.Count))\"},{\"lineNumber\":802,\"content\":\"    $txt.Add((\\\"Rows:      {0} (raw rows in CSV)\\\" -f $data.Count))\"},{\"lineNumber\":803,\"content\":\"    $txt.Add((\\\"Settings:  MinRamGB={0}, StaleDays={1}\\\" -f $MinRam, $StaleDaysThreshold))\",\"isContextLine\":true},{\"lineNumber\":806,\"isContextLine\":true},{\"lineNumber\":807,\"content\":\"    if ($issues.Count -eq 0) {\"},{\"lineNumber\":808,\"content\":\"        $txt.Add(\u0027No issues found.\u0027)\",\"isContextLine\":true},{\"lineNumber\":811,\"content\":\"        foreach ($t in $byType) {\",\"isContextLine\":true},{\"lineNumber\":812,\"content\":\"            $txt.Add((\\\"--- {0} ({1}) ---\\\" -f $t.Name, $t.Count))\"},{\"lineNumber\":813,\"content\":\"            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\",\"isContextLine\":true},{\"lineNumber\":836,\"content\":\"    if (-not $SkipCsv) { Write-Host (\\\"Issues CSV:   {0}\\\" -f $IssuesCsv) -ForegroundColor Green }\",\"isContextLine\":true},{\"lineNumber\":837,\"content\":\"    Write-Host (\\\"Issues found: {0}\\\" -f $issues.Count) -ForegroundColor Yellow\"},{\"lineNumber\":838,\"content\":\"    Write-Host $line -ForegroundColor Cyan\",\"isContextLine\":true},{\"lineNumber\":839,\"isContextLine\":true},{\"lineNumber\":840,\"content\":\"    if ($issues.Count -gt 0) {\"},{\"lineNumber\":841,\"content\":\"        $sev = $issues | Group-Object Severity | Sort-Object Name\",\"isContextLine\":true},{\"lineNumber\":847,\"content\":\"            }\",\"isContextLine\":true},{\"lineNumber\":848,\"content\":\"            Write-Host (\\\"{0}: {1}\\\" -f $s.Name, $s.Count) -ForegroundColor $c\"},{\"lineNumber\":849,\"content\":\"        }\",\"isContextLine\":true}]}],\"totalLines\":83,\"totalMatchedLines\":33}}}}}"}},"bubbleId":"3ea518f7-356d-41c5-b5b6-bb0bf7d22b0a"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"40c2213d-5e70-4e47-af3a-e9d29bcd6ced","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:59:10.666Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"0d24f558-8ec4-4618-b219-06ad3a9b9e7c","usageUuid":"e9c16abc-6c1c-449d-b840-6078a84b45b4","capabilityType":30,"thinking":{"text":"Let me run the script to test it on the local machine.","signature":"EuABCkgICxACGAIqQDQcEY+PFUQqDP2F2XUbI0YoNN0VS8jLfCR29D/eRnQDObfeL4xNAhA1JwQIEloPNhzMloqOu1s7CaIjOeMdjgASDAa0SrFnSuZQSc/MmRoMHY8JriQd2F/nzJUtIjAVAHehbafboDO/MeDQ1SdizHol1Ras9PYKxWM9Y2yvNAfAzhfjmSPEomdLoiCoNc4qRmJH8ZB5juKArw3M9q1EXw99XcDaFnEzhGMkzTUs4GkUugwQ3O7Mf1yWs9Fd9P4EWYp6NkEDMgIgf47k+uF8e5UgGgZi/ZgYAQ=="},"thinkingStyle":1,"thinkingDurationMs":804},"bubbleId":"40c2213d-5e70-4e47-af3a-e9d29bcd6ced"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"42289197-423e-486f-a7bb-bd15044a7fcf","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:55:18.820Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","capabilityType":15,"toolFormerData":{"tool":43,"toolIndex":1,"modelCallId":"81a1c1ff-fa80-48fe-bc9d-6cf9da66a7de","toolCallId":"toolu_vrtx_01KkFdgSLMDnJm1vJvTAYnN9","status":"completed","rawArgs":"{\"name\": \"USB Inventory Script\", \"overview\": \"Synthesize Collect-Inventory.ps1 and Analyze-Inventory.ps1 into a single portable PowerShell script that runs from USB to inventory the host PC, with optional health analysis.\", \"plan\": \"# USB-Inventory.ps1 Synthesis Plan\\n\\n## Approach\\n\\nCombine the improved collection script (v2.0 with WmiMonitorID, fallbacks, error tracking) with the analysis script into one file. The script will:\\n\\n1. **Collect** hardware inventory on the current PC\\n2. **Append** to `PC_Inventory_Master.csv` in the same folder as the script (USB root)\\n3. **Optionally analyze** the CSV for issues when `-Analyze` is passed\\n\\n## Script Structure\\n\\n```\\nUSB-Inventory.ps1\\n  [Parameters]\\n    -OutputFile     (default: PC_Inventory_Master.csv in $PSScriptRoot)\\n    -IncludePciDevices\\n    -Analyze        (runs health check after collection)\\n    -AnalyzeOnly    (skip collection, just analyze existing CSV)\\n    -StaleDays      (default: 90)\\n    -MinRamGB       (default: 8)\\n\\n  [Helper Functions]\\n    Clean-Cell, Convert-UShortArrayToString\\n    Get-MonitorInventory (WmiMonitorID preferred, EDID registry fallback)\\n    Get-NetworkInventory (Get-NetAdapter preferred, CIM fallback)\\n    Get-GpuInventory     (CIM + nvidia-smi if present)\\n    Get-DiskInventory    (Get-PhysicalDisk preferred, CIM fallback)\\n    Get-PciDeviceInventory (optional)\\n    \\n    # Analysis helpers\\n    Parse-ScanDate, Normalize-Serial, Parse-RamGB, Is-MonitorMissing\\n    Get-ColumnMap (tolerates renamed headers)\\n\\n  [Main]\\n    IF NOT $AnalyzeOnly:\\n      Collect system/BIOS/CPU/OS/baseboard info\\n      Collect network/GPU/disk/monitor inventories\\n      Build PSCustomObject record\\n      Append to CSV (with header safety)\\n      \\n    IF $Analyze OR $AnalyzeOnly:\\n      Import CSV\\n      Detect duplicates, stale assets, low RAM, missing monitors\\n      Output text report + optional CSV of issues\\n```\\n\\n## Key Design Decisions\\n\\n| Decision | Rationale |\\n|----------|-----------|\\n| PowerShell 5.1 compatible | Ships with Windows 10/11; no `??` operator |\\n| `$PSScriptRoot` for paths | Works correctly when run from USB |\\n| Append mode with header check | Multiple PCs can be scanned to same CSV |\\n| Error column in CSV | Non-fatal errors captured, not hidden |\\n| WmiMonitorID first | More reliable than EDID registry decode |\\n| Analysis is optional | Collection is the primary use case |\\n\\n## Output Files (on USB)\\n\\n- `PC_Inventory_Master.csv` - cumulative inventory\\n- `Inventory_Issues_Report.txt` - human-readable (when `-Analyze`)\\n- `Inventory_Issues_Report.csv` - sortable issues (when `-Analyze`)\\n\\n## Usage Examples\\n\\n```powershell\\n# Basic: collect this PC\u0027s inventory\\n.\\\\USB-Inventory.ps1\\n\\n# Collect with PCI devices and run analysis\\n.\\\\USB-Inventory.ps1 -IncludePciDevices -Analyze\\n\\n# Just analyze existing data (no new collection)\\n.\\\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\\n```\\n\\n## File Location\\n\\nNew file: `USB-Inventory.ps1` (single ~600-line script in workspace root or user-specified location)\\n\", \"todos\": [{\"id\": \"synth-script\", \"content\": \"Create USB-Inventory.ps1 combining collection + analysis logic\"}, {\"id\": \"test-local\", \"content\": \"Test script execution on local machine\"}]}","name":"create_plan","params":"{\"plan\":\"# USB-Inventory.ps1 Synthesis Plan\\n\\n## Approach\\n\\nCombine the improved collection script (v2.0 with WmiMonitorID, fallbacks, error tracking) with the analysis script into one file. The script will:\\n\\n1. **Collect** hardware inventory on the current PC\\n2. **Append** to `PC_Inventory_Master.csv` in the same folder as the script (USB root)\\n3. **Optionally analyze** the CSV for issues when `-Analyze` is passed\\n\\n## Script Structure\\n\\n```\\nUSB-Inventory.ps1\\n  [Parameters]\\n    -OutputFile     (default: PC_Inventory_Master.csv in $PSScriptRoot)\\n    -IncludePciDevices\\n    -Analyze        (runs health check after collection)\\n    -AnalyzeOnly    (skip collection, just analyze existing CSV)\\n    -StaleDays      (default: 90)\\n    -MinRamGB       (default: 8)\\n\\n  [Helper Functions]\\n    Clean-Cell, Convert-UShortArrayToString\\n    Get-MonitorInventory (WmiMonitorID preferred, EDID registry fallback)\\n    Get-NetworkInventory (Get-NetAdapter preferred, CIM fallback)\\n    Get-GpuInventory     (CIM + nvidia-smi if present)\\n    Get-DiskInventory    (Get-PhysicalDisk preferred, CIM fallback)\\n    Get-PciDeviceInventory (optional)\\n    \\n    # Analysis helpers\\n    Parse-ScanDate, Normalize-Serial, Parse-RamGB, Is-MonitorMissing\\n    Get-ColumnMap (tolerates renamed headers)\\n\\n  [Main]\\n    IF NOT $AnalyzeOnly:\\n      Collect system/BIOS/CPU/OS/baseboard info\\n      Collect network/GPU/disk/monitor inventories\\n      Build PSCustomObject record\\n      Append to CSV (with header safety)\\n      \\n    IF $Analyze OR $AnalyzeOnly:\\n      Import CSV\\n      Detect duplicates, stale assets, low RAM, missing monitors\\n      Output text report + optional CSV of issues\\n```\\n\\n## Key Design Decisions\\n\\n| Decision | Rationale |\\n|----------|-----------|\\n| PowerShell 5.1 compatible | Ships with Windows 10/11; no `??` operator |\\n| `$PSScriptRoot` for paths | Works correctly when run from USB |\\n| Append mode with header check | Multiple PCs can be scanned to same CSV |\\n| Error column in CSV | Non-fatal errors captured, not hidden |\\n| WmiMonitorID first | More reliable than EDID registry decode |\\n| Analysis is optional | Collection is the primary use case |\\n\\n## Output Files (on USB)\\n\\n- `PC_Inventory_Master.csv` - cumulative inventory\\n- `Inventory_Issues_Report.txt` - human-readable (when `-Analyze`)\\n- `Inventory_Issues_Report.csv` - sortable issues (when `-Analyze`)\\n\\n## Usage Examples\\n\\n```powershell\\n# Basic: collect this PC\u0027s inventory\\n.\\\\USB-Inventory.ps1\\n\\n# Collect with PCI devices and run analysis\\n.\\\\USB-Inventory.ps1 -IncludePciDevices -Analyze\\n\\n# Just analyze existing data (no new collection)\\n.\\\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\\n```\\n\\n## File Location\\n\\nNew file: `USB-Inventory.ps1` (single ~600-line script in workspace root or user-specified location)\\n\",\"name\":\"USB Inventory Script\",\"todos\":[{\"content\":\"Create USB-Inventory.ps1 combining collection + analysis logic\",\"status\":\"pending\",\"id\":\"synth-script\"},{\"content\":\"Test script execution on local machine\",\"status\":\"pending\",\"id\":\"test-local\"}],\"overview\":\"Synthesize Collect-Inventory.ps1 and Analyze-Inventory.ps1 into a single portable PowerShell script that runs from USB to inventory the host PC, with optional health analysis.\"}","additionalData":{"reviewData":{"status":"Requested","selectedOption":"none","isShowingInput":false},"planUri":"file:///c%3A/Users/user/.cursor/plans/usb_4c3f18cf.plan.md","hasOpenedEditor":true,"pinnedName":"USB"},"result":"{\"accepted\":{\"finalTodos\":[{\"content\":\"Create USB-Inventory.ps1 combining collection + analysis logic\",\"status\":\"pending\",\"id\":\"synth-script\"},{\"content\":\"Test script execution on local machine\",\"status\":\"pending\",\"id\":\"test-local\"}]},\"planUri\":\"c:\\\\Users\\\\user\\\\.cursor\\\\plans\\\\usb_4c3f18cf.plan.md\"}"}},"bubbleId":"42289197-423e-486f-a7bb-bd15044a7fcf"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"42df8c24-eb89-420e-90b4-ef1c3cc7d76b","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:59:41.546Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"647c39f5-37d9-4c80-b8f1-a4049431cfce","codeBlocks":[{"uri":{"scheme":"file","authority":"","path":"/c:/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1","query":"","fragment":"","_formatted":"file:///c%3A/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1","_fsPath":"c:\\Users\\user\\Downloads\\Cursor_working_directory_misc\\USB-Inventory.ps1"},"codeblockId":"b2bdde5c-5cdd-4c0b-a21a-3806e20967f4","codeBlockIdx":0,"content":"#requires -Version 5.1\n\u003c#\n.SYNOPSIS\n    USB-portable PC hardware inventory collection and analysis tool.\n\n.DESCRIPTION\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\n    script. Optionally runs health analysis to detect duplicates, stale assets,\n    low RAM, and missing monitor data.\n\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\n\n.PARAMETER OutputFile\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\n\n.PARAMETER IncludePciDevices\n    Include detailed PCI device enumeration (can produce large output).\n\n.PARAMETER Analyze\n    After collection, run health analysis on the CSV file.\n\n.PARAMETER AnalyzeOnly\n    Skip collection; only run health analysis on existing CSV.\n\n.PARAMETER StaleDays\n    Threshold in days for flagging stale assets. Default: 90.\n\n.PARAMETER MinRamGB\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\n\n.PARAMETER NoCsv\n    Do not output Inventory_Issues_Report.csv (text report only).\n\n.EXAMPLE\n    .\\USB-Inventory.ps1\n    Collect inventory from this PC into PC_Inventory_Master.csv.\n\n.EXAMPLE\n    .\\USB-Inventory.ps1 -IncludePciDevices -Analyze\n    Collect inventory with PCI devices, then run health analysis.\n\n.EXAMPLE\n    .\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\n    Analyze existing CSV with custom thresholds (no new collection).\n#\u003e\n\n[CmdletBinding()]\nparam(\n    [string]$OutputFile,\n    [switch]$IncludePciDevices,\n    [switch]$Analyze,\n    [switch]$AnalyzeOnly,\n    [int]$StaleDays = 90,\n    [int]$MinRamGB = 8,\n    [switch]$NoCsv\n)\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = \u0027Stop\u0027\n\n# Resolve script root (handles -File invocation where $PSScriptRoot may be empty)\n$ScriptDir = $PSScriptRoot\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\n    $ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition\n}\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\n    $ScriptDir = $PWD.Path\n}\n\n# Default OutputFile if not specified\nif ([string]::IsNullOrWhiteSpace($OutputFile)) {\n    $OutputFile = Join-Path -Path $ScriptDir -ChildPath \u0027PC_Inventory_Master.csv\u0027\n}\n\n# ============================================================================\n# HELPER FUNCTIONS - COLLECTION\n# ============================================================================\n\nfunction Clean-Cell {\n    param([AllowNull()][string]$Text)\n    if ($null -eq $Text) { return \u0027\u0027 }\n    return ($Text -replace \"(`r`n|`n|`r|`t)+\", \u0027 \u0027).Trim()\n}\n\nfunction Convert-UShortArrayToString {\n    param([AllowNull()]$Arr)\n    if ($null -eq $Arr) { return \u0027\u0027 }\n    $chars = foreach ($x in $Arr) {\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\n    }\n    return ( -join $chars ).Trim()\n}\n\nfunction Get-MonitorInventory {\n    \u003c#\n      Preferred: root\\wmi:WmiMonitorID (easy, consistent, usually no admin)\n      Fallback: registry EDID decode under HKLM:\\SYSTEM\\CCS\\Enum\\DISPLAY\n    #\u003e\n\n    $results = New-Object System.Collections.Generic.List[string]\n\n    # --- Preferred path: WmiMonitorID ---\n    try {\n        $wmiMons = Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorID -ErrorAction Stop\n        foreach ($m in $wmiMons) {\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\n\n            $label = @()\n            if ($mfg)  { $label += $mfg }\n            if ($name) { $label += $name }\n\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\n            $serialPart  = if ($sn) { \"SN:$sn\" } else { \u0027SN:(none)\u0027 }\n\n            $results.Add(\"$displayName ($serialPart)\")\n        }\n    } catch {\n        # WmiMonitorID not available; fall through to EDID fallback\n    }\n\n    if ($results.Count -gt 0) {\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n    }\n\n    # --- Fallback path: registry EDID decode ---\n    function Get-EdidDescriptorString {\n        param(\n            [byte[]]$Edid,\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\n        )\n\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\n\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\n\n        foreach ($offset in 54,72,90,108) {\n            if (($offset + 18) -gt $Edid.Length) { continue }\n\n            # Descriptor: 00 00 00 {tag} 00 ...\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\n\n                $bytes = $Edid[($offset+5)..($offset+17)]\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\n                $text = ($text -replace \"[`0`n`r]+\", \u0027\u0027).Trim()\n                if ($text) { return $text }\n            }\n        }\n\n        return \u0027\u0027\n    }\n\n    try {\n        $root = \u0027HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\DISPLAY\u0027\n        if (Test-Path -LiteralPath $root) {\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\n                    if (Test-Path -LiteralPath $params) {\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\n                        if ($edid -is [byte[]]) {\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\n\n                            # Numeric serial (bytes 12-15 LE) sometimes present\n                            $num = [BitConverter]::ToUInt32($edid, 12)\n                            $numStr = if ($num -ne 0) { \"NUM:$num\" } else { \u0027\u0027 }\n\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\n                            $serialPart  = if ($sn) { \"SN:$sn\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\n\n                            $results.Add(\"$displayName ($serialPart)\")\n                        }\n                    }\n                }\n            }\n        }\n    } catch {\n        # EDID fallback failed silently\n    }\n\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-NetworkInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\n\n    if ($hasNetAdapter -and $hasNetIpCfg) {\n        try {\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\n            foreach ($a in $adapters) {\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\n                $ipv4 = @()\n                if ($cfg -and $cfg.IPv4Address) {\n                    $ipv4 = $cfg.IPv4Address |\n                        ForEach-Object { $_.IPAddress } |\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\n                }\n                $gw = @()\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\n                }\n\n                $parts = @()\n                $parts += (Clean-Cell $a.Name)\n                if ($a.MacAddress) { $parts += \"MAC:$($a.MacAddress)\" }\n                if ($ipv4.Count -gt 0) { $parts += (\"IPv4:\" + ($ipv4 -join \u0027;\u0027)) }\n                if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n                $items.Add(($parts -join \u0027 \u0027))\n            }\n        } catch {\n            # Fall back to CIM below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\n            Where-Object { $_.IPEnabled -eq $true }\n\n        foreach ($n in $net) {\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\n            $mac  = $n.MACAddress\n            $ips  = @()\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\n            $gw   = @()\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\n\n            $parts = @()\n            $parts += (Clean-Cell $name)\n            if ($mac) { $parts += \"MAC:$mac\" }\n            if ($ips.Count -gt 0) { $parts += (\"IP:\" + ($ips -join \u0027;\u0027)) }\n            if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n            $items.Add(($parts -join \u0027 \u0027))\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-GpuInventory {\n    $gpus = New-Object System.Collections.Generic.List[string]\n\n    # CIM GPUs\n    try {\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\n        foreach ($g in $vc) {\n            $name = Clean-Cell $g.Name\n            $pnp  = Clean-Cell $g.PNPDeviceID\n            if ($name -or $pnp) {\n                $gpus.Add((\"{0}{1}\" -f $name, $(if ($pnp) { \" [ID:$pnp]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    # Optional NVIDIA serials if nvidia-smi exists\n    try {\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\n        if ($nvsmi) {\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\n            foreach ($line in @($raw)) {\n                $t = Clean-Cell $line\n                if ($t) { $gpus.Add(\"NVIDIA $t\") }\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-DiskInventory {\n    $disks = New-Object System.Collections.Generic.List[string]\n\n    # Prefer Storage module when available\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\n    if ($hasPhysicalDisk) {\n        try {\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\n                $name = Clean-Cell $d.FriendlyName\n                $sn   = Clean-Cell $d.SerialNumber\n                $mt   = Clean-Cell ([string]$d.MediaType)\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n                $parts = @()\n                if ($name) { $parts += $name }\n                if ($sn)   { $parts += \"SN:$sn\" }\n                if ($mt)   { $parts += \"Type:$mt\" }\n                if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n            }\n        } catch {\n            # Fall back below\n        }\n    }\n\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\n            $model = Clean-Cell $d.Model\n            $sn = \u0027\u0027\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\n            $devId = Clean-Cell $d.DeviceID\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n            $parts = @()\n            if ($model) { $parts += $model }\n            if ($sn)    { $parts += \"SN:$sn\" }\n            if ($devId) { $parts += \"Dev:$devId\" }\n            if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-PciDeviceInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\n    if ($hasGetPnpDevice) {\n        try {\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\n                Where-Object { $_.InstanceId -like \u0027PCI\\*\u0027 } |\n                Sort-Object -Property Class, FriendlyName, Name\n\n            foreach ($d in $devs) {\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\n                $name = Clean-Cell $name\n                $cls  = Clean-Cell $d.Class\n                $id   = Clean-Cell $d.InstanceId\n                if ($name -or $id) {\n                    $items.Add((\"{0}{1}{2}\" -f $name, $(if ($cls) { \" [Class:$cls]\" } else { \u0027\u0027 }), $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n                }\n            }\n        } catch {\n            # Fall back below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM Win32_PnPEntity\n    try {\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\*\u0027 } |\n            Sort-Object -Property Name\n\n        foreach ($d in $devs) {\n            $name = Clean-Cell $d.Name\n            $id   = Clean-Cell $d.PNPDeviceID\n            if ($name -or $id) {\n                $items.Add((\"{0}{1}\" -f $name, $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\n# ============================================================================\n# HELPER FUNCTIONS - ANALYSIS\n# ============================================================================\n\nfunction Get-ColumnMap {\n    param([string[]]$Headers)\n\n    $map = @{\n        Hostname        = \u0027Hostname\u0027\n        User            = \u0027User\u0027\n        System_Serial   = \u0027System_Serial\u0027\n        RAM_GB          = \u0027RAM_GB\u0027\n        Monitor_Serials = \u0027Monitor_Serials\u0027\n        Scan_Date       = \u0027Scan_Date\u0027\n    }\n\n    foreach ($k in @($map.Keys)) {\n        if ($Headers -notcontains $map[$k]) {\n            $alts = switch ($k) {\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\n                default           { @() }\n            }\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\n            if ($found) { $map[$k] = $found }\n        }\n    }\n\n    return $map\n}\n\nfunction Parse-ScanDate {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    $dt = $null\n\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\n\n    if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\n\n    return $null\n}\n\nfunction Normalize-Serial {\n    param([AllowNull()][string]$Serial)\n\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\n    $s = ($Serial.Trim())\n\n    $bad = @(\n        \u0027To Be Filled By O.E.M.\u0027,\n        \u0027To Be Filled By OEM\u0027,\n        \u0027Default string\u0027,\n        \u0027System Serial Number\u0027,\n        \u0027None\u0027,\n        \u0027N/A\u0027,\n        \u0027NA\u0027,\n        \u00270\u0027,\n        \u002700000000\u0027,\n        \u00270000000000\u0027,\n        \u00270000000000000000\u0027\n    )\n\n    if ($bad -contains $s) { return \u0027\u0027 }\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\n\n    return $s.ToUpperInvariant()\n}\n\nfunction Parse-RamGB {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    $m = [regex]::Match($s, \u0027(\\d+)(\\.\\d+)?\u0027)\n    if (-not $m.Success) { return $null }\n\n    $n = $null\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\n        return [int][math]::Round($n, 0)\n    }\n\n    return $null\n}\n\nfunction Is-MonitorMissing {\n    param([AllowNull()][string]$Value)\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\n    $t = $Value.Trim()\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\n}\n\n# ============================================================================\n# MAIN: COLLECTION\n# ============================================================================\n\nfunction Invoke-Collection {\n    param([string]$OutPath, [switch]$IncludePci)\n\n    $errors = New-Object System.Collections.Generic.List[string]\n\n    Write-Host \"`n========================================================\" -ForegroundColor Cyan\n    Write-Host \"   GATHERING HARDWARE SPECS... PLEASE WAIT\" -ForegroundColor Cyan\n    Write-Host \"========================================================\" -ForegroundColor Cyan\n\n    # --- Collect core system info ---\n    $sys  = $null\n    $bios = $null\n    $cpu  = $null\n    $os   = $null\n    $bb   = $null\n\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_ComputerSystem: $($_.Exception.Message)\") }\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\"Win32_BIOS: $($_.Exception.Message)\") }\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_Processor: $($_.Exception.Message)\") }\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_OperatingSystem: $($_.Exception.Message)\") }\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_BaseBoard: $($_.Exception.Message)\") }\n\n    # --- Derived values ---\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\n\n    $ramGB = $null\n    try {\n        if ($sys -and $sys.TotalPhysicalMemory) {\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\n        }\n    } catch {\n        $errors.Add(\"RAM calc: $($_.Exception.Message)\")\n    }\n\n    # --- Other sections ---\n    $netStr  = \u0027\u0027\n    $gpuStr  = \u0027\u0027\n    $diskStr = \u0027\u0027\n    $monStr  = \u0027\u0027\n    $pciStr  = \u0027\u0027\n\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\"Network: $($_.Exception.Message)\") }\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\"GPU: $($_.Exception.Message)\") }\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\"Disks: $($_.Exception.Message)\") }\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\"Monitors: $($_.Exception.Message)\") }\n\n    if ($IncludePci) {\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\"PCI devices: $($_.Exception.Message)\") }\n    }\n\n    # --- Build record ---\n    $record = [pscustomobject]@{\n        Hostname          = Clean-Cell $hostname\n        User              = Clean-Cell $env:USERNAME\n\n        Make_Model        = Clean-Cell ((\"{0} {1}\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\n\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\n        Baseboard_Product = Clean-Cell ($bb.Product)\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\n\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\n        BIOS_ReleaseDate  = Clean-Cell (try { ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027) } catch { \u0027\u0027 })\n\n        OS_Caption        = Clean-Cell ($os.Caption)\n        OS_Version        = Clean-Cell ($os.Version)\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\n\n        CPU               = Clean-Cell ($cpu.Name)\n        RAM_GB            = $ramGB\n\n        Network_Adapters  = Clean-Cell $netStr\n        GPUs              = Clean-Cell $gpuStr\n        Disk_Serials      = Clean-Cell $diskStr\n        Monitor_Serials   = Clean-Cell $monStr\n\n        PCI_Devices       = Clean-Cell $pciStr\n\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\n        Collector_Version = \u00272.0\u0027\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\n    }\n\n    # --- CSV append with header safety ---\n    $needHeader = $true\n    if (Test-Path -LiteralPath $OutPath) {\n        try {\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\n            if ($fi.Length -gt 0) { $needHeader = $false }\n        } catch { $needHeader = $true }\n    }\n\n    if ($needHeader) {\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\n    } else {\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\n    }\n\n    Write-Host \"`nSUCCESS!\" -ForegroundColor Green\n    Write-Host \"Data saved to: $OutPath\" -ForegroundColor Gray\n    if ($record.Errors) {\n        Write-Host (\"Warnings captured in Errors column: {0}\" -f $record.Errors) -ForegroundColor Yellow\n    }\n}\n\n# ============================================================================\n# MAIN: ANALYSIS\n# ============================================================================\n\nfunction Invoke-Analysis {\n    param(\n        [string]$InputPath,\n        [int]$StaleDaysThreshold,\n        [int]$MinRam,\n        [switch]$SkipCsv,\n        [string]$BaseDir\n    )\n\n    $ReportFile = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.txt\u0027\n    $IssuesCsv  = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.csv\u0027\n\n    if (-not (Test-Path -LiteralPath $InputPath)) {\n        Write-Warning \"Input file not found: $InputPath\"\n        Write-Warning \"Run the script without -AnalyzeOnly first to collect data.\"\n        return\n    }\n\n    $raw = Import-Csv -LiteralPath $InputPath\n    if (-not $raw -or $raw.Count -eq 0) {\n        Write-Warning \"Input file contains no rows: $InputPath\"\n        return\n    }\n\n    $headers = @()\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\n    $col = Get-ColumnMap -Headers $headers\n\n    $today = Get-Date\n\n    # Normalize data and add helper properties\n    $data = foreach ($r in $raw) {\n        $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\n        $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\n        $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\n        $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\n        $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\n        $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\n\n        $serialN = Normalize-Serial $serial\n        $scanDt  = Parse-ScanDate $scan\n        $ramGb   = Parse-RamGB $ram\n\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\n\n        # Asset key: prefer System Serial, fallback to Hostname\n        $assetKey = \u0027\u0027\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\n            $assetKey = $serialN\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\n            $assetKey = $h.Trim().ToUpperInvariant()\n        }\n\n        [pscustomobject]@{\n            Hostname        = $h.Trim()\n            User            = $u.Trim()\n            System_Serial   = $serialN\n            RAM_GB          = $ramGb\n            Monitor_Serials = $m.Trim()\n            Scan_Date       = $s.Trim()\n\n            ScanDateParsed  = $scanDt\n            AssetKey        = $assetKey\n            RawRow          = $r\n        }\n    }\n\n    # Latest record per asset\n    $latestByAsset = $data |\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\n        Group-Object -Property AssetKey |\n        ForEach-Object { $_.Group | Select-Object -First 1 }\n\n    $issues = New-Object System.Collections.Generic.List[object]\n\n    function Add-Issue {\n        param(\n            [Parameter(Mandatory)][string]$IssueType,\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\n            [string]$AssetKey,\n            [string]$Hostname,\n            [string]$User,\n            [string]$SystemSerial,\n            [string]$ScanDate,\n            [string]$Details\n        )\n\n        $issues.Add([pscustomobject]@{\n            IssueType     = $IssueType\n            Severity      = $Severity\n            AssetKey      = $AssetKey\n            Hostname      = $Hostname\n            User          = $User\n            System_Serial = $SystemSerial\n            Scan_Date     = $ScanDate\n            Details       = $Details\n        })\n    }\n\n    # 0) Data quality (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\n        }\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\n        }\n        if (-not $pc.ScanDateParsed) {\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\n        }\n    }\n\n    # 1) Duplicate serials (all rows; ignore blanks)\n    $dupeGroups = $data |\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\n        Group-Object -Property System_Serial |\n        Where-Object { $_.Count -gt 1 }\n\n    foreach ($g in $dupeGroups) {\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\n\n        $severity =\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\n            else { \u0027Info\u0027 }\n\n        $entries = $g.Group |\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\n            ForEach-Object {\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\n                \"{0} ({1})\" -f $_.Hostname, $d\n            }\n\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\n    }\n\n    # 2) Low RAM (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\"RAM_GB={0} (min {1})\" -f $pc.RAM_GB, $MinRam)\n        } elseif ($null -eq $pc.RAM_GB) {\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\n        }\n    }\n\n    # 3) Stale assets (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ($pc.ScanDateParsed) {\n            $ageDays = ($today - $pc.ScanDateParsed).Days\n            if ($ageDays -gt $StaleDaysThreshold) {\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\"Last seen {0} days ago (threshold {1})\" -f $ageDays, $StaleDaysThreshold)\n            }\n        }\n    }\n\n    # 4) Missing monitor serials (latest records)\n    foreach ($pc in $latestByAsset) {\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\n        }\n    }\n\n    # --- Build text report ---\n    $generated = Get-Date\n    $line = (\u0027=\u0027 * 70)\n\n    $txt = New-Object System.Collections.Generic.List[string]\n    $txt.Add($line)\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\n    $txt.Add(\"Generated: $generated\")\n    $txt.Add(\"Input:     $InputPath\")\n    $txt.Add((\"Assets:    {0} (latest per asset)\" -f $latestByAsset.Count))\n    $txt.Add((\"Rows:      {0} (raw rows in CSV)\" -f $data.Count))\n    $txt.Add((\"Settings:  MinRamGB={0}, StaleDays={1}\" -f $MinRam, $StaleDaysThreshold))\n    $txt.Add($line)\n    $txt.Add(\u0027\u0027)\n\n    if ($issues.Count -eq 0) {\n        $txt.Add(\u0027No issues found.\u0027)\n    } else {\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\n        foreach ($t in $byType) {\n            $txt.Add((\"--- {0} ({1}) ---\" -f $t.Name, $t.Count))\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\n\n                $txt.Add((\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\n            }\n            $txt.Add(\u0027\u0027)\n        }\n    }\n\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\n\n    if (-not $SkipCsv) {\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\n    }\n\n    # --- Console summary ---\n    Write-Host \"`n$line\" -ForegroundColor Cyan\n    Write-Host (\"Report saved: {0}\" -f $ReportFile) -ForegroundColor Green\n    if (-not $SkipCsv) { Write-Host (\"Issues CSV:   {0}\" -f $IssuesCsv) -ForegroundColor Green }\n    Write-Host (\"Issues found: {0}\" -f $issues.Count) -ForegroundColor Yellow\n    Write-Host $line -ForegroundColor Cyan\n\n    if ($issues.Count -gt 0) {\n        $sev = $issues | Group-Object Severity | Sort-Object Name\n        foreach ($s in $sev) {\n            $c = switch ($s.Name) {\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\n                default    { [ConsoleColor]::Gray }\n            }\n            Write-Host (\"{0}: {1}\" -f $s.Name, $s.Count) -ForegroundColor $c\n        }\n    }\n}\n\n# ============================================================================\n# ENTRY POINT\n# ============================================================================\n\nif (-not $AnalyzeOnly) {\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\n}\n\nif ($Analyze -or $AnalyzeOnly) {\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv -BaseDir $ScriptDir\n}\n\nif (-not $AnalyzeOnly -and -not $Analyze) {\n    Write-Host \"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\" -ForegroundColor DarkGray\n}\n\n","languageId":"powershell"}],"capabilityType":15,"toolFormerData":{"tool":38,"toolCallId":"toolu_vrtx_01CYXHWdmYuy14BLcccFyuE6","toolIndex":1,"modelCallId":"f9cd5cd4-9eeb-4d94-bed6-b650a498926d","status":"completed","rawArgs":"{\"file_path\": \"USB-Inventory.ps1\", \"old_string\": \"if ($Analyze -or $AnalyzeOnly) {\\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv\\n}\", \"new_string\": \"if ($Analyze -or $AnalyzeOnly) {\\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv -BaseDir $ScriptDir\\n}\"}","name":"search_replace","params":"{\"relativeWorkspacePath\":\"USB-Inventory.ps1\"}","additionalData":{"codeblockId":"b2bdde5c-5cdd-4c0b-a21a-3806e20967f4"},"userDecision":"accepted","result":"{\"diff\":{\"chunks\":[{\"diffString\":\"  \\n  if ($Analyze -or $AnalyzeOnly) {\\n-     Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv\\n+     Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv -BaseDir $ScriptDir\\n  }\\n  \",\"oldStart\":841,\"newStart\":841,\"oldLines\":5,\"newLines\":5,\"linesRemoved\":1,\"linesAdded\":1}],\"editor\":\"EDITOR_AI\"},\"shouldAutoFixLints\":true,\"resultForModel\":\"The file USB-Inventory.ps1 has been updated.\",\"contentsAfterEdit\":\"#requires -Version 5.1\\n\u003c#\\n.SYNOPSIS\\n    USB-portable PC hardware inventory collection and analysis tool.\\n\\n.DESCRIPTION\\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\\n    script. Optionally runs health analysis to detect duplicates, stale assets,\\n    low RAM, and missing monitor data.\\n\\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\\n\\n.PARAMETER OutputFile\\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\\n\\n.PARAMETER IncludePciDevices\\n    Include detailed PCI device enumeration (can produce large output).\\n\\n.PARAMETER Analyze\\n    After collection, run health analysis on the CSV file.\\n\\n.PARAMETER AnalyzeOnly\\n    Skip collection; only run health analysis on existing CSV.\\n\\n.PARAMETER StaleDays\\n    Threshold in days for flagging stale assets. Default: 90.\\n\\n.PARAMETER MinRamGB\\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\\n\\n.PARAMETER NoCsv\\n    Do not output Inventory_Issues_Report.csv (text report only).\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1\\n    Collect inventory from this PC into PC_Inventory_Master.csv.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -IncludePciDevices -Analyze\\n    Collect inventory with PCI devices, then run health analysis.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\\n    Analyze existing CSV with custom thresholds (no new collection).\\n#\u003e\\n\\n[CmdletBinding()]\\nparam(\\n    [string]$OutputFile,\\n    [switch]$IncludePciDevices,\\n    [switch]$Analyze,\\n    [switch]$AnalyzeOnly,\\n    [int]$StaleDays = 90,\\n    [int]$MinRamGB = 8,\\n    [switch]$NoCsv\\n)\\n\\nSet-StrictMode -Version Latest\\n$ErrorActionPreference = \u0027Stop\u0027\\n\\n# Resolve script root (handles -File invocation where $PSScriptRoot may be empty)\\n$ScriptDir = $PSScriptRoot\\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n    $ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition\\n}\\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n    $ScriptDir = $PWD.Path\\n}\\n\\n# Default OutputFile if not specified\\nif ([string]::IsNullOrWhiteSpace($OutputFile)) {\\n    $OutputFile = Join-Path -Path $ScriptDir -ChildPath \u0027PC_Inventory_Master.csv\u0027\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - COLLECTION\\n# ============================================================================\\n\\nfunction Clean-Cell {\\n    param([AllowNull()][string]$Text)\\n    if ($null -eq $Text) { return \u0027\u0027 }\\n    return ($Text -replace \\\"(`r`n|`n|`r|`t)+\\\", \u0027 \u0027).Trim()\\n}\\n\\nfunction Convert-UShortArrayToString {\\n    param([AllowNull()]$Arr)\\n    if ($null -eq $Arr) { return \u0027\u0027 }\\n    $chars = foreach ($x in $Arr) {\\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\\n    }\\n    return ( -join $chars ).Trim()\\n}\\n\\nfunction Get-MonitorInventory {\\n    \u003c#\\n      Preferred: root\\\\wmi:WmiMonitorID (easy, consistent, usually no admin)\\n      Fallback: registry EDID decode under HKLM:\\\\SYSTEM\\\\CCS\\\\Enum\\\\DISPLAY\\n    #\u003e\\n\\n    $results = New-Object System.Collections.Generic.List[string]\\n\\n    # --- Preferred path: WmiMonitorID ---\\n    try {\\n        $wmiMons = Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorID -ErrorAction Stop\\n        foreach ($m in $wmiMons) {\\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\\n\\n            $label = @()\\n            if ($mfg)  { $label += $mfg }\\n            if ($name) { $label += $name }\\n\\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\\n            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } else { \u0027SN:(none)\u0027 }\\n\\n            $results.Add(\\\"$displayName ($serialPart)\\\")\\n        }\\n    } catch {\\n        # WmiMonitorID not available; fall through to EDID fallback\\n    }\\n\\n    if ($results.Count -gt 0) {\\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n    }\\n\\n    # --- Fallback path: registry EDID decode ---\\n    function Get-EdidDescriptorString {\\n        param(\\n            [byte[]]$Edid,\\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\\n        )\\n\\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\\n\\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\\n\\n        foreach ($offset in 54,72,90,108) {\\n            if (($offset + 18) -gt $Edid.Length) { continue }\\n\\n            # Descriptor: 00 00 00 {tag} 00 ...\\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\\n\\n                $bytes = $Edid[($offset+5)..($offset+17)]\\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\\n                $text = ($text -replace \\\"[`0`n`r]+\\\", \u0027\u0027).Trim()\\n                if ($text) { return $text }\\n            }\\n        }\\n\\n        return \u0027\u0027\\n    }\\n\\n    try {\\n        $root = \u0027HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Enum\\\\DISPLAY\u0027\\n        if (Test-Path -LiteralPath $root) {\\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\\n                    if (Test-Path -LiteralPath $params) {\\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\\n                        if ($edid -is [byte[]]) {\\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\\n\\n                            # Numeric serial (bytes 12-15 LE) sometimes present\\n                            $num = [BitConverter]::ToUInt32($edid, 12)\\n                            $numStr = if ($num -ne 0) { \\\"NUM:$num\\\" } else { \u0027\u0027 }\\n\\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\\n                            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\\n\\n                            $results.Add(\\\"$displayName ($serialPart)\\\")\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    } catch {\\n        # EDID fallback failed silently\\n    }\\n\\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-NetworkInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\\n\\n    if ($hasNetAdapter -and $hasNetIpCfg) {\\n        try {\\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\\n            foreach ($a in $adapters) {\\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\\n                $ipv4 = @()\\n                if ($cfg -and $cfg.IPv4Address) {\\n                    $ipv4 = $cfg.IPv4Address |\\n                        ForEach-Object { $_.IPAddress } |\\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\\n                }\\n                $gw = @()\\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\\n                }\\n\\n                $parts = @()\\n                $parts += (Clean-Cell $a.Name)\\n                if ($a.MacAddress) { $parts += \\\"MAC:$($a.MacAddress)\\\" }\\n                if ($ipv4.Count -gt 0) { $parts += (\\\"IPv4:\\\" + ($ipv4 -join \u0027;\u0027)) }\\n                if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n                $items.Add(($parts -join \u0027 \u0027))\\n            }\\n        } catch {\\n            # Fall back to CIM below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\\n            Where-Object { $_.IPEnabled -eq $true }\\n\\n        foreach ($n in $net) {\\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\\n            $mac  = $n.MACAddress\\n            $ips  = @()\\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\\n            $gw   = @()\\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\\n\\n            $parts = @()\\n            $parts += (Clean-Cell $name)\\n            if ($mac) { $parts += \\\"MAC:$mac\\\" }\\n            if ($ips.Count -gt 0) { $parts += (\\\"IP:\\\" + ($ips -join \u0027;\u0027)) }\\n            if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n            $items.Add(($parts -join \u0027 \u0027))\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-GpuInventory {\\n    $gpus = New-Object System.Collections.Generic.List[string]\\n\\n    # CIM GPUs\\n    try {\\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\\n        foreach ($g in $vc) {\\n            $name = Clean-Cell $g.Name\\n            $pnp  = Clean-Cell $g.PNPDeviceID\\n            if ($name -or $pnp) {\\n                $gpus.Add((\\\"{0}{1}\\\" -f $name, $(if ($pnp) { \\\" [ID:$pnp]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    # Optional NVIDIA serials if nvidia-smi exists\\n    try {\\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\\n        if ($nvsmi) {\\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\\n            foreach ($line in @($raw)) {\\n                $t = Clean-Cell $line\\n                if ($t) { $gpus.Add(\\\"NVIDIA $t\\\") }\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-DiskInventory {\\n    $disks = New-Object System.Collections.Generic.List[string]\\n\\n    # Prefer Storage module when available\\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasPhysicalDisk) {\\n        try {\\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\\n                $name = Clean-Cell $d.FriendlyName\\n                $sn   = Clean-Cell $d.SerialNumber\\n                $mt   = Clean-Cell ([string]$d.MediaType)\\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n                $parts = @()\\n                if ($name) { $parts += $name }\\n                if ($sn)   { $parts += \\\"SN:$sn\\\" }\\n                if ($mt)   { $parts += \\\"Type:$mt\\\" }\\n                if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\\n            $model = Clean-Cell $d.Model\\n            $sn = \u0027\u0027\\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\\n            $devId = Clean-Cell $d.DeviceID\\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n            $parts = @()\\n            if ($model) { $parts += $model }\\n            if ($sn)    { $parts += \\\"SN:$sn\\\" }\\n            if ($devId) { $parts += \\\"Dev:$devId\\\" }\\n            if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-PciDeviceInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasGetPnpDevice) {\\n        try {\\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\\n                Where-Object { $_.InstanceId -like \u0027PCI\\\\*\u0027 } |\\n                Sort-Object -Property Class, FriendlyName, Name\\n\\n            foreach ($d in $devs) {\\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\\n                $name = Clean-Cell $name\\n                $cls  = Clean-Cell $d.Class\\n                $id   = Clean-Cell $d.InstanceId\\n                if ($name -or $id) {\\n                    $items.Add((\\\"{0}{1}{2}\\\" -f $name, $(if ($cls) { \\\" [Class:$cls]\\\" } else { \u0027\u0027 }), $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n                }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM Win32_PnPEntity\\n    try {\\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\\\*\u0027 } |\\n            Sort-Object -Property Name\\n\\n        foreach ($d in $devs) {\\n            $name = Clean-Cell $d.Name\\n            $id   = Clean-Cell $d.PNPDeviceID\\n            if ($name -or $id) {\\n                $items.Add((\\\"{0}{1}\\\" -f $name, $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - ANALYSIS\\n# ============================================================================\\n\\nfunction Get-ColumnMap {\\n    param([string[]]$Headers)\\n\\n    $map = @{\\n        Hostname        = \u0027Hostname\u0027\\n        User            = \u0027User\u0027\\n        System_Serial   = \u0027System_Serial\u0027\\n        RAM_GB          = \u0027RAM_GB\u0027\\n        Monitor_Serials = \u0027Monitor_Serials\u0027\\n        Scan_Date       = \u0027Scan_Date\u0027\\n    }\\n\\n    foreach ($k in @($map.Keys)) {\\n        if ($Headers -notcontains $map[$k]) {\\n            $alts = switch ($k) {\\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\\n                default           { @() }\\n            }\\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\\n            if ($found) { $map[$k] = $found }\\n        }\\n    }\\n\\n    return $map\\n}\\n\\nfunction Parse-ScanDate {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    $dt = $null\\n\\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n\\n    if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\\n\\n    return $null\\n}\\n\\nfunction Normalize-Serial {\\n    param([AllowNull()][string]$Serial)\\n\\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\\n    $s = ($Serial.Trim())\\n\\n    $bad = @(\\n        \u0027To Be Filled By O.E.M.\u0027,\\n        \u0027To Be Filled By OEM\u0027,\\n        \u0027Default string\u0027,\\n        \u0027System Serial Number\u0027,\\n        \u0027None\u0027,\\n        \u0027N/A\u0027,\\n        \u0027NA\u0027,\\n        \u00270\u0027,\\n        \u002700000000\u0027,\\n        \u00270000000000\u0027,\\n        \u00270000000000000000\u0027\\n    )\\n\\n    if ($bad -contains $s) { return \u0027\u0027 }\\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\\n\\n    return $s.ToUpperInvariant()\\n}\\n\\nfunction Parse-RamGB {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    $m = [regex]::Match($s, \u0027(\\\\d+)(\\\\.\\\\d+)?\u0027)\\n    if (-not $m.Success) { return $null }\\n\\n    $n = $null\\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\\n        return [int][math]::Round($n, 0)\\n    }\\n\\n    return $null\\n}\\n\\nfunction Is-MonitorMissing {\\n    param([AllowNull()][string]$Value)\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\\n    $t = $Value.Trim()\\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\\n}\\n\\n# ============================================================================\\n# MAIN: COLLECTION\\n# ============================================================================\\n\\nfunction Invoke-Collection {\\n    param([string]$OutPath, [switch]$IncludePci)\\n\\n    $errors = New-Object System.Collections.Generic.List[string]\\n\\n    Write-Host \\\"`n========================================================\\\" -ForegroundColor Cyan\\n    Write-Host \\\"   GATHERING HARDWARE SPECS... PLEASE WAIT\\\" -ForegroundColor Cyan\\n    Write-Host \\\"========================================================\\\" -ForegroundColor Cyan\\n\\n    # --- Collect core system info ---\\n    $sys  = $null\\n    $bios = $null\\n    $cpu  = $null\\n    $os   = $null\\n    $bb   = $null\\n\\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_ComputerSystem: $($_.Exception.Message)\\\") }\\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\\\"Win32_BIOS: $($_.Exception.Message)\\\") }\\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_Processor: $($_.Exception.Message)\\\") }\\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_OperatingSystem: $($_.Exception.Message)\\\") }\\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_BaseBoard: $($_.Exception.Message)\\\") }\\n\\n    # --- Derived values ---\\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\\n\\n    $ramGB = $null\\n    try {\\n        if ($sys -and $sys.TotalPhysicalMemory) {\\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\\n        }\\n    } catch {\\n        $errors.Add(\\\"RAM calc: $($_.Exception.Message)\\\")\\n    }\\n\\n    # --- Other sections ---\\n    $netStr  = \u0027\u0027\\n    $gpuStr  = \u0027\u0027\\n    $diskStr = \u0027\u0027\\n    $monStr  = \u0027\u0027\\n    $pciStr  = \u0027\u0027\\n\\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\\\"Network: $($_.Exception.Message)\\\") }\\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\\\"GPU: $($_.Exception.Message)\\\") }\\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\\\"Disks: $($_.Exception.Message)\\\") }\\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\\\"Monitors: $($_.Exception.Message)\\\") }\\n\\n    if ($IncludePci) {\\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\\\"PCI devices: $($_.Exception.Message)\\\") }\\n    }\\n\\n    # --- Build record ---\\n    $record = [pscustomobject]@{\\n        Hostname          = Clean-Cell $hostname\\n        User              = Clean-Cell $env:USERNAME\\n\\n        Make_Model        = Clean-Cell ((\\\"{0} {1}\\\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\\n\\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\\n        Baseboard_Product = Clean-Cell ($bb.Product)\\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\\n\\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\\n        BIOS_ReleaseDate  = Clean-Cell (try { ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027) } catch { \u0027\u0027 })\\n\\n        OS_Caption        = Clean-Cell ($os.Caption)\\n        OS_Version        = Clean-Cell ($os.Version)\\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\\n\\n        CPU               = Clean-Cell ($cpu.Name)\\n        RAM_GB            = $ramGB\\n\\n        Network_Adapters  = Clean-Cell $netStr\\n        GPUs              = Clean-Cell $gpuStr\\n        Disk_Serials      = Clean-Cell $diskStr\\n        Monitor_Serials   = Clean-Cell $monStr\\n\\n        PCI_Devices       = Clean-Cell $pciStr\\n\\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\\n        Collector_Version = \u00272.0\u0027\\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\\n    }\\n\\n    # --- CSV append with header safety ---\\n    $needHeader = $true\\n    if (Test-Path -LiteralPath $OutPath) {\\n        try {\\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\\n            if ($fi.Length -gt 0) { $needHeader = $false }\\n        } catch { $needHeader = $true }\\n    }\\n\\n    if ($needHeader) {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\\n    } else {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\\n    }\\n\\n    Write-Host \\\"`nSUCCESS!\\\" -ForegroundColor Green\\n    Write-Host \\\"Data saved to: $OutPath\\\" -ForegroundColor Gray\\n    if ($record.Errors) {\\n        Write-Host (\\\"Warnings captured in Errors column: {0}\\\" -f $record.Errors) -ForegroundColor Yellow\\n    }\\n}\\n\\n# ============================================================================\\n# MAIN: ANALYSIS\\n# ============================================================================\\n\\nfunction Invoke-Analysis {\\n    param(\\n        [string]$InputPath,\\n        [int]$StaleDaysThreshold,\\n        [int]$MinRam,\\n        [switch]$SkipCsv,\\n        [string]$BaseDir\\n    )\\n\\n    $ReportFile = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.txt\u0027\\n    $IssuesCsv  = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.csv\u0027\\n\\n    if (-not (Test-Path -LiteralPath $InputPath)) {\\n        Write-Warning \\\"Input file not found: $InputPath\\\"\\n        Write-Warning \\\"Run the script without -AnalyzeOnly first to collect data.\\\"\\n        return\\n    }\\n\\n    $raw = Import-Csv -LiteralPath $InputPath\\n    if (-not $raw -or $raw.Count -eq 0) {\\n        Write-Warning \\\"Input file contains no rows: $InputPath\\\"\\n        return\\n    }\\n\\n    $headers = @()\\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\\n    $col = Get-ColumnMap -Headers $headers\\n\\n    $today = Get-Date\\n\\n    # Normalize data and add helper properties\\n    $data = foreach ($r in $raw) {\\n        $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\\n        $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\\n        $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\\n        $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\\n        $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\\n        $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\\n\\n        $serialN = Normalize-Serial $serial\\n        $scanDt  = Parse-ScanDate $scan\\n        $ramGb   = Parse-RamGB $ram\\n\\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\\n\\n        # Asset key: prefer System Serial, fallback to Hostname\\n        $assetKey = \u0027\u0027\\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\\n            $assetKey = $serialN\\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\\n            $assetKey = $h.Trim().ToUpperInvariant()\\n        }\\n\\n        [pscustomobject]@{\\n            Hostname        = $h.Trim()\\n            User            = $u.Trim()\\n            System_Serial   = $serialN\\n            RAM_GB          = $ramGb\\n            Monitor_Serials = $m.Trim()\\n            Scan_Date       = $s.Trim()\\n\\n            ScanDateParsed  = $scanDt\\n            AssetKey        = $assetKey\\n            RawRow          = $r\\n        }\\n    }\\n\\n    # Latest record per asset\\n    $latestByAsset = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\\n        Group-Object -Property AssetKey |\\n        ForEach-Object { $_.Group | Select-Object -First 1 }\\n\\n    $issues = New-Object System.Collections.Generic.List[object]\\n\\n    function Add-Issue {\\n        param(\\n            [Parameter(Mandatory)][string]$IssueType,\\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\\n            [string]$AssetKey,\\n            [string]$Hostname,\\n            [string]$User,\\n            [string]$SystemSerial,\\n            [string]$ScanDate,\\n            [string]$Details\\n        )\\n\\n        $issues.Add([pscustomobject]@{\\n            IssueType     = $IssueType\\n            Severity      = $Severity\\n            AssetKey      = $AssetKey\\n            Hostname      = $Hostname\\n            User          = $User\\n            System_Serial = $SystemSerial\\n            Scan_Date     = $ScanDate\\n            Details       = $Details\\n        })\\n    }\\n\\n    # 0) Data quality (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\\n        }\\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\\n        }\\n        if (-not $pc.ScanDateParsed) {\\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\\n        }\\n    }\\n\\n    # 1) Duplicate serials (all rows; ignore blanks)\\n    $dupeGroups = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\\n        Group-Object -Property System_Serial |\\n        Where-Object { $_.Count -gt 1 }\\n\\n    foreach ($g in $dupeGroups) {\\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\\n\\n        $severity =\\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\\n            else { \u0027Info\u0027 }\\n\\n        $entries = $g.Group |\\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\\n            ForEach-Object {\\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\\n                \\\"{0} ({1})\\\" -f $_.Hostname, $d\\n            }\\n\\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\\\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\\\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\\n    }\\n\\n    # 2) Low RAM (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\\\"RAM_GB={0} (min {1})\\\" -f $pc.RAM_GB, $MinRam)\\n        } elseif ($null -eq $pc.RAM_GB) {\\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\\n        }\\n    }\\n\\n    # 3) Stale assets (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($pc.ScanDateParsed) {\\n            $ageDays = ($today - $pc.ScanDateParsed).Days\\n            if ($ageDays -gt $StaleDaysThreshold) {\\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\\\"Last seen {0} days ago (threshold {1})\\\" -f $ageDays, $StaleDaysThreshold)\\n            }\\n        }\\n    }\\n\\n    # 4) Missing monitor serials (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\\n        }\\n    }\\n\\n    # --- Build text report ---\\n    $generated = Get-Date\\n    $line = (\u0027=\u0027 * 70)\\n\\n    $txt = New-Object System.Collections.Generic.List[string]\\n    $txt.Add($line)\\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\\n    $txt.Add(\\\"Generated: $generated\\\")\\n    $txt.Add(\\\"Input:     $InputPath\\\")\\n    $txt.Add((\\\"Assets:    {0} (latest per asset)\\\" -f $latestByAsset.Count))\\n    $txt.Add((\\\"Rows:      {0} (raw rows in CSV)\\\" -f $data.Count))\\n    $txt.Add((\\\"Settings:  MinRamGB={0}, StaleDays={1}\\\" -f $MinRam, $StaleDaysThreshold))\\n    $txt.Add($line)\\n    $txt.Add(\u0027\u0027)\\n\\n    if ($issues.Count -eq 0) {\\n        $txt.Add(\u0027No issues found.\u0027)\\n    } else {\\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\\n        foreach ($t in $byType) {\\n            $txt.Add((\\\"--- {0} ({1}) ---\\\" -f $t.Name, $t.Count))\\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\\n\\n                $txt.Add((\\\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\\\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\\n            }\\n            $txt.Add(\u0027\u0027)\\n        }\\n    }\\n\\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\\n\\n    if (-not $SkipCsv) {\\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\\n    }\\n\\n    # --- Console summary ---\\n    Write-Host \\\"`n$line\\\" -ForegroundColor Cyan\\n    Write-Host (\\\"Report saved: {0}\\\" -f $ReportFile) -ForegroundColor Green\\n    if (-not $SkipCsv) { Write-Host (\\\"Issues CSV:   {0}\\\" -f $IssuesCsv) -ForegroundColor Green }\\n    Write-Host (\\\"Issues found: {0}\\\" -f $issues.Count) -ForegroundColor Yellow\\n    Write-Host $line -ForegroundColor Cyan\\n\\n    if ($issues.Count -gt 0) {\\n        $sev = $issues | Group-Object Severity | Sort-Object Name\\n        foreach ($s in $sev) {\\n            $c = switch ($s.Name) {\\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\\n                default    { [ConsoleColor]::Gray }\\n            }\\n            Write-Host (\\\"{0}: {1}\\\" -f $s.Name, $s.Count) -ForegroundColor $c\\n        }\\n    }\\n}\\n\\n# ============================================================================\\n# ENTRY POINT\\n# ============================================================================\\n\\nif (-not $AnalyzeOnly) {\\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\\n}\\n\\nif ($Analyze -or $AnalyzeOnly) {\\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv -BaseDir $ScriptDir\\n}\\n\\nif (-not $AnalyzeOnly -and -not $Analyze) {\\n    Write-Host \\\"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\\\" -ForegroundColor DarkGray\\n}\\n\\n\"}"},"checkpointId":"0dede5dc-300d-4df4-b40d-ceeb81a93ba4"},"bubbleId":"42df8c24-eb89-420e-90b4-ef1c3cc7d76b"}
{"data":{"_v":3,"type":1,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"456ed3cb-9301-4c17-8225-a66dc5800df3","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":true,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"a9191b46-22da-4067-a6e4-b4d34407fb70","attachedFoldersListDirResults":[],"humanChanges":[],"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[1,41,7,38,8,9,11,12,15,18,25,27,43,46,47,29,30,32,34,35,39,40,42,44,45,49,51,52],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[{"relativeWorkspacePath":"c:\\Users\\user\\.cursor\\projects\\c-Users-user-Downloads-Cursor-working-directory-misc\\terminals\\3.txt","startLineNumber":1,"lines":[],"languageIdentifier":"","intent":8,"isOnlyIncludedFromFolder":false}],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":5,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:54:59.895Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":["file:///c%3A/Users/user/Downloads/Cursor_working_directory_misc"],"richText":"{\"root\":{\"children\":[{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Here are the refined and improved scripts converted entirely into **PowerShell**. \",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"These versions replace the clunky \\\"Batch/CMD\\\" hybrid with pure PowerShell. This change ensures that commas in hardware names (like \\\"Intel(R) Uhd, 620\\\") do not break your CSV columns, and it handles the complex Monitor Serial decoding much more reliably.\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"### Script 1: Data Collection (`Collect-Inventory.ps1`)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"**Instructions:** Save this code as `Collect-Inventory.ps1`. Right-click the file and select **Run with PowerShell** on the target computer.\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"```powershell\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"\u003c#\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\".SYNOPSIS\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Collects hardware inventory (System, Network, GPU, Storage, Monitors)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    and appends it to a Master CSV file.\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\".DESCRIPTION\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Run this script as Administrator to ensure Monitor EDID data (Registry)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    can be read. It outputs to \u0027PC_Inventory_Master.csv\u0027 in the same folder.\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"#\u003e\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$ErrorActionPreference = \\\"SilentlyContinue\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$OutputFile = Join-Path -Path $PSScriptRoot -ChildPath \\\"PC_Inventory_Master.csv\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# --- FUNCTION: DECODE MONITOR SERIALS FROM EDID ---\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"function Get-MonitorSerials {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $Monitors = @()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    # The registry path where Windows stores Monitor EDID data\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $Root = \u0027HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Enum\\\\DISPLAY\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    \",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if (Test-Path $Root) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Get-ChildItem -Path $Root | ForEach-Object {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            Get-ChildItem -Path $_.PSPath | ForEach-Object {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $Params = Join-Path $_.PSPath \\\"Device Parameters\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                if (Test-Path $Params) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                    $EDID = (Get-ItemProperty -Path $Params).EDID\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                    if ($EDID) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                        # Convert byte array to hex string\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                        $Hex = ($EDID | ForEach-Object { \u0027{0:X2}\u0027 -f $_ }) -join \u0027\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                        \",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                        # The Serial Number Descriptor Block typically starts at offset 108 (0x6C)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                        # We try to read 13 bytes (26 hex characters) from there.\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                        try {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                            if ($Hex.Length -ge 134) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                                $SerialHex = $Hex.Substring(108, 26)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                                $String = \\\"\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                                for ($i=0; $i -lt $SerialHex.Length; $i+=2) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                                    $Val = [convert]::ToInt32($SerialHex.Substring($i, 2), 16)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                                    # Only accept printable ASCII characters (Alphanumeric + dashes)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                                    if ($Val -ge 32 -and $Val -le 126) { \",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                                        $String += [char]$Val \",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                                    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                                }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                                # Cleanup result\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                                $Result = $String.Trim()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                                if ($Result -match \u0027[A-Z0-9]\u0027) { $Monitors += $Result }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                            }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                        } catch {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                            # Silently fail if EDID structure is non-standard\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($Monitors.Count -eq 0) { return \\\"None Detected/Generic\\\" }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    return ($Monitors -join \u0027 | \u0027)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# --- MAIN EXECUTION ---\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Write-Host \\\"`n========================================================\\\" -ForegroundColor Cyan\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Write-Host \\\"   GATHERING HARDWARE SPECS... PLEASE WAIT\\\" -ForegroundColor Cyan\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Write-Host \\\"========================================================\\\" -ForegroundColor Cyan\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 1. System \u0026 CPU\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Sys  = Get-CimInstance Win32_ComputerSystem\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Bios = Get-CimInstance Win32_BIOS\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Cpu  = Get-CimInstance Win32_Processor\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 2. RAM (Convert Bytes to GB)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$RamGB = [math]::Round($Sys.TotalPhysicalMemory / 1GB, 0)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 3. Network (Physical Adapters Only to avoid VPN/Virtual clutter)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$NetList = Get-CimInstance Win32_NetworkAdapter | Where-Object { $_.PhysicalAdapter -eq $true }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$NetStr  = ($NetList | ForEach-Object { \\\"$($_.Name) [$($_.MACAddress)]\\\" }) -join \u0027 | \u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 4. GPU (Video Controllers)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# Note: True \\\"Sticker\\\" serials are rarely in firmware. We capture Name + PNP ID for unique identification.\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$GpuList = Get-CimInstance Win32_VideoController\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$GpuStr  = ($GpuList | ForEach-Object { \\\"$($_.Name) [PNP:$($_.PNPDeviceID)]\\\" }) -join \u0027 | \u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 5. Storage (Physical Disks)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$DiskList = Get-CimInstance Win32_DiskDrive\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$DiskStr  = ($DiskList | ForEach-Object { \\\"$($_.Model) (SN:$($_.SerialNumber.Trim()))\\\" }) -join \u0027 | \u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 6. Monitors (EDID Decode)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$MonStr = Get-MonitorSerials\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 7. Construct Object\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$InventoryData = [PSCustomObject]@{\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Hostname         = $Sys.DNSHostName\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    User             = $env:USERNAME\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Make_Model       = \\\"$($Sys.Manufacturer) $($Sys.Model)\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    System_Serial    = $Bios.SerialNumber\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    CPU              = $Cpu.Name\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    RAM_GB           = $RamGB\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Network_Adapters = $NetStr\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    GPUs             = $GpuStr\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Disk_Serials     = $DiskStr\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Monitor_Serials  = $MonStr\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Scan_Date        = Get-Date -Format \\\"yyyy-MM-dd\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 8. Export to CSV\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# -Append allows adding new rows to existing file\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# -NoTypeInformation removes the weird #TYPE line at the top\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$InventoryData | Export-Csv -Path $OutputFile -Append -NoTypeInformation -Force\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Write-Host \\\"`nSUCCESS!\\\" -ForegroundColor Green\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Write-Host \\\"Data saved to: $OutputFile\\\" -ForegroundColor Gray\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Start-Sleep -Seconds 2\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"```\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"***\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"### Script 2: Analysis \u0026 Maintenance (`Analyze-Inventory.ps1`)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"**Instructions:** Save this code as `Analyze-Inventory.ps1`. Run this whenever you want to check your master list for old data, duplicates, or hardware that needs upgrading.\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"```powershell\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"\u003c#\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\".SYNOPSIS\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Audits the PC_Inventory_Master.csv file.\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\".DESCRIPTION\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Checks for:\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    1. Duplicate System Serial Numbers (Double scans)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    2. Stale Assets (Not scanned in X days)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    3. Low RAM (Below 8GB)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    4. Missing Monitor Data\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"#\u003e\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$InputFile  = Join-Path -Path $PSScriptRoot -ChildPath \\\"PC_Inventory_Master.csv\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$ReportFile = Join-Path -Path $PSScriptRoot -ChildPath \\\"Inventory_Health_Report.txt\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# --- SETTINGS ---\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$StaleThresholdDays = 90\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$MinRamGB = 8\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"if (-not (Test-Path $InputFile)) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Write-Warning \\\"File \u0027$InputFile\u0027 not found. Run the collection script first.\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    exit\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Data = Import-Csv $InputFile\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Today = Get-Date\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Report = @()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Report += \\\"====================================================\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Report += \\\"        IT INVENTORY HEALTH REPORT                  \\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Report += \\\"        Date Generated: $($Today.ToString(\u0027yyyy-MM-dd\u0027))\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Report += \\\"        Total Assets in File: $($Data.Count)\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Report += \\\"====================================================`n\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 1. CHECK DUPLICATES (Logic: Group by Serial, count \u003e 1)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Duplicates = $Data | Group-Object System_Serial | Where-Object { $_.Count -gt 1 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Report += \\\"--- [1] DUPLICATE SERIAL NUMBERS (Potential Double Entry) ---\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"if ($Duplicates) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    foreach ($Group in $Duplicates) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        # Filter out empty serials just in case\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        if (-not [string]::IsNullOrWhiteSpace($Group.Name)) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $Report += \\\"WARNING: Serial \u0027$($Group.Name)\u0027 appears $($Group.Count) times.\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $Report += \\\"    \u003e Affects Hostnames: $(($Group.Group.Hostname) -join \u0027, \u0027)\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"} else { $Report += \\\"OK: No duplicate hardware detected.\\\" }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Report += \\\"\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 2. CHECK STALE ASSETS (Old Scan Date)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Report += \\\"--- [2] STALE ASSETS (Not scanned in $StaleThresholdDays days) ---\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$StaleCount = 0\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"foreach ($Row in $Data) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    try {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        if (-not [string]::IsNullOrWhiteSpace($Row.Scan_Date)) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $ScanDate = [datetime]::ParseExact($Row.Scan_Date, \\\"yyyy-MM-dd\\\", $null)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $Age = ($Today - $ScanDate).Days\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            \",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($Age -gt $StaleThresholdDays) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $Report += \\\"STALE: \u0027$($Row.Hostname)\u0027 last scanned $Age days ago ($($Row.Scan_Date)).\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $StaleCount++\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    } catch {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        # Skip rows with corrupt dates\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"if ($StaleCount -eq 0) { $Report += \\\"OK: All assets have been scanned recently.\\\" }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Report += \\\"\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 3. CHECK SPECS (Low RAM)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Report += \\\"--- [3] LOW SPEC WARNING (Below ${MinRamGB}GB RAM) ---\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$LowSpec = $Data | Where-Object { [int]$_.RAM_GB -lt $MinRamGB }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"if ($LowSpec) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    foreach ($PC in $LowSpec) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $Report += \\\"UPGRADE NEEDED: \u0027$($PC.Hostname)\u0027 has only $($PC.RAM_GB) GB RAM.\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"} else { $Report += \\\"OK: All systems meet the ${MinRamGB}GB RAM requirement.\\\" }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Report += \\\"\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 4. CHECK MONITORS (Missing Info)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Report += \\\"--- [4] MONITOR DATA CHECK ---\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$NoMon = $Data | Where-Object { \",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    [string]::IsNullOrWhiteSpace($_.Monitor_Serials) -or \",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $_.Monitor_Serials -match \\\"None Detected\\\" \",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"if ($NoMon) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    foreach ($PC in $NoMon) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $Report += \\\"CHECK: \u0027$($PC.Hostname)\u0027 has no external monitor serials detected.\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"} else { $Report += \\\"OK: All systems have monitor data recorded.\\\" }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# --- OUTPUT TO FILE AND CONSOLE ---\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$Report | Out-File $ReportFile -Encoding UTF8\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Write-Host ($Report -join \\\"`n\\\") -ForegroundColor Cyan\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Write-Host \\\"`nReport saved to: $ReportFile\\\" -ForegroundColor Green\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"```\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"```powershell\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"#requires -Version 5.1\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"\u003c#\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Collect-Inventory.ps1\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Collects PC inventory into PC_Inventory_Master.csv in the same folder as the script.\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Improvements vs prior version:\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"- Robust CSV append (adds headers if file missing/empty)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"- Better error handling (records errors instead of hiding them)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"- Monitor serials via WmiMonitorID (preferred), with EDID-registry fallback\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"- Richer network details (MAC + IPv4 + gateway when available)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"- Disk serial collection with safer null handling\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"- Optional NVIDIA GPU serial capture via nvidia-smi when present\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"- Optional PCIe device enumeration (can be large)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"#\u003e\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"[CmdletBinding()]\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"param(\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    [string]$OutputFile = (Join-Path -Path $PSScriptRoot -ChildPath \u0027PC_Inventory_Master.csv\u0027),\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    [switch]$IncludePciDevices\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\")\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Set-StrictMode -Version Latest\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$ErrorActionPreference = \u0027Stop\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"function Clean-Cell {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    param([AllowNull()][string]$Text)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($null -eq $Text) { return \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    # Remove newlines/tabs that can make CSV look messy in Excel\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    return ($Text -replace \\\"(`r`n|`n|`r|`t)+\\\", \u0027 \u0027).Trim()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"function Convert-UShortArrayToString {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    param([AllowNull()]$Arr)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($null -eq $Arr) { return \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    # WmiMonitorID returns ushort[] with trailing zeros\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $chars = foreach ($x in $Arr) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    return ( -join $chars ).Trim()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"function Get-MonitorInventory {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    \u003c#\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"      Preferred: root\\\\wmi:WmiMonitorID (easy, consistent, usually no admin)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"      Fallback: registry EDID decode under HKLM:\\\\SYSTEM\\\\CCS\\\\Enum\\\\DISPLAY (may require admin; can be blocked)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    #\u003e\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $results = New-Object System.Collections.Generic.List[string]\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    # --- Preferred path ---\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    try {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $wmiMons = Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorID -ErrorAction Stop\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        foreach ($m in $wmiMons) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $name = Convert-UShortArrayToString $m.UserFriendlyName\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $sn   = Convert-UShortArrayToString $m.SerialNumberID\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $label = @()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($mfg)  { $label += $mfg }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($name) { $label += $name }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } else { \u0027SN:(none)\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $results.Add(\\\"$displayName ($serialPart)\\\")\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    } catch {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        # ignore here; fallback below\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($results.Count -gt 0) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    # --- Fallback path: registry EDID decode ---\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    function Get-EdidDescriptorString {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        param(\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            [byte[]]$Edid,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        )\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        foreach ($offset in 54,72,90,108) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if (($offset + 18) -gt $Edid.Length) { continue }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            # Descriptor: 00 00 00 {tag} 00 ...\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $bytes = $Edid[($offset+5)..($offset+17)]\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $text = ($text -replace \\\"[`0`n`r]+\\\", \u0027\u0027).Trim()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                if ($text) { return $text }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        return \u0027\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    try {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $root = \u0027HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Enum\\\\DISPLAY\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        if (Test-Path -LiteralPath $root) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                    if (Test-Path -LiteralPath $params) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                        if ($edid -is [byte[]]) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                            # Numeric serial (bytes 12-15 LE) sometimes present; not always the sticker SN.\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                            $num = [BitConverter]::ToUInt32($edid, 12)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                            $numStr = if ($num -ne 0) { \\\"NUM:$num\\\" } else { \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                            $results.Add(\\\"$displayName ($serialPart)\\\")\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    } catch {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        # ignore\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"function Get-NetworkInventory {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $items = New-Object System.Collections.Generic.List[string]\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    # Use NetTCPIP cmdlets when available (better data)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($hasNetAdapter -and $hasNetIpCfg) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        try {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            foreach ($a in $adapters) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $ipv4 = @()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                if ($cfg -and $cfg.IPv4Address) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                    $ipv4 = $cfg.IPv4Address |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                        ForEach-Object { $_.IPAddress } |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $gw = @()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                if ($cfg -and $cfg.IPv4DefaultGateway) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $parts = @()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $parts += (Clean-Cell $a.Name)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                if ($a.MacAddress) { $parts += \\\"MAC:$($a.MacAddress)\\\" }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                if ($ipv4.Count -gt 0) { $parts += (\\\"IPv4:\\\" + ($ipv4 -join \u0027;\u0027)) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $items.Add(($parts -join \u0027 \u0027))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        } catch {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            # fall back below\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    # Fallback: CIM\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    try {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            Where-Object { $_.IPEnabled -eq $true }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        foreach ($n in $net) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $mac  = $n.MACAddress\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $ips  = @()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $gw   = @()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $parts = @()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $parts += (Clean-Cell $name)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($mac) { $parts += \\\"MAC:$mac\\\" }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($ips.Count -gt 0) { $parts += (\\\"IP:\\\" + ($ips -join \u0027;\u0027)) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $items.Add(($parts -join \u0027 \u0027))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    } catch {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        # ignore\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($items.Count -eq 0) { return \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"function Get-GpuInventory {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $gpus = New-Object System.Collections.Generic.List[string]\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    # CIM GPUs\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    try {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        foreach ($g in $vc) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $name = Clean-Cell $g.Name\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $pnp  = Clean-Cell $g.PNPDeviceID\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($name -or $pnp) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $gpus.Add((\\\"{0}{1}\\\" -f $name, $(if ($pnp) { \\\" [ID:$pnp]\\\" } else { \u0027\u0027 })))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    } catch {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        # ignore\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    # Optional NVIDIA serials if nvidia-smi exists\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    try {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        if ($nvsmi) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            foreach ($line in @($raw)) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $t = Clean-Cell $line\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                if ($t) { $gpus.Add(\\\"NVIDIA $t\\\") }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    } catch {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        # ignore\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($gpus.Count -eq 0) { return \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"function Get-DiskInventory {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $disks = New-Object System.Collections.Generic.List[string]\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    # Prefer Storage module when available\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($hasPhysicalDisk) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        try {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $name = Clean-Cell $d.FriendlyName\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $sn   = Clean-Cell $d.SerialNumber\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $mt   = Clean-Cell ([string]$d.MediaType)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $parts = @()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                if ($name) { $parts += $name }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                if ($sn)   { $parts += \\\"SN:$sn\\\" }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                if ($mt)   { $parts += \\\"Type:$mt\\\" }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        } catch {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            # fall back below\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    # Fallback: CIM\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    try {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $model = Clean-Cell $d.Model\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $sn = \u0027\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $devId = Clean-Cell $d.DeviceID\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $parts = @()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($model) { $parts += $model }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($sn)    { $parts += \\\"SN:$sn\\\" }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($devId) { $parts += \\\"Dev:$devId\\\" }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    } catch {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        # ignore\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($disks.Count -eq 0) { return \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"function Get-PciDeviceInventory {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $items = New-Object System.Collections.Generic.List[string]\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($hasGetPnpDevice) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        try {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                Where-Object { $_.InstanceId -like \u0027PCI\\\\*\u0027 } |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                Sort-Object -Property Class, FriendlyName, Name\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            foreach ($d in $devs) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $name = Clean-Cell $name\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $cls  = Clean-Cell $d.Class\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $id   = Clean-Cell $d.InstanceId\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                if ($name -or $id) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                    $items.Add((\\\"{0}{1}{2}\\\" -f $name, $(if ($cls) { \\\" [Class:$cls]\\\" } else { \u0027\u0027 }), $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        } catch {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            # fall back below\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    # Fallback: CIM Win32_PnPEntity (can be slower)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    try {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            Where-Object { $_.PNPDeviceID -like \u0027PCI\\\\*\u0027 } |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            Sort-Object -Property Name\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        foreach ($d in $devs) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $name = Clean-Cell $d.Name\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $id   = Clean-Cell $d.PNPDeviceID\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($name -or $id) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                $items.Add((\\\"{0}{1}\\\" -f $name, $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    } catch {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        # ignore\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($items.Count -eq 0) { return \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$errors = New-Object System.Collections.Generic.List[string]\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# --- Collect core system info ---\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$sys  = $null\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$bios = $null\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$cpu  = $null\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$os   = $null\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$bb   = $null\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_ComputerSystem: $($_.Exception.Message)\\\") }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\\\"Win32_BIOS: $($_.Exception.Message)\\\") }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_Processor: $($_.Exception.Message)\\\") }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_OperatingSystem: $($_.Exception.Message)\\\") }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_BaseBoard: $($_.Exception.Message)\\\") }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# --- Derived values ---\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$ramGB = $null\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"try {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($sys -and $sys.TotalPhysicalMemory) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"} catch {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $errors.Add(\\\"RAM calc: $($_.Exception.Message)\\\")\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# --- Other sections ---\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$netStr  = \u0027\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$gpuStr  = \u0027\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$diskStr = \u0027\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$monStr  = \u0027\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$pciStr  = \u0027\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\\\"Network: $($_.Exception.Message)\\\") }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\\\"GPU: $($_.Exception.Message)\\\") }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"try { $diskStr = Get-DiskInventory } catch { $errors.Add(\\\"Disks: $($_.Exception.Message)\\\") }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\\\"Monitors: $($_.Exception.Message)\\\") }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"if ($IncludePciDevices) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\\\"PCI devices: $($_.Exception.Message)\\\") }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# --- Build record ---\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$record = [pscustomobject]@{\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Hostname          = Clean-Cell $hostname\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    User              = Clean-Cell $env:USERNAME\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Make_Model        = Clean-Cell ((\\\"{0} {1}\\\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    System_Serial     = Clean-Cell ($bios.SerialNumber)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Baseboard_Product = Clean-Cell ($bb.Product)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    BIOS_ReleaseDate  = Clean-Cell (try { ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027) } catch { \u0027\u0027 })\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    OS_Caption        = Clean-Cell ($os.Caption)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    OS_Version        = Clean-Cell ($os.Version)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    CPU               = Clean-Cell ($cpu.Name)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    RAM_GB            = $ramGB\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Network_Adapters  = Clean-Cell $netStr\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    GPUs              = Clean-Cell $gpuStr\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Disk_Serials      = Clean-Cell $diskStr\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Monitor_Serials   = Clean-Cell $monStr\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    PCI_Devices       = Clean-Cell $pciStr\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Collector_Version = \u00272.0\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# --- CSV append with header safety ---\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$needHeader = $true\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"if (Test-Path -LiteralPath $OutputFile) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    try {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $fi = Get-Item -LiteralPath $OutputFile -ErrorAction Stop\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        if ($fi.Length -gt 0) { $needHeader = $false }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    } catch { $needHeader = $true }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"if ($needHeader) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $record | Export-Csv -LiteralPath $OutputFile -NoTypeInformation -Encoding UTF8 -Force\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"} else {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $record | Export-Csv -LiteralPath $OutputFile -NoTypeInformation -Encoding UTF8 -Append\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Write-Host (\\\"Success! Data written to: {0}\\\" -f $OutputFile) -ForegroundColor Green\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"if ($record.Errors) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Write-Host (\\\"Warnings captured in Errors column: {0}\\\" -f $record.Errors) -ForegroundColor Yellow\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"```\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"```powershell\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"#requires -Version 5.1\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"\u003c#\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Analyze-Inventory.ps1\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Audits PC_Inventory_Master.csv and outputs:\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"- Inventory_Issues_Report.txt (human-readable)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"- Inventory_Issues_Report.csv (sortable in Excel)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Improvements vs prior versions:\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"- PowerShell 5.1 compatible (no ?? operator)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"- Works even if columns were renamed (header mapping)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"- Uses \\\"latest record per asset\\\" for staleness/low-RAM/monitor checks\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"- Duplicate serials are graded: Info if same hostname; Warning if multiple hostnames/users\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"- Treats \\\"None Detected/Generic\\\" as missing monitor data\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"#\u003e\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"[CmdletBinding()]\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"param(\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    [string]$InputFile = \\\"PC_Inventory_Master.csv\\\",\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    [string]$ReportFile = \\\"Inventory_Issues_Report.txt\\\",\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    [string]$IssuesCsv = \\\"Inventory_Issues_Report.csv\\\",\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    [int]$StaleDays = 90,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    [int]$MinRamGB = 8,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    [switch]$NoCsv,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    [switch]$NoConsoleColor\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\")\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Set-StrictMode -Version Latest\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$ErrorActionPreference = \u0027Stop\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"function Write-Info {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    param(\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        [Parameter(Mandatory)][string]$Message,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        [ConsoleColor]$Color = [ConsoleColor]::Cyan\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    )\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($NoConsoleColor) { Write-Host $Message }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    else { Write-Host $Message -ForegroundColor $Color }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"function Get-ColumnMap {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    param([string[]]$Headers)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $map = @{\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Hostname        = \u0027Hostname\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        User            = \u0027User\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        System_Serial   = \u0027System_Serial\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        RAM_GB          = \u0027RAM_GB\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Monitor_Serials = \u0027Monitor_Serials\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Scan_Date       = \u0027Scan_Date\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    foreach ($k in @($map.Keys)) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        if ($Headers -notcontains $map[$k]) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $alts = switch ($k) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"                default           { @() }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            if ($found) { $map[$k] = $found }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    return $map\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"function Parse-ScanDate {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    param([AllowNull()][string]$Value)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $s = $Value.Trim()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $dt = $null\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    # Prefer yyyy-MM-dd or yyyy-MM-dd HH:mm:ss\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    # Fallback parse\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    return $null\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"function Normalize-Serial {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    param([AllowNull()][string]$Serial)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $s = ($Serial.Trim())\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $bad = @(\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        \u0027To Be Filled By O.E.M.\u0027,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        \u0027To Be Filled By OEM\u0027,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        \u0027Default string\u0027,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        \u0027System Serial Number\u0027,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        \u0027None\u0027,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        \u0027N/A\u0027,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        \u0027NA\u0027,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        \u00270\u0027,\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        \u002700000000\u0027,\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        \u00270000000000\u0027,\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        \u00270000000000000000\u0027\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    )\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($bad -contains $s) { return \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    return $s.ToUpperInvariant()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"function Parse-RamGB {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    param([AllowNull()][string]$Value)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $s = $Value.Trim()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $m = [regex]::Match($s, \u0027(\\\\d+)(\\\\.\\\\d+)?\u0027)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if (-not $m.Success) { return $null }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $n = $null\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        return [int][math]::Round($n, 0)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    return $null\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"function Is-MonitorMissing {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    param([AllowNull()][string]$Value)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $t = $Value.Trim()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"if (-not (Test-Path -LiteralPath $InputFile)) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    throw \\\"Input file not found: $InputFile\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$raw = Import-Csv -LiteralPath $InputFile\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"if (-not $raw -or $raw.Count -eq 0) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    throw \\\"Input file contains no rows: $InputFile\\\"\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$headers = @()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$col = Get-ColumnMap -Headers $headers\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$today = Get-Date\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# Normalize data and add helper properties\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$data = foreach ($r in $raw) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $serialN = Normalize-Serial $serial\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $scanDt  = Parse-ScanDate $scan\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $ramGb   = Parse-RamGB $ram\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    # Asset key: prefer System Serial, fallback to Hostname\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $assetKey = \u0027\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if (-not [string]::IsNullOrWhiteSpace($serialN)) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $assetKey = $serialN\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $assetKey = $h.Trim().ToUpperInvariant()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    [pscustomobject]@{\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Hostname        = $h.Trim()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        User            = $u.Trim()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        System_Serial   = $serialN\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        RAM_GB          = $ramGb\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Monitor_Serials = $m.Trim()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Scan_Date       = $s.Trim()\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        ScanDateParsed  = $scanDt\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        AssetKey        = $assetKey\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        RawRow          = $r\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# Latest record per asset\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$latestByAsset = $data |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Group-Object -Property AssetKey |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    ForEach-Object { $_.Group | Select-Object -First 1 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$issues = New-Object System.Collections.Generic.List[object]\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"function Add-Issue {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    param(\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        [Parameter(Mandatory)][string]$IssueType,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        [string]$AssetKey,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        [string]$Hostname,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        [string]$User,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        [string]$SystemSerial,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        [string]$ScanDate,\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        [string]$Details\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    )\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $issues.Add([pscustomobject]@{\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        IssueType     = $IssueType\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Severity      = $Severity\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        AssetKey      = $AssetKey\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Hostname      = $Hostname\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        User          = $User\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        System_Serial = $SystemSerial\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Scan_Date     = $ScanDate\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Details       = $Details\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    })\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 0) Data quality (latest records)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"foreach ($pc in $latestByAsset) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if (-not $pc.ScanDateParsed) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 1) Duplicate serials (all rows; ignore blanks)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$dupeGroups = $data |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Group-Object -Property System_Serial |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Where-Object { $_.Count -gt 1 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"foreach ($g in $dupeGroups) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $severity =\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        else { \u0027Info\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $entries = $g.Group |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        ForEach-Object {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            \\\"{0} ({1})\\\" -f $_.Hostname, $d\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\\\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\\\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 2) Low RAM (latest records)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"foreach ($pc in $latestByAsset) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRamGB) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\\\"RAM_GB={0} (min {1})\\\" -f $pc.RAM_GB, $MinRamGB)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    } elseif ($null -eq $pc.RAM_GB) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 3) Stale assets (latest records)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"foreach ($pc in $latestByAsset) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if ($pc.ScanDateParsed) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $ageDays = ($today - $pc.ScanDateParsed).Days\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        if ($ageDays -gt $StaleDays) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\\\"Last seen {0} days ago (threshold {1})\\\" -f $ageDays, $StaleDays)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# 4) Missing monitor serials (latest records)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"foreach ($pc in $latestByAsset) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    if (Is-MonitorMissing $pc.Monitor_Serials) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# --- Build text report ---\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$generated = Get-Date\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$line = (\u0027=\u0027 * 70)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$txt = New-Object System.Collections.Generic.List[string]\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$txt.Add($line)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$txt.Add(\\\"Generated: $generated\\\")\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$txt.Add(\\\"Input:     $InputFile\\\")\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$txt.Add((\\\"Assets:    {0} (latest per asset)\\\" -f $latestByAsset.Count))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$txt.Add((\\\"Rows:      {0} (raw rows in CSV)\\\" -f $data.Count))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$txt.Add((\\\"Settings:  MinRamGB={0}, StaleDays={1}\\\" -f $MinRamGB, $StaleDays))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$txt.Add($line)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$txt.Add(\u0027\u0027)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"if ($issues.Count -eq 0) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $txt.Add(\u0027No issues found.\u0027)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"} else {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $byType = $issues | Group-Object IssueType | Sort-Object Name\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    foreach ($t in $byType) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $txt.Add((\\\"--- {0} ({1}) ---\\\" -f $t.Name, $t.Count))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $host  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $scan  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            $txt.Add((\\\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\\\" -f $i.Severity, $asset, $host, $usr, $ser, $scan, $i.Details))\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $txt.Add(\u0027\u0027)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"$txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"if (-not $NoCsv) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"# --- Console summary ---\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Write-Info $line\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Write-Info (\\\"Report saved: {0}\\\" -f $ReportFile) ([ConsoleColor]::Green)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"if (-not $NoCsv) { Write-Info (\\\"Issues CSV:   {0}\\\" -f $IssuesCsv) ([ConsoleColor]::Green) }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Write-Info (\\\"Issues found: {0}\\\" -f $issues.Count) ([ConsoleColor]::Yellow)\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Write-Info $line\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"if ($issues.Count -gt 0) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    $sev = $issues | Group-Object Severity | Sort-Object Name\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    foreach ($s in $sev) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        $c = switch ($s.Name) {\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            \u0027Critical\u0027 { [ConsoleColor]::Red }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            \u0027Warning\u0027  { [ConsoleColor]::Yellow }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"            default    { [ConsoleColor]::Gray }\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"        Write-Info (\\\"{0}: {1}\\\" -f $s.Name, $s.Count) $c\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"    }\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"}\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"```\",\"type\":\"text\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1},{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"synthesize the above into a single script which can be run from a usb to inventory the PC it is running on\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"root\",\"version\":1}}","text":"Here are the refined and improved scripts converted entirely into **PowerShell**. \n\nThese versions replace the clunky \"Batch/CMD\" hybrid with pure PowerShell. This change ensures that commas in hardware names (like \"Intel(R) Uhd, 620\") do not break your CSV columns, and it handles the complex Monitor Serial decoding much more reliably.\n\n### Script 1: Data Collection (`Collect-Inventory.ps1`)\n**Instructions:** Save this code as `Collect-Inventory.ps1`. Right-click the file and select **Run with PowerShell** on the target computer.\n\n```powershell\n\u003c#\n.SYNOPSIS\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors)\n    and appends it to a Master CSV file.\n.DESCRIPTION\n    Run this script as Administrator to ensure Monitor EDID data (Registry)\n    can be read. It outputs to \u0027PC_Inventory_Master.csv\u0027 in the same folder.\n#\u003e\n\n$ErrorActionPreference = \"SilentlyContinue\"\n$OutputFile = Join-Path -Path $PSScriptRoot -ChildPath \"PC_Inventory_Master.csv\"\n\n# --- FUNCTION: DECODE MONITOR SERIALS FROM EDID ---\nfunction Get-MonitorSerials {\n    $Monitors = @()\n    # The registry path where Windows stores Monitor EDID data\n    $Root = \u0027HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\DISPLAY\u0027\n    \n    if (Test-Path $Root) {\n        Get-ChildItem -Path $Root | ForEach-Object {\n            Get-ChildItem -Path $_.PSPath | ForEach-Object {\n                $Params = Join-Path $_.PSPath \"Device Parameters\"\n                if (Test-Path $Params) {\n                    $EDID = (Get-ItemProperty -Path $Params).EDID\n                    if ($EDID) {\n                        # Convert byte array to hex string\n                        $Hex = ($EDID | ForEach-Object { \u0027{0:X2}\u0027 -f $_ }) -join \u0027\u0027\n                        \n                        # The Serial Number Descriptor Block typically starts at offset 108 (0x6C)\n                        # We try to read 13 bytes (26 hex characters) from there.\n                        try {\n                            if ($Hex.Length -ge 134) {\n                                $SerialHex = $Hex.Substring(108, 26)\n                                $String = \"\"\n                                for ($i=0; $i -lt $SerialHex.Length; $i+=2) {\n                                    $Val = [convert]::ToInt32($SerialHex.Substring($i, 2), 16)\n                                    # Only accept printable ASCII characters (Alphanumeric + dashes)\n                                    if ($Val -ge 32 -and $Val -le 126) { \n                                        $String += [char]$Val \n                                    }\n                                }\n                                # Cleanup result\n                                $Result = $String.Trim()\n                                if ($Result -match \u0027[A-Z0-9]\u0027) { $Monitors += $Result }\n                            }\n                        } catch {\n                            # Silently fail if EDID structure is non-standard\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if ($Monitors.Count -eq 0) { return \"None Detected/Generic\" }\n    return ($Monitors -join \u0027 | \u0027)\n}\n\n# --- MAIN EXECUTION ---\nWrite-Host \"`n========================================================\" -ForegroundColor Cyan\nWrite-Host \"   GATHERING HARDWARE SPECS... PLEASE WAIT\" -ForegroundColor Cyan\nWrite-Host \"========================================================\" -ForegroundColor Cyan\n\n# 1. System \u0026 CPU\n$Sys  = Get-CimInstance Win32_ComputerSystem\n$Bios = Get-CimInstance Win32_BIOS\n$Cpu  = Get-CimInstance Win32_Processor\n\n# 2. RAM (Convert Bytes to GB)\n$RamGB = [math]::Round($Sys.TotalPhysicalMemory / 1GB, 0)\n\n# 3. Network (Physical Adapters Only to avoid VPN/Virtual clutter)\n$NetList = Get-CimInstance Win32_NetworkAdapter | Where-Object { $_.PhysicalAdapter -eq $true }\n$NetStr  = ($NetList | ForEach-Object { \"$($_.Name) [$($_.MACAddress)]\" }) -join \u0027 | \u0027\n\n# 4. GPU (Video Controllers)\n# Note: True \"Sticker\" serials are rarely in firmware. We capture Name + PNP ID for unique identification.\n$GpuList = Get-CimInstance Win32_VideoController\n$GpuStr  = ($GpuList | ForEach-Object { \"$($_.Name) [PNP:$($_.PNPDeviceID)]\" }) -join \u0027 | \u0027\n\n# 5. Storage (Physical Disks)\n$DiskList = Get-CimInstance Win32_DiskDrive\n$DiskStr  = ($DiskList | ForEach-Object { \"$($_.Model) (SN:$($_.SerialNumber.Trim()))\" }) -join \u0027 | \u0027\n\n# 6. Monitors (EDID Decode)\n$MonStr = Get-MonitorSerials\n\n# 7. Construct Object\n$InventoryData = [PSCustomObject]@{\n    Hostname         = $Sys.DNSHostName\n    User             = $env:USERNAME\n    Make_Model       = \"$($Sys.Manufacturer) $($Sys.Model)\"\n    System_Serial    = $Bios.SerialNumber\n    CPU              = $Cpu.Name\n    RAM_GB           = $RamGB\n    Network_Adapters = $NetStr\n    GPUs             = $GpuStr\n    Disk_Serials     = $DiskStr\n    Monitor_Serials  = $MonStr\n    Scan_Date        = Get-Date -Format \"yyyy-MM-dd\"\n}\n\n# 8. Export to CSV\n# -Append allows adding new rows to existing file\n# -NoTypeInformation removes the weird #TYPE line at the top\n$InventoryData | Export-Csv -Path $OutputFile -Append -NoTypeInformation -Force\n\nWrite-Host \"`nSUCCESS!\" -ForegroundColor Green\nWrite-Host \"Data saved to: $OutputFile\" -ForegroundColor Gray\nStart-Sleep -Seconds 2\n```\n\n***\n\n### Script 2: Analysis \u0026 Maintenance (`Analyze-Inventory.ps1`)\n**Instructions:** Save this code as `Analyze-Inventory.ps1`. Run this whenever you want to check your master list for old data, duplicates, or hardware that needs upgrading.\n\n```powershell\n\u003c#\n.SYNOPSIS\n    Audits the PC_Inventory_Master.csv file.\n.DESCRIPTION\n    Checks for:\n    1. Duplicate System Serial Numbers (Double scans)\n    2. Stale Assets (Not scanned in X days)\n    3. Low RAM (Below 8GB)\n    4. Missing Monitor Data\n#\u003e\n\n$InputFile  = Join-Path -Path $PSScriptRoot -ChildPath \"PC_Inventory_Master.csv\"\n$ReportFile = Join-Path -Path $PSScriptRoot -ChildPath \"Inventory_Health_Report.txt\"\n\n# --- SETTINGS ---\n$StaleThresholdDays = 90\n$MinRamGB = 8\n\nif (-not (Test-Path $InputFile)) {\n    Write-Warning \"File \u0027$InputFile\u0027 not found. Run the collection script first.\"\n    exit\n}\n\n$Data = Import-Csv $InputFile\n$Today = Get-Date\n$Report = @()\n\n$Report += \"====================================================\"\n$Report += \"        IT INVENTORY HEALTH REPORT                  \"\n$Report += \"        Date Generated: $($Today.ToString(\u0027yyyy-MM-dd\u0027))\"\n$Report += \"        Total Assets in File: $($Data.Count)\"\n$Report += \"====================================================`n\"\n\n# 1. CHECK DUPLICATES (Logic: Group by Serial, count \u003e 1)\n$Duplicates = $Data | Group-Object System_Serial | Where-Object { $_.Count -gt 1 }\n$Report += \"--- [1] DUPLICATE SERIAL NUMBERS (Potential Double Entry) ---\"\nif ($Duplicates) {\n    foreach ($Group in $Duplicates) {\n        # Filter out empty serials just in case\n        if (-not [string]::IsNullOrWhiteSpace($Group.Name)) {\n            $Report += \"WARNING: Serial \u0027$($Group.Name)\u0027 appears $($Group.Count) times.\"\n            $Report += \"    \u003e Affects Hostnames: $(($Group.Group.Hostname) -join \u0027, \u0027)\"\n        }\n    }\n} else { $Report += \"OK: No duplicate hardware detected.\" }\n$Report += \"\"\n\n# 2. CHECK STALE ASSETS (Old Scan Date)\n$Report += \"--- [2] STALE ASSETS (Not scanned in $StaleThresholdDays days) ---\"\n$StaleCount = 0\nforeach ($Row in $Data) {\n    try {\n        if (-not [string]::IsNullOrWhiteSpace($Row.Scan_Date)) {\n            $ScanDate = [datetime]::ParseExact($Row.Scan_Date, \"yyyy-MM-dd\", $null)\n            $Age = ($Today - $ScanDate).Days\n            \n            if ($Age -gt $StaleThresholdDays) {\n                $Report += \"STALE: \u0027$($Row.Hostname)\u0027 last scanned $Age days ago ($($Row.Scan_Date)).\"\n                $StaleCount++\n            }\n        }\n    } catch {\n        # Skip rows with corrupt dates\n    }\n}\nif ($StaleCount -eq 0) { $Report += \"OK: All assets have been scanned recently.\" }\n$Report += \"\"\n\n# 3. CHECK SPECS (Low RAM)\n$Report += \"--- [3] LOW SPEC WARNING (Below ${MinRamGB}GB RAM) ---\"\n$LowSpec = $Data | Where-Object { [int]$_.RAM_GB -lt $MinRamGB }\nif ($LowSpec) {\n    foreach ($PC in $LowSpec) {\n        $Report += \"UPGRADE NEEDED: \u0027$($PC.Hostname)\u0027 has only $($PC.RAM_GB) GB RAM.\"\n    }\n} else { $Report += \"OK: All systems meet the ${MinRamGB}GB RAM requirement.\" }\n$Report += \"\"\n\n# 4. CHECK MONITORS (Missing Info)\n$Report += \"--- [4] MONITOR DATA CHECK ---\"\n$NoMon = $Data | Where-Object { \n    [string]::IsNullOrWhiteSpace($_.Monitor_Serials) -or \n    $_.Monitor_Serials -match \"None Detected\" \n}\nif ($NoMon) {\n    foreach ($PC in $NoMon) {\n        $Report += \"CHECK: \u0027$($PC.Hostname)\u0027 has no external monitor serials detected.\"\n    }\n} else { $Report += \"OK: All systems have monitor data recorded.\" }\n\n# --- OUTPUT TO FILE AND CONSOLE ---\n$Report | Out-File $ReportFile -Encoding UTF8\nWrite-Host ($Report -join \"`n\") -ForegroundColor Cyan\n\nWrite-Host \"`nReport saved to: $ReportFile\" -ForegroundColor Green\n```\n\n```powershell\n#requires -Version 5.1\n\u003c#\nCollect-Inventory.ps1\n\nCollects PC inventory into PC_Inventory_Master.csv in the same folder as the script.\n\nImprovements vs prior version:\n- Robust CSV append (adds headers if file missing/empty)\n- Better error handling (records errors instead of hiding them)\n- Monitor serials via WmiMonitorID (preferred), with EDID-registry fallback\n- Richer network details (MAC + IPv4 + gateway when available)\n- Disk serial collection with safer null handling\n- Optional NVIDIA GPU serial capture via nvidia-smi when present\n- Optional PCIe device enumeration (can be large)\n\n#\u003e\n\n[CmdletBinding()]\nparam(\n    [string]$OutputFile = (Join-Path -Path $PSScriptRoot -ChildPath \u0027PC_Inventory_Master.csv\u0027),\n    [switch]$IncludePciDevices\n)\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = \u0027Stop\u0027\n\nfunction Clean-Cell {\n    param([AllowNull()][string]$Text)\n    if ($null -eq $Text) { return \u0027\u0027 }\n    # Remove newlines/tabs that can make CSV look messy in Excel\n    return ($Text -replace \"(`r`n|`n|`r|`t)+\", \u0027 \u0027).Trim()\n}\n\nfunction Convert-UShortArrayToString {\n    param([AllowNull()]$Arr)\n    if ($null -eq $Arr) { return \u0027\u0027 }\n    # WmiMonitorID returns ushort[] with trailing zeros\n    $chars = foreach ($x in $Arr) {\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\n    }\n    return ( -join $chars ).Trim()\n}\n\nfunction Get-MonitorInventory {\n    \u003c#\n      Preferred: root\\wmi:WmiMonitorID (easy, consistent, usually no admin)\n      Fallback: registry EDID decode under HKLM:\\SYSTEM\\CCS\\Enum\\DISPLAY (may require admin; can be blocked)\n    #\u003e\n\n    $results = New-Object System.Collections.Generic.List[string]\n\n    # --- Preferred path ---\n    try {\n        $wmiMons = Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorID -ErrorAction Stop\n        foreach ($m in $wmiMons) {\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\n\n            $label = @()\n            if ($mfg)  { $label += $mfg }\n            if ($name) { $label += $name }\n\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\n            $serialPart  = if ($sn) { \"SN:$sn\" } else { \u0027SN:(none)\u0027 }\n\n            $results.Add(\"$displayName ($serialPart)\")\n        }\n    } catch {\n        # ignore here; fallback below\n    }\n\n    if ($results.Count -gt 0) {\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n    }\n\n    # --- Fallback path: registry EDID decode ---\n    function Get-EdidDescriptorString {\n        param(\n            [byte[]]$Edid,\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\n        )\n\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\n\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\n\n        foreach ($offset in 54,72,90,108) {\n            if (($offset + 18) -gt $Edid.Length) { continue }\n\n            # Descriptor: 00 00 00 {tag} 00 ...\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\n\n                $bytes = $Edid[($offset+5)..($offset+17)]\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\n                $text = ($text -replace \"[`0`n`r]+\", \u0027\u0027).Trim()\n                if ($text) { return $text }\n            }\n        }\n\n        return \u0027\u0027\n    }\n\n    try {\n        $root = \u0027HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\DISPLAY\u0027\n        if (Test-Path -LiteralPath $root) {\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\n                    if (Test-Path -LiteralPath $params) {\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\n                        if ($edid -is [byte[]]) {\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\n\n                            # Numeric serial (bytes 12-15 LE) sometimes present; not always the sticker SN.\n                            $num = [BitConverter]::ToUInt32($edid, 12)\n                            $numStr = if ($num -ne 0) { \"NUM:$num\" } else { \u0027\u0027 }\n\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\n                            $serialPart  = if ($sn) { \"SN:$sn\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\n\n                            $results.Add(\"$displayName ($serialPart)\")\n                        }\n                    }\n                }\n            }\n        }\n    } catch {\n        # ignore\n    }\n\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-NetworkInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    # Use NetTCPIP cmdlets when available (better data)\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\n\n    if ($hasNetAdapter -and $hasNetIpCfg) {\n        try {\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\n            foreach ($a in $adapters) {\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\n                $ipv4 = @()\n                if ($cfg -and $cfg.IPv4Address) {\n                    $ipv4 = $cfg.IPv4Address |\n                        ForEach-Object { $_.IPAddress } |\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\n                }\n                $gw = @()\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\n                }\n\n                $parts = @()\n                $parts += (Clean-Cell $a.Name)\n                if ($a.MacAddress) { $parts += \"MAC:$($a.MacAddress)\" }\n                if ($ipv4.Count -gt 0) { $parts += (\"IPv4:\" + ($ipv4 -join \u0027;\u0027)) }\n                if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n                $items.Add(($parts -join \u0027 \u0027))\n            }\n        } catch {\n            # fall back below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\n            Where-Object { $_.IPEnabled -eq $true }\n\n        foreach ($n in $net) {\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\n            $mac  = $n.MACAddress\n            $ips  = @()\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\n            $gw   = @()\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\n\n            $parts = @()\n            $parts += (Clean-Cell $name)\n            if ($mac) { $parts += \"MAC:$mac\" }\n            if ($ips.Count -gt 0) { $parts += (\"IP:\" + ($ips -join \u0027;\u0027)) }\n            if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n            $items.Add(($parts -join \u0027 \u0027))\n        }\n    } catch {\n        # ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-GpuInventory {\n    $gpus = New-Object System.Collections.Generic.List[string]\n\n    # CIM GPUs\n    try {\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\n        foreach ($g in $vc) {\n            $name = Clean-Cell $g.Name\n            $pnp  = Clean-Cell $g.PNPDeviceID\n            if ($name -or $pnp) {\n                $gpus.Add((\"{0}{1}\" -f $name, $(if ($pnp) { \" [ID:$pnp]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # ignore\n    }\n\n    # Optional NVIDIA serials if nvidia-smi exists\n    try {\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\n        if ($nvsmi) {\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\n            foreach ($line in @($raw)) {\n                $t = Clean-Cell $line\n                if ($t) { $gpus.Add(\"NVIDIA $t\") }\n            }\n        }\n    } catch {\n        # ignore\n    }\n\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-DiskInventory {\n    $disks = New-Object System.Collections.Generic.List[string]\n\n    # Prefer Storage module when available\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\n    if ($hasPhysicalDisk) {\n        try {\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\n                $name = Clean-Cell $d.FriendlyName\n                $sn   = Clean-Cell $d.SerialNumber\n                $mt   = Clean-Cell ([string]$d.MediaType)\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n                $parts = @()\n                if ($name) { $parts += $name }\n                if ($sn)   { $parts += \"SN:$sn\" }\n                if ($mt)   { $parts += \"Type:$mt\" }\n                if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n            }\n        } catch {\n            # fall back below\n        }\n    }\n\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\n            $model = Clean-Cell $d.Model\n            $sn = \u0027\u0027\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\n            $devId = Clean-Cell $d.DeviceID\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n            $parts = @()\n            if ($model) { $parts += $model }\n            if ($sn)    { $parts += \"SN:$sn\" }\n            if ($devId) { $parts += \"Dev:$devId\" }\n            if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n        }\n    } catch {\n        # ignore\n    }\n\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-PciDeviceInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\n    if ($hasGetPnpDevice) {\n        try {\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\n                Where-Object { $_.InstanceId -like \u0027PCI\\*\u0027 } |\n                Sort-Object -Property Class, FriendlyName, Name\n\n            foreach ($d in $devs) {\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\n                $name = Clean-Cell $name\n                $cls  = Clean-Cell $d.Class\n                $id   = Clean-Cell $d.InstanceId\n                if ($name -or $id) {\n                    $items.Add((\"{0}{1}{2}\" -f $name, $(if ($cls) { \" [Class:$cls]\" } else { \u0027\u0027 }), $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n                }\n            }\n        } catch {\n            # fall back below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM Win32_PnPEntity (can be slower)\n    try {\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\*\u0027 } |\n            Sort-Object -Property Name\n\n        foreach ($d in $devs) {\n            $name = Clean-Cell $d.Name\n            $id   = Clean-Cell $d.PNPDeviceID\n            if ($name -or $id) {\n                $items.Add((\"{0}{1}\" -f $name, $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\n$errors = New-Object System.Collections.Generic.List[string]\n\n# --- Collect core system info ---\n$sys  = $null\n$bios = $null\n$cpu  = $null\n$os   = $null\n$bb   = $null\n\ntry { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_ComputerSystem: $($_.Exception.Message)\") }\ntry { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\"Win32_BIOS: $($_.Exception.Message)\") }\ntry { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_Processor: $($_.Exception.Message)\") }\ntry { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_OperatingSystem: $($_.Exception.Message)\") }\ntry { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_BaseBoard: $($_.Exception.Message)\") }\n\n# --- Derived values ---\n$hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\nif ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\n\n$ramGB = $null\ntry {\n    if ($sys -and $sys.TotalPhysicalMemory) {\n        $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\n    }\n} catch {\n    $errors.Add(\"RAM calc: $($_.Exception.Message)\")\n}\n\n# --- Other sections ---\n$netStr  = \u0027\u0027\n$gpuStr  = \u0027\u0027\n$diskStr = \u0027\u0027\n$monStr  = \u0027\u0027\n$pciStr  = \u0027\u0027\n\ntry { $netStr  = Get-NetworkInventory } catch { $errors.Add(\"Network: $($_.Exception.Message)\") }\ntry { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\"GPU: $($_.Exception.Message)\") }\ntry { $diskStr = Get-DiskInventory } catch { $errors.Add(\"Disks: $($_.Exception.Message)\") }\ntry { $monStr  = Get-MonitorInventory } catch { $errors.Add(\"Monitors: $($_.Exception.Message)\") }\n\nif ($IncludePciDevices) {\n    try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\"PCI devices: $($_.Exception.Message)\") }\n}\n\n# --- Build record ---\n$record = [pscustomobject]@{\n    Hostname          = Clean-Cell $hostname\n    User              = Clean-Cell $env:USERNAME\n\n    Make_Model        = Clean-Cell ((\"{0} {1}\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\n    System_Serial     = Clean-Cell ($bios.SerialNumber)\n\n    Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\n    Baseboard_Product = Clean-Cell ($bb.Product)\n    Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\n\n    BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\n    BIOS_ReleaseDate  = Clean-Cell (try { ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027) } catch { \u0027\u0027 })\n\n    OS_Caption        = Clean-Cell ($os.Caption)\n    OS_Version        = Clean-Cell ($os.Version)\n    OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\n\n    CPU               = Clean-Cell ($cpu.Name)\n    RAM_GB            = $ramGB\n\n    Network_Adapters  = Clean-Cell $netStr\n    GPUs              = Clean-Cell $gpuStr\n    Disk_Serials      = Clean-Cell $diskStr\n    Monitor_Serials   = Clean-Cell $monStr\n\n    PCI_Devices       = Clean-Cell $pciStr\n\n    Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\n    Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\n    Collector_Version = \u00272.0\u0027\n    Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\n}\n\n# --- CSV append with header safety ---\n$needHeader = $true\nif (Test-Path -LiteralPath $OutputFile) {\n    try {\n        $fi = Get-Item -LiteralPath $OutputFile -ErrorAction Stop\n        if ($fi.Length -gt 0) { $needHeader = $false }\n    } catch { $needHeader = $true }\n}\n\nif ($needHeader) {\n    $record | Export-Csv -LiteralPath $OutputFile -NoTypeInformation -Encoding UTF8 -Force\n} else {\n    $record | Export-Csv -LiteralPath $OutputFile -NoTypeInformation -Encoding UTF8 -Append\n}\n\nWrite-Host (\"Success! Data written to: {0}\" -f $OutputFile) -ForegroundColor Green\nif ($record.Errors) {\n    Write-Host (\"Warnings captured in Errors column: {0}\" -f $record.Errors) -ForegroundColor Yellow\n}\n```\n\n```powershell\n#requires -Version 5.1\n\u003c#\nAnalyze-Inventory.ps1\n\nAudits PC_Inventory_Master.csv and outputs:\n- Inventory_Issues_Report.txt (human-readable)\n- Inventory_Issues_Report.csv (sortable in Excel)\n\nImprovements vs prior versions:\n- PowerShell 5.1 compatible (no ?? operator)\n- Works even if columns were renamed (header mapping)\n- Uses \"latest record per asset\" for staleness/low-RAM/monitor checks\n- Duplicate serials are graded: Info if same hostname; Warning if multiple hostnames/users\n- Treats \"None Detected/Generic\" as missing monitor data\n#\u003e\n\n[CmdletBinding()]\nparam(\n    [string]$InputFile = \"PC_Inventory_Master.csv\",\n    [string]$ReportFile = \"Inventory_Issues_Report.txt\",\n    [string]$IssuesCsv = \"Inventory_Issues_Report.csv\",\n    [int]$StaleDays = 90,\n    [int]$MinRamGB = 8,\n    [switch]$NoCsv,\n    [switch]$NoConsoleColor\n)\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = \u0027Stop\u0027\n\nfunction Write-Info {\n    param(\n        [Parameter(Mandatory)][string]$Message,\n        [ConsoleColor]$Color = [ConsoleColor]::Cyan\n    )\n    if ($NoConsoleColor) { Write-Host $Message }\n    else { Write-Host $Message -ForegroundColor $Color }\n}\n\nfunction Get-ColumnMap {\n    param([string[]]$Headers)\n\n    $map = @{\n        Hostname        = \u0027Hostname\u0027\n        User            = \u0027User\u0027\n        System_Serial   = \u0027System_Serial\u0027\n        RAM_GB          = \u0027RAM_GB\u0027\n        Monitor_Serials = \u0027Monitor_Serials\u0027\n        Scan_Date       = \u0027Scan_Date\u0027\n    }\n\n    foreach ($k in @($map.Keys)) {\n        if ($Headers -notcontains $map[$k]) {\n            $alts = switch ($k) {\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\n                default           { @() }\n            }\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\n            if ($found) { $map[$k] = $found }\n        }\n    }\n\n    return $map\n}\n\nfunction Parse-ScanDate {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    $dt = $null\n\n    # Prefer yyyy-MM-dd or yyyy-MM-dd HH:mm:ss\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\n\n    # Fallback parse\n    if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\n\n    return $null\n}\n\nfunction Normalize-Serial {\n    param([AllowNull()][string]$Serial)\n\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\n    $s = ($Serial.Trim())\n\n    $bad = @(\n        \u0027To Be Filled By O.E.M.\u0027,\n        \u0027To Be Filled By OEM\u0027,\n        \u0027Default string\u0027,\n        \u0027System Serial Number\u0027,\n        \u0027None\u0027,\n        \u0027N/A\u0027,\n        \u0027NA\u0027,\n        \u00270\u0027,\n        \u002700000000\u0027,\n        \u00270000000000\u0027,\n        \u00270000000000000000\u0027\n    )\n\n    if ($bad -contains $s) { return \u0027\u0027 }\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\n\n    return $s.ToUpperInvariant()\n}\n\nfunction Parse-RamGB {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    $m = [regex]::Match($s, \u0027(\\d+)(\\.\\d+)?\u0027)\n    if (-not $m.Success) { return $null }\n\n    $n = $null\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\n        return [int][math]::Round($n, 0)\n    }\n\n    return $null\n}\n\nfunction Is-MonitorMissing {\n    param([AllowNull()][string]$Value)\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\n    $t = $Value.Trim()\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\n}\n\nif (-not (Test-Path -LiteralPath $InputFile)) {\n    throw \"Input file not found: $InputFile\"\n}\n\n$raw = Import-Csv -LiteralPath $InputFile\nif (-not $raw -or $raw.Count -eq 0) {\n    throw \"Input file contains no rows: $InputFile\"\n}\n\n$headers = @()\ntry { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\n$col = Get-ColumnMap -Headers $headers\n\n$today = Get-Date\n\n# Normalize data and add helper properties\n$data = foreach ($r in $raw) {\n    $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\n    $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\n    $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\n    $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\n    $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\n    $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\n\n    $serialN = Normalize-Serial $serial\n    $scanDt  = Parse-ScanDate $scan\n    $ramGb   = Parse-RamGB $ram\n\n    $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\n    $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\n    $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\n    $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\n\n    # Asset key: prefer System Serial, fallback to Hostname\n    $assetKey = \u0027\u0027\n    if (-not [string]::IsNullOrWhiteSpace($serialN)) {\n        $assetKey = $serialN\n    } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\n        $assetKey = $h.Trim().ToUpperInvariant()\n    }\n\n    [pscustomobject]@{\n        Hostname        = $h.Trim()\n        User            = $u.Trim()\n        System_Serial   = $serialN\n        RAM_GB          = $ramGb\n        Monitor_Serials = $m.Trim()\n        Scan_Date       = $s.Trim()\n\n        ScanDateParsed  = $scanDt\n        AssetKey        = $assetKey\n        RawRow          = $r\n    }\n}\n\n# Latest record per asset\n$latestByAsset = $data |\n    Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\n    Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\n    Group-Object -Property AssetKey |\n    ForEach-Object { $_.Group | Select-Object -First 1 }\n\n$issues = New-Object System.Collections.Generic.List[object]\n\nfunction Add-Issue {\n    param(\n        [Parameter(Mandatory)][string]$IssueType,\n        [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\n        [string]$AssetKey,\n        [string]$Hostname,\n        [string]$User,\n        [string]$SystemSerial,\n        [string]$ScanDate,\n        [string]$Details\n    )\n\n    $issues.Add([pscustomobject]@{\n        IssueType     = $IssueType\n        Severity      = $Severity\n        AssetKey      = $AssetKey\n        Hostname      = $Hostname\n        User          = $User\n        System_Serial = $SystemSerial\n        Scan_Date     = $ScanDate\n        Details       = $Details\n    })\n}\n\n# 0) Data quality (latest records)\nforeach ($pc in $latestByAsset) {\n    if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\n        Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\n    }\n    if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\n        Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\n    }\n    if (-not $pc.ScanDateParsed) {\n        Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\n    }\n}\n\n# 1) Duplicate serials (all rows; ignore blanks)\n$dupeGroups = $data |\n    Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\n    Group-Object -Property System_Serial |\n    Where-Object { $_.Count -gt 1 }\n\nforeach ($g in $dupeGroups) {\n    $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\n    $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\n\n    $severity =\n        if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\n        else { \u0027Info\u0027 }\n\n    $entries = $g.Group |\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\n        ForEach-Object {\n            $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\n            \"{0} ({1})\" -f $_.Hostname, $d\n        }\n\n    Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\n}\n\n# 2) Low RAM (latest records)\nforeach ($pc in $latestByAsset) {\n    if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRamGB) {\n        Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\"RAM_GB={0} (min {1})\" -f $pc.RAM_GB, $MinRamGB)\n    } elseif ($null -eq $pc.RAM_GB) {\n        Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\n    }\n}\n\n# 3) Stale assets (latest records)\nforeach ($pc in $latestByAsset) {\n    if ($pc.ScanDateParsed) {\n        $ageDays = ($today - $pc.ScanDateParsed).Days\n        if ($ageDays -gt $StaleDays) {\n            Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\"Last seen {0} days ago (threshold {1})\" -f $ageDays, $StaleDays)\n        }\n    }\n}\n\n# 4) Missing monitor serials (latest records)\nforeach ($pc in $latestByAsset) {\n    if (Is-MonitorMissing $pc.Monitor_Serials) {\n        Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\n    }\n}\n\n# --- Build text report ---\n$generated = Get-Date\n$line = (\u0027=\u0027 * 70)\n\n$txt = New-Object System.Collections.Generic.List[string]\n$txt.Add($line)\n$txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\n$txt.Add(\"Generated: $generated\")\n$txt.Add(\"Input:     $InputFile\")\n$txt.Add((\"Assets:    {0} (latest per asset)\" -f $latestByAsset.Count))\n$txt.Add((\"Rows:      {0} (raw rows in CSV)\" -f $data.Count))\n$txt.Add((\"Settings:  MinRamGB={0}, StaleDays={1}\" -f $MinRamGB, $StaleDays))\n$txt.Add($line)\n$txt.Add(\u0027\u0027)\n\nif ($issues.Count -eq 0) {\n    $txt.Add(\u0027No issues found.\u0027)\n} else {\n    $byType = $issues | Group-Object IssueType | Sort-Object Name\n    foreach ($t in $byType) {\n        $txt.Add((\"--- {0} ({1}) ---\" -f $t.Name, $t.Count))\n        foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\n            $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\n            $host  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\n            $scan  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\n            $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\n            $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\n\n            $txt.Add((\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\" -f $i.Severity, $asset, $host, $usr, $ser, $scan, $i.Details))\n        }\n        $txt.Add(\u0027\u0027)\n    }\n}\n\n$txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\n\nif (-not $NoCsv) {\n    $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\n        Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\n}\n\n# --- Console summary ---\nWrite-Info $line\nWrite-Info (\"Report saved: {0}\" -f $ReportFile) ([ConsoleColor]::Green)\nif (-not $NoCsv) { Write-Info (\"Issues CSV:   {0}\" -f $IssuesCsv) ([ConsoleColor]::Green) }\nWrite-Info (\"Issues found: {0}\" -f $issues.Count) ([ConsoleColor]::Yellow)\nWrite-Info $line\n\nif ($issues.Count -gt 0) {\n    $sev = $issues | Group-Object Severity | Sort-Object Name\n    foreach ($s in $sev) {\n        $c = switch ($s.Name) {\n            \u0027Critical\u0027 { [ConsoleColor]::Red }\n            \u0027Warning\u0027  { [ConsoleColor]::Yellow }\n            default    { [ConsoleColor]::Gray }\n        }\n        Write-Info (\"{0}: {1}\" -f $s.Name, $s.Count) $c\n    }\n}\n```\n\nsynthesize the above into a single script which can be run from a usb to inventory the PC it is running on","modelInfo":{"modelName":"claude-4.5-opus-high-thinking"},"isNudge":false,"skipRendering":false,"isPlanExecution":false,"editToolSupportsSearchAndReplace":true,"workspaceProjectDir":"c:\\Users\\user\\.cursor\\projects\\c-Users-user-Downloads-Cursor-working-directory-misc","context":{"composers":[],"quotes":[],"selectedCommits":[],"selectedPullRequests":[],"selectedImages":[],"folderSelections":[],"fileSelections":[],"terminalFiles":[],"selections":[],"terminalSelections":[],"selectedDocs":[],"externalLinks":[],"cursorRules":[],"cursorCommands":[],"gitPRDiffSelections":[],"mentions":{"composers":{},"quotes":{},"selectedCommits":{},"selectedPullRequests":{},"gitDiff":[],"gitDiffFromBranchToMain":[],"selectedImages":{},"useWeb":[],"folderSelections":{},"fileSelections":{},"terminalFiles":{},"selections":{},"terminalSelections":{},"selectedDocs":{},"externalLinks":{},"useLinterErrors":[],"useDiffReview":[],"useGenerateRules":[],"useContextPicking":[],"useRememberThis":[],"diffHistory":[],"cursorRules":{},"cursorCommands":{},"autoContext":[],"uiElementSelections":[],"consoleLogs":[],"ideEditorsState":[],"gitPRDiffSelections":{}},"ideEditorsState":true},"checkpointId":"cfa6c8d8-c4a3-4d1f-bf18-9fa014b2b50e","toolFormerData":{"additionalData":{"status":"error"}}},"bubbleId":"456ed3cb-9301-4c17-8225-a66dc5800df3"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"474cb551-d3ca-43a3-ba27-7336b749fd8b","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:59:46.238Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"e73b9a64-9d71-4962-8ea1-0bed7fe99de6","codeBlocks":[],"capabilityType":15,"toolFormerData":{"tool":15,"toolCallId":"toolu_vrtx_01MYxLuSXiSC6iuanNm5Vd4t","toolIndex":1,"modelCallId":"b74496b8-f835-4bd7-8837-69883ef60659","status":"completed","rawArgs":"{\"command\": \"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\"\", \"is_background\": false, \"explanation\": \"Testing the fixed USB-Inventory.ps1 script with proper $ScriptDir fallback.\"}","name":"run_terminal_cmd","params":"{\"command\":\"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\"\",\"requireUserApproval\":true,\"parsingResult\":{\"executableCommands\":[{\"name\":\"powershell\",\"args\":[{\"type\":\"word\",\"value\":\"-ExecutionPolicy\"},{\"type\":\"word\",\"value\":\"Bypass\"},{\"type\":\"word\",\"value\":\"-File\"},{\"type\":\"string\",\"value\":\"\\\".\\\\USB-Inventory.ps1\\\"\"}],\"fullText\":\"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\"\"}]},\"fileOutputThresholdBytes\":\"20000\"}","additionalData":{"status":"success","reviewData":{"status":"Done","selectedOption":"run","isShowingInput":false,"candidatesForAllowlist":["powershell"],"approvalType":"allowlist"},"sessionId":"5dd745c9-3368-496b-b5ac-9b78458b05d4","startAtBufferLine":0,"previousAttempt":"{\"output\":\"\\n========================================================\\n   GATHERING HARDWARE SPECS... PLEASE WAIT\\n========================================================\\nC:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\USB-Inventory.ps1 : The term \u0027try\u0027 is not recognized as the name \\r\\nof a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, \\r\\nverify that the path is correct and try again.\\r\\n    + CategoryInfo          : ObjectNotFound: (try:String) [USB-Inventory.ps1], CommandNotFoundException\\r\\n    + FullyQualifiedErrorId : CommandNotFoundException,USB-Inventory.ps1\\r\\n \\r\\n\",\"rejected\":false,\"notInterrupted\":true,\"endedReason\":\"RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED\",\"exitCodeV2\":1,\"effectiveSandboxPolicy\":{\"type\":\"TYPE_INSECURE_NONE\"}}"},"result":"{\"output\":\"\\n========================================================\\n   GATHERING HARDWARE SPECS... PLEASE WAIT\\n========================================================\\nC:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\USB-Inventory.ps1 : The term \u0027try\u0027 is not recognized as the name \\r\\nof a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, \\r\\nverify that the path is correct and try again.\\r\\n    + CategoryInfo          : ObjectNotFound: (try:String) [USB-Inventory.ps1], CommandNotFoundException\\r\\n    + FullyQualifiedErrorId : CommandNotFoundException,USB-Inventory.ps1\\r\\n \\r\\n\",\"rejected\":false,\"notInterrupted\":true,\"endedReason\":\"RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED\",\"exitCodeV2\":1,\"effectiveSandboxPolicy\":{\"type\":\"TYPE_INSECURE_NONE\"}}"}},"bubbleId":"474cb551-d3ca-43a3-ba27-7336b749fd8b"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"4e788465-4e35-4293-bf2b-6a0f96fe832d","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:55:53.702Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"2fcdacba-1ffa-476a-a6b9-0a8aa82879cb","usageUuid":"aa84bc24-3ac4-4cb9-ad69-5f82484b6ce7","capabilityType":30,"thinking":{"text":"The script has been created. Now let me update the todo and test it.","signature":"Eu4BCkgICxACGAIqQIzNg7uLylj0mWJHi82a+YMdOUK3oz5kx7X7ABDu193KmT0E6sCoIkNaXuuH/LASFy9AqLzRLyrlNUwoy2EtIfESDAuStI0l2EpoUZ3yAhoMpoNK8p/zQZbl+6FEIjC3FYpK3YQwCcf511TbLUiZ3HgIh4b7hIudMZFcg9kDwCXjmWhGQBxT2LA5tCML4mQqVBX57OcsYvh7LKxoz9ub1F0Z21zrJDRWlAlvOmKlT77YN7/eCO99oTpyVECWlp8JjsWgTE4QYPsZQal64QOnUHxwFK0w9S8kXSUA6kqkZ3pkRfX8VxgB"},"thinkingStyle":1,"thinkingDurationMs":1069},"bubbleId":"4e788465-4e35-4293-bf2b-6a0f96fe832d"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"4e8e6511-398e-4d6b-9c5f-31397cdb0cc3","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"8260971b-a940-4daf-be09-b8d59af492b8","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:55:44.215Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":["file:///c%3A/Users/user/Downloads/Cursor_working_directory_misc"],"codeBlocks":[],"text":"","modelInfo":{"modelName":"claude-4.5-opus-high-thinking"},"timingInfo":{"clientStartTime":10160146.899999976,"clientRpcSendTime":1766969744215,"clientSettleTime":1766970144849,"clientEndTime":1766970144849},"workspaceProjectDir":"c:\\Users\\user\\.cursor\\projects\\c-Users-user-Downloads-Cursor-working-directory-misc","serverBubbleId":"b6fb4c3e-c832-4826-b776-01618f02cfa0","usageUuid":"8260971b-a940-4daf-be09-b8d59af492b8","capabilityType":30,"thinking":{"text":"The user wants me to implement the plan for creating USB-Inventory.ps1. Let me start by marking the first todo as in_progress and then create the script.\n\nLooking at the plan:\n1. Create USB-Inventory.ps1 combining collection + analysis logic\n2. Test script execution on local machine\n\nLet me start implementing the script based on the plan and the code snippets the user provided in their original message.","signature":"ErsECkgICxACGAIqQN9mH184wALeHyPTnbelDPiAzElEeoBico/5UTQ9xO+diJ8OiBGq86iLCbfNyW4B8JshPCxKC7zgNSKrhrTJnMMSDM/6davtq+5zY9bpexoM6/3J4Z+KRVSSMC4iIjB0xfNlNwJEt/qzRiKbLLD8YxU2EXfcAYp1D4sty4/eIe4jF0KFgeDcBAHEokdX8s8qoANYGAJlmD+ptPvZgCrFoJOydOjUYXBL44VRmOeWYMtn2lVjGjSLFLLOC6/74XDAuPStHtg9Nv6jialJIMGjPYvGZlebV1NfDEaSFyB4UumzL3sq8HVx19qjauktevLMoBfbYGWPJUkXPvNVhc5QHDUre6yErOnELpuUzZsag+o/QtEh3gpB/mV6QT+i9G2INNJfLIBdFGpUd7BmWVQvRQey91gFbO50hMrilTdmi1g0+dYxjGgPT2B7COiHBmlz/y8k8QBN2Hdgww8wsTXQuRZfZ/GK48VRKuW22pBvun5UGxb7mQSf3Xe7DfO5jlnS4O8ULZE9kg8uyhTKIvh7par+p9cBYJZ7tAhGKFeftBhZ/50Uzyv3J1pzWDNVnmSyQEqUARBMs0aHO7ngAothD1XDVtKAwSxIN/RJ1Snd3CyvrJ9cJdJb3rtMxvcGznKH1KEO9ymY0Z/y4UzxOvkoO2npLNV1snMlDrXuYG+VoOoGWVr2Y5CPbox6/sGMNrM0tpShBV1pQVCQTHR5UVaX7f/kDZI2UN7aiZWLfULAmSOqXRgB"},"thinkingStyle":1,"thinkingDurationMs":2828},"bubbleId":"4e8e6511-398e-4d6b-9c5f-31397cdb0cc3"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"52df6034-ebf6-4d1d-b6f9-149eda92e8a4","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"861cdc21-ed75-4deb-9985-b81d8a78e2c4","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:54:47.732Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":["file:///c%3A/Users/user/Downloads/Cursor_working_directory_misc"],"codeBlocks":[],"text":"","modelInfo":{"modelName":"local-qwen-7b"},"timingInfo":{"clientStartTime":10103635.800000012,"clientRpcSendTime":1766969687732},"workspaceProjectDir":"c:\\Users\\user\\.cursor\\projects\\c-Users-user-Downloads-Cursor-working-directory-misc"},"bubbleId":"52df6034-ebf6-4d1d-b6f9-149eda92e8a4"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"57c4da06-3017-4e0e-a90a-1a7becaee5a4","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:00:58.255Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"60f0ece2-b461-4053-ab52-4d2da6a10c7a","codeBlocks":[],"capabilityType":15,"toolFormerData":{"tool":15,"toolCallId":"toolu_vrtx_018V3R9SmP33zWfimdGCzBm6","toolIndex":1,"modelCallId":"f68d18ae-e44c-446c-97a5-b52cbaa1c6f6","status":"completed","rawArgs":"{\"command\": \"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\" -Analyze\", \"is_background\": false, \"explanation\": \"Testing the -Analyze functionality after fixing date parsing.\"}","name":"run_terminal_cmd","params":"{\"command\":\"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\" -Analyze\",\"requireUserApproval\":true,\"parsingResult\":{\"executableCommands\":[{\"name\":\"powershell\",\"args\":[{\"type\":\"word\",\"value\":\"-ExecutionPolicy\"},{\"type\":\"word\",\"value\":\"Bypass\"},{\"type\":\"word\",\"value\":\"-File\"},{\"type\":\"string\",\"value\":\"\\\".\\\\USB-Inventory.ps1\\\"\"},{\"type\":\"word\",\"value\":\"-Analyze\"}],\"fullText\":\"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\" -Analyze\"}]},\"fileOutputThresholdBytes\":\"20000\"}","additionalData":{"status":"success","reviewData":{"status":"Done","selectedOption":"run","isShowingInput":false,"candidatesForAllowlist":["powershell"],"approvalType":"allowlist"},"sessionId":"5dd745c9-3368-496b-b5ac-9b78458b05d4","startAtBufferLine":0,"previousAttempt":"{\"output\":\"\\n========================================================\\n   GATHERING HARDWARE SPECS... PLEASE WAIT\\n========================================================\\n\\nSUCCESS!\\nData saved to: C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\PC_Inventory_Master.csv\\nC:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\USB-Inventory.ps1 : The property \u0027Count\u0027 cannot be found on this \\r\\nobject. Verify that the property exists.\\r\\n    + CategoryInfo          : NotSpecified: (:) [USB-Inventory.ps1], PropertyNotFoundException\\r\\n    + FullyQualifiedErrorId : PropertyNotFoundStrict,USB-Inventory.ps1\\r\\n \\r\\n\",\"rejected\":false,\"notInterrupted\":true,\"endedReason\":\"RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED\",\"exitCodeV2\":1,\"effectiveSandboxPolicy\":{\"type\":\"TYPE_INSECURE_NONE\"}}"},"result":"{\"output\":\"\\n========================================================\\n   GATHERING HARDWARE SPECS... PLEASE WAIT\\n========================================================\\n\\nSUCCESS!\\nData saved to: C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\PC_Inventory_Master.csv\\nC:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\USB-Inventory.ps1 : The property \u0027Count\u0027 cannot be found on this \\r\\nobject. Verify that the property exists.\\r\\n    + CategoryInfo          : NotSpecified: (:) [USB-Inventory.ps1], PropertyNotFoundException\\r\\n    + FullyQualifiedErrorId : PropertyNotFoundStrict,USB-Inventory.ps1\\r\\n \\r\\n\",\"rejected\":false,\"notInterrupted\":true,\"endedReason\":\"RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED\",\"exitCodeV2\":1,\"effectiveSandboxPolicy\":{\"type\":\"TYPE_INSECURE_NONE\"}}"}},"bubbleId":"57c4da06-3017-4e0e-a90a-1a7becaee5a4"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"5ef8913a-6f34-4b55-b671-b53311d43475","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:01:34.528Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"c4636bbc-4e02-4297-bb25-e81744236396","usageUuid":"1ba3a684-7b2f-455d-81c6-67d73a94a2df","capabilityType":30,"thinking":{"text":"Excellent! The script now works. Let me also test -AnalyzeOnly to make sure that path works too.","signature":"EooCCkgICxACGAIqQBt41HbJzvzKBbJ90vWBoCyvJHUyTN/Eao/1Ra4t/ZRKrMRFlRATUW9OAbFC829nPP7BO8y2RpclBHRiSmu0NpgSDJC3iVcIjKq2+lEqVhoM541SpIAja0Ruij+5IjA+vA5w+ijECryhuZ/ZEd1HA4tT/u151y6R0iSAz6RowxVoVcl5D5AjSUPHDbCPRu8qcNOxf3YyqayNQidhDMsqRFHQk7N5zbtoPu0TWjq62LN89o2Ua8qbv26CL856NQK4Z4yoKj1fzftDSufmo9zqEhNqagbM5zyCzbwSTtN9HKrH0lptSlsWnlBduu/17Xd+sYd33c5wYul2ywvY55jkIyMYAQ=="},"thinkingStyle":1,"thinkingDurationMs":1083},"bubbleId":"5ef8913a-6f34-4b55-b671-b53311d43475"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"67bf5648-9747-4c3e-b00b-35f8046330a1","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:02:04.953Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"992ef4a3-aaaa-4b66-8d89-46dcc8b446d0","codeBlocks":[],"capabilityType":15,"toolFormerData":{"tool":15,"toolCallId":"toolu_vrtx_01M7ob6XN4rVY4J4BxfU8wiC","toolIndex":1,"modelCallId":"7318723d-49a7-4178-9211-04c77561709a","status":"completed","rawArgs":"{\"command\": \"Remove-Item PC_Inventory_Master.csv, Inventory_Issues_Report.txt, Inventory_Issues_Report.csv -ErrorAction SilentlyContinue\", \"is_background\": false, \"explanation\": \"Cleaning up test files generated during testing.\"}","name":"run_terminal_cmd","params":"{\"command\":\"Remove-Item PC_Inventory_Master.csv, Inventory_Issues_Report.txt, Inventory_Issues_Report.csv -ErrorAction SilentlyContinue\",\"requireUserApproval\":true,\"parsingResult\":{\"executableCommands\":[{\"name\":\"Remove-Item\",\"args\":[{\"type\":\"word\",\"value\":\"PC_Inventory_Master.csv,\"},{\"type\":\"word\",\"value\":\"Inventory_Issues_Report.txt,\"},{\"type\":\"word\",\"value\":\"Inventory_Issues_Report.csv\"},{\"type\":\"word\",\"value\":\"-ErrorAction\"},{\"type\":\"word\",\"value\":\"SilentlyContinue\"}],\"fullText\":\"Remove-Item PC_Inventory_Master.csv, Inventory_Issues_Report.txt, Inventory_Issues_Report.csv -ErrorAction SilentlyContinue\"}]},\"fileOutputThresholdBytes\":\"20000\"}","additionalData":{"status":"success","reviewData":{"status":"Done","selectedOption":"run","isShowingInput":false,"candidatesForAllowlist":["Remove-Item"],"approvalType":"allowlist"},"sessionId":"5dd745c9-3368-496b-b5ac-9b78458b05d4","startAtBufferLine":0,"previousAttempt":"{\"rejected\":false,\"notInterrupted\":true,\"endedReason\":\"RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED\",\"exitCodeV2\":0,\"effectiveSandboxPolicy\":{\"type\":\"TYPE_INSECURE_NONE\"}}"},"result":"{\"rejected\":false,\"notInterrupted\":true,\"endedReason\":\"RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED\",\"exitCodeV2\":0,\"effectiveSandboxPolicy\":{\"type\":\"TYPE_INSECURE_NONE\"}}"}},"bubbleId":"67bf5648-9747-4c3e-b00b-35f8046330a1"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"692430ca-b80d-4471-bb30-8a534c1ce177","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":["{\"content\":\"Create USB-Inventory.ps1 combining collection + analysis logic\",\"status\":\"completed\",\"id\":\"synth-script\"}","{\"content\":\"Test script execution on local machine\",\"status\":\"in_progress\",\"id\":\"test-local\"}"],"createdAt":"2025-12-29T00:59:08.249Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"aa84bc24-3ac4-4cb9-ad69-5f82484b6ce7","codeBlocks":[],"capabilityType":15,"toolFormerData":{"tool":35,"toolCallId":"toolu_vrtx_014N7VeGPeRMCKGcCmi9cztZ","toolIndex":1,"modelCallId":"dbae0edf-9714-4678-a07d-596d49604597","status":"completed","rawArgs":"{\"todos\": [{\"id\": \"synth-script\", \"content\": \"Create USB-Inventory.ps1 combining collection + analysis logic\", \"status\": \"completed\"}, {\"id\": \"test-local\", \"content\": \"Test script execution on local machine\", \"status\": \"in_progress\"}], \"merge\": true}","name":"todo_write","params":"{\"todos\":[{\"content\":\"Create USB-Inventory.ps1 combining collection + analysis logic\",\"status\":\"completed\",\"id\":\"synth-script\"}]}","additionalData":{},"result":"{\"success\":true,\"finalTodos\":[{\"content\":\"Create USB-Inventory.ps1 combining collection + analysis logic\",\"status\":\"completed\",\"id\":\"synth-script\"},{\"content\":\"Test script execution on local machine\",\"status\":\"in_progress\",\"id\":\"test-local\"}],\"initialTodos\":[{\"content\":\"Create USB-Inventory.ps1 combining collection + analysis logic\",\"status\":\"in_progress\",\"id\":\"synth-script\"},{\"content\":\"Test script execution on local machine\",\"status\":\"pending\",\"id\":\"test-local\"}],\"wasMerge\":true}"}},"bubbleId":"692430ca-b80d-4471-bb30-8a534c1ce177"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"6ac9241a-25b4-49df-8775-722c3bcf372f","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:01:45.370Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"1ba3a684-7b2f-455d-81c6-67d73a94a2df","codeBlocks":[],"capabilityType":15,"toolFormerData":{"tool":15,"toolCallId":"toolu_vrtx_01MoMp5bzdRaYB5EWfBo54DA","toolIndex":1,"modelCallId":"f6d9e3a0-613b-4a25-9bde-c27a10a042b8","status":"completed","rawArgs":"{\"command\": \"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\" -AnalyzeOnly\", \"is_background\": false, \"explanation\": \"Testing -AnalyzeOnly mode to verify it skips collection and only analyzes.\"}","name":"run_terminal_cmd","params":"{\"command\":\"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\" -AnalyzeOnly\",\"requireUserApproval\":true,\"parsingResult\":{\"executableCommands\":[{\"name\":\"powershell\",\"args\":[{\"type\":\"word\",\"value\":\"-ExecutionPolicy\"},{\"type\":\"word\",\"value\":\"Bypass\"},{\"type\":\"word\",\"value\":\"-File\"},{\"type\":\"string\",\"value\":\"\\\".\\\\USB-Inventory.ps1\\\"\"},{\"type\":\"word\",\"value\":\"-AnalyzeOnly\"}],\"fullText\":\"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\" -AnalyzeOnly\"}]},\"fileOutputThresholdBytes\":\"20000\"}","additionalData":{"status":"success","reviewData":{"status":"Done","selectedOption":"run","isShowingInput":false,"candidatesForAllowlist":["powershell"],"approvalType":"allowlist"},"sessionId":"5dd745c9-3368-496b-b5ac-9b78458b05d4","startAtBufferLine":0,"previousAttempt":"{\"output\":\"\\n======================================================================\\nReport saved: C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\Inventory_Issues_Report.txt\\nIssues CSV:   C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\Inventory_Issues_Report.csv\\nIssues found: 1\\n======================================================================\\nInfo: 1\\n\",\"rejected\":false,\"notInterrupted\":true,\"endedReason\":\"RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED\",\"exitCodeV2\":0,\"effectiveSandboxPolicy\":{\"type\":\"TYPE_INSECURE_NONE\"}}"},"result":"{\"output\":\"\\n======================================================================\\nReport saved: C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\Inventory_Issues_Report.txt\\nIssues CSV:   C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\Inventory_Issues_Report.csv\\nIssues found: 1\\n======================================================================\\nInfo: 1\\n\",\"rejected\":false,\"notInterrupted\":true,\"endedReason\":\"RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED\",\"exitCodeV2\":0,\"effectiveSandboxPolicy\":{\"type\":\"TYPE_INSECURE_NONE\"}}"}},"bubbleId":"6ac9241a-25b4-49df-8775-722c3bcf372f"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"6c6bd087-ae33-46b6-8f24-1669867d133a","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:01:09.916Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"df7050ae-299f-41ae-a21f-dc2247355b60","usageUuid":"af06e54b-e699-4ebe-b525-d1b8fb1c6f58","capabilityType":30,"thinking":{"text":"The issue is likely with accessing `.Count` on arrays that could be null or single items. When PowerShell returns a single object from a pipeline, it\u0027s not an array and doesn\u0027t have a `.Count` property. In Strict Mode, this throws an error.\n\nThe likely culprit is on lines 658-663 where we\u0027re using `.Count` on `$r.PSObject.Properties.Match()` results. Let me fix those and also wrap other array Count checks.\n\nThe fix is to use `@(...)` to ensure arrays, or use `.Count` with a null-coalescing approach, or use a helper function.","signature":"ErsFCkgICxACGAIqQK04StByo7aoN/1h7lT7NIvnXbwCzwegCxxuKFOYH9TCe562AR3rdzzFuCQqzUoZShn9Ci/ezvR8/SEUcANx0v0SDDKRGqngUCcr4k239BoMkxzo6mUVvZbUwy01IjA12UUUkBhP84UIt1DhOgOOuAltxzsfSFwpCzjsolnNPJHDA3bKGzhEoKVa4o0hvDQqoARfGNBVXer4Z/p3ymmnuTxvKCjIvm3nElMgWaMlt+cjTzxLYhhtAfqfrI+LFMOiYr3FdX2YSrVO9K31buQY6Ywn99Yt73EiQYwjmeCOJu3OhUt1DFL00XdL9G67ulpXYOvrX0dV1ar3KEx2plM1g7kVL0Cb369n+bAXDkEWWYmFGsaBzq8Vkxajx+waQm/ZZusQzNl9DRCNm+DeX2J9i7f9SsLWISvlA5m2aCmImUyPdAfeyGpsRq03KaJyFxnNI+opNOat9Dt2oPVERo8cr22XOCYka+1AeBktfXvPu1lmQPag/bAgZIn1DKQ+pr3UORkviubpGyrGj4CtaVg3hWFysBmMVOkrFxhUz2iaoXBlcyKRf5p7p7bV0htt8FnKy0mP8RNF5Sf5SnT3vrCsHZcc63m8s3LW5MwOWisJX1pMcK/zCridrAQRB31EXwIUyf+f47SbrP9yJa6F1bmrFHUQ3NDksmQwpIf6nIpEc83u3GgLAc/7CkBARdm/3aiwkGkt2rSyUNb2594hOE5Y5EZCRTix/FDye9GdYVZJf8zDbYNVhZJkcxg2ZrZgOSOewcDExrYghpVwyifxhVSYcn/Rv4xG3uUHncImTFp+qJVwTctNGfk/S+ZpQJnUYZgNYABb+/3ie9IVvyY2vN7UhOgP5N5+J6VahfrIqyqBdfLfDsy6OmeoMlwlVkDoesBi0zc9lNcsCoatCyaROgwOaDHjGAE="},"thinkingStyle":1,"thinkingDurationMs":4464},"bubbleId":"6c6bd087-ae33-46b6-8f24-1669867d133a"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"7681c233-4d5a-4d8e-a33e-c2b3002ba555","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:01:52.189Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"d66c932c-e7be-42d4-8286-c42be412c3fa","codeBlocks":[],"capabilityType":15,"toolFormerData":{"tool":40,"toolCallId":"toolu_vrtx_0191N7edKSbKaUuPu8gH3o43","toolIndex":1,"modelCallId":"d5574437-f0b0-4a80-b692-b6e0f5366b7a","status":"completed","rawArgs":"{\"target_file\": \"PC_Inventory_Master.csv\"}","name":"read_file","params":"{\"targetFile\":\"PC_Inventory_Master.csv\",\"charsLimit\":100000,\"effectiveUri\":\"file:///c%3A/Users/user/Downloads/Cursor_working_directory_misc/PC_Inventory_Master.csv\"}","additionalData":{},"result":"{\"contents\":\"\\\"Hostname\\\",\\\"User\\\",\\\"Make_Model\\\",\\\"System_Serial\\\",\\\"Baseboard_Make\\\",\\\"Baseboard_Product\\\",\\\"Baseboard_Serial\\\",\\\"BIOS_Version\\\",\\\"BIOS_ReleaseDate\\\",\\\"OS_Caption\\\",\\\"OS_Version\\\",\\\"OS_BuildNumber\\\",\\\"CPU\\\",\\\"RAM_GB\\\",\\\"Network_Adapters\\\",\\\"GPUs\\\",\\\"Disk_Serials\\\",\\\"Monitor_Serials\\\",\\\"PCI_Devices\\\",\\\"Scan_Date\\\",\\\"Scan_Timestamp\\\",\\\"Collector_Version\\\",\\\"Errors\\\"\\r\\n\\\"DESKTOP-7KTB236\\\",\\\"user\\\",\\\"LENOVO 90UX000QUS\\\",\\\"PF4VVA6F\\\",\\\"LENOVO\\\",\\\"3768\\\",\\\"\\\",\\\"O5SKT31A\\\",\\\"\\\",\\\"Microsoft Windows 11 Pro\\\",\\\"10.0.26200\\\",\\\"26200\\\",\\\"AMD Ryzen 7 7700 8-Core Processor\\\",\\\"16\\\",\\\"\\\",\\\"NVIDIA GeForce RTX 4060 [ID:PCI\\\\VEN_10DE\u0026DEV_2882\u0026SUBSYS_233617AA\u0026REV_A1\\\\4\u00263AC71E07\u00260\u00260009] | NVIDIA NVIDIA GeForce RTX 4060, [N/A]\\\",\\\"SAMSUNG MZVL21T0HDLU-00BL7 SN:0025_38B9_3101_FBB6. Type:SSD GB:954 | Verbatim STORE N GO SN:057029103060 Type:Unspecified GB:58\\\",\\\"MSI MSI G32C4X (SN:0)\\\",\\\"\\\",\\\"2025-12-28\\\",\\\"2025-12-28 18:00:29\\\",\\\"2.0\\\",\\\"\\\"\\r\\n\\\"DESKTOP-7KTB236\\\",\\\"user\\\",\\\"LENOVO 90UX000QUS\\\",\\\"PF4VVA6F\\\",\\\"LENOVO\\\",\\\"3768\\\",\\\"\\\",\\\"O5SKT31A\\\",\\\"\\\",\\\"Microsoft Windows 11 Pro\\\",\\\"10.0.26200\\\",\\\"26200\\\",\\\"AMD Ryzen 7 7700 8-Core Processor\\\",\\\"16\\\",\\\"\\\",\\\"NVIDIA GeForce RTX 4060 [ID:PCI\\\\VEN_10DE\u0026DEV_2882\u0026SUBSYS_233617AA\u0026REV_A1\\\\4\u00263AC71E07\u00260\u00260009] | NVIDIA NVIDIA GeForce RTX 4060, [N/A]\\\",\\\"SAMSUNG MZVL21T0HDLU-00BL7 SN:0025_38B9_3101_FBB6. Type:SSD GB:954 | Verbatim STORE N GO SN:057029103060 Type:Unspecified GB:58\\\",\\\"MSI MSI G32C4X (SN:0)\\\",\\\"\\\",\\\"2025-12-28\\\",\\\"2025-12-28 18:00:40\\\",\\\"2.0\\\",\\\"\\\"\\r\\n\\\"DESKTOP-7KTB236\\\",\\\"user\\\",\\\"LENOVO 90UX000QUS\\\",\\\"PF4VVA6F\\\",\\\"LENOVO\\\",\\\"3768\\\",\\\"\\\",\\\"O5SKT31A\\\",\\\"\\\",\\\"Microsoft Windows 11 Pro\\\",\\\"10.0.26200\\\",\\\"26200\\\",\\\"AMD Ryzen 7 7700 8-Core Processor\\\",\\\"16\\\",\\\"\\\",\\\"NVIDIA GeForce RTX 4060 [ID:PCI\\\\VEN_10DE\u0026DEV_2882\u0026SUBSYS_233617AA\u0026REV_A1\\\\4\u00263AC71E07\u00260\u00260009] | NVIDIA NVIDIA GeForce RTX 4060, [N/A]\\\",\\\"SAMSUNG MZVL21T0HDLU-00BL7 SN:0025_38B9_3101_FBB6. Type:SSD GB:954 | Verbatim STORE N GO SN:057029103060 Type:Unspecified GB:58\\\",\\\"MSI MSI G32C4X (SN:0)\\\",\\\"\\\",\\\"2025-12-28\\\",\\\"2025-12-28 18:01:04\\\",\\\"2.0\\\",\\\"\\\"\\r\\n\\\"DESKTOP-7KTB236\\\",\\\"user\\\",\\\"LENOVO 90UX000QUS\\\",\\\"PF4VVA6F\\\",\\\"LENOVO\\\",\\\"3768\\\",\\\"\\\",\\\"O5SKT31A\\\",\\\"\\\",\\\"Microsoft Windows 11 Pro\\\",\\\"10.0.26200\\\",\\\"26200\\\",\\\"AMD Ryzen 7 7700 8-Core Processor\\\",\\\"16\\\",\\\"\\\",\\\"NVIDIA GeForce RTX 4060 [ID:PCI\\\\VEN_10DE\u0026DEV_2882\u0026SUBSYS_233617AA\u0026REV_A1\\\\4\u00263AC71E07\u00260\u00260009] | NVIDIA NVIDIA GeForce RTX 4060, [N/A]\\\",\\\"SAMSUNG MZVL21T0HDLU-00BL7 SN:0025_38B9_3101_FBB6. Type:SSD GB:954 | Verbatim STORE N GO SN:057029103060 Type:Unspecified GB:58\\\",\\\"MSI MSI G32C4X (SN:0)\\\",\\\"\\\",\\\"2025-12-28\\\",\\\"2025-12-28 18:01:40\\\",\\\"2.0\\\",\\\"\\\"\\r\\n\",\"numCharactersInRequestedRange\":2395,\"totalLinesInFile\":6}","attachments":"{\"shouldShowTodoWriteReminder\":true,\"todoReminderType\":\"TODO_REMINDER_TYPE_EVERY_10_TURNS\"}"}},"bubbleId":"7681c233-4d5a-4d8e-a33e-c2b3002ba555"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"81cc3bcf-da31-4269-80d2-d7526b5cfb5b","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:55:49.363Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"87aee03c-9439-4b75-83a9-4f7fd7940077","usageUuid":"45d7fab2-f5b9-4af9-b2c2-66d4e1bd1674","capabilityType":30,"thinking":{"text":"Now I\u0027ll create the USB-Inventory.ps1 script by combining the collection and analysis functionality from the user\u0027s provided scripts.","signature":"ErACCkgICxACGAIqQHequMX4Dh1hdUtfh4m8EdjE5XHHauAX4D743lMWou0TfraU6k08P8Dn1v0ZlTT+CHHquosTWBVAUiXog0HRWmISDEtlUp4Em6u6IaIS/hoMZ7xwjtUb2W1UHzFcIjCWaRJ4s5hoilEFUeLtIdBrN6mglDnsARJidm/WlD/My3kNoFBarxG2Y02HIwWhgUYqlQFe6xOZeNfR0Er8qU+cYXXAW+G4ij+O7OQt4UTk1WES8b/vTB7VE/1MKmZEhUDkiYtUDCVrneFKKP/70la1zJSNuiMrV50hCPV1G6CTZFxaVh8+LGq1Kq/husL+Xh7qEWFxVHKyyWvcieF4DF8n3MEhm69xeG2kMakju6iXgh4pf0014q7q2fw55CCe3XKdYuqP+Agq8xgB"},"thinkingStyle":1,"thinkingDurationMs":1108},"bubbleId":"81cc3bcf-da31-4269-80d2-d7526b5cfb5b"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"8b3569b5-6bc4-461d-a77d-bd4b106d7327","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:55:18.162Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"Looking at your request, I need to synthesize the two PowerShell scripts (collection + analysis) into a single portable script for USB-based PC inventory.\n\nLet me create a plan for this:","usageUuid":"a9191b46-22da-4067-a6e4-b4d34407fb70","toolFormerData":{"additionalData":{"status":"error"}}},"bubbleId":"8b3569b5-6bc4-461d-a77d-bd4b106d7327"}
{"data":{"_v":3,"type":1,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"90e85453-f902-410a-a296-bc1f83ce3d8d","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":true,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"8260971b-a940-4daf-be09-b8d59af492b8","attachedFoldersListDirResults":[],"humanChanges":[],"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[1,41,7,38,8,9,11,12,15,18,25,27,43,46,47,29,30,32,34,35,39,40,42,44,45,49,52],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[{"relativeWorkspacePath":"c:\\Users\\user\\.cursor\\projects\\c-Users-user-Downloads-Cursor-working-directory-misc\\terminals\\3.txt","startLineNumber":1,"lines":[],"languageIdentifier":"","intent":8,"isOnlyIncludedFromFolder":false}],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:55:44.108Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":["file:///c%3A/Users/user/Downloads/Cursor_working_directory_misc"],"richText":"Implement the plan as specified, it is attached for your reference. Do NOT edit the plan file itself.\n\nTo-do\u0027s from the plan have already been created. Do not create them again. Mark them as in_progress as you work, starting with the first one. Don\u0027t stop until you have completed all the to-dos.","text":"Implement the plan as specified, it is attached for your reference. Do NOT edit the plan file itself.\n\nTo-do\u0027s from the plan have already been created. Do not create them again. Mark them as in_progress as you work, starting with the first one. Don\u0027t stop until you have completed all the to-dos.","modelInfo":{"modelName":"claude-4.5-opus-high-thinking"},"isNudge":false,"contextWindowStatusAtCreation":{"percentageRemaining":60,"percentageRemainingFloat":60.90625,"tokensUsed":68805,"tokenLimit":176000},"skipRendering":false,"isPlanExecution":true,"planUri":"file:///c%3A/Users/user/.cursor/plans/usb_inventory_script_4c3f18cf.plan.md","editToolSupportsSearchAndReplace":true,"workspaceProjectDir":"c:\\Users\\user\\.cursor\\projects\\c-Users-user-Downloads-Cursor-working-directory-misc","context":{"composers":[],"quotes":[],"selectedCommits":[],"selectedPullRequests":[],"selectedImages":[],"folderSelections":[],"fileSelections":[],"terminalFiles":[],"selections":[{"uri":{"$mid":1,"fsPath":"c:\\Users\\user\\.cursor\\plans\\usb_inventory_script_4c3f18cf.plan.md","_sep":1,"external":"file:///c%3A/Users/user/.cursor/plans/usb_inventory_script_4c3f18cf.plan.md","path":"/c:/Users/user/.cursor/plans/usb_inventory_script_4c3f18cf.plan.md","scheme":"file"},"text":"# USB-Inventory.ps1 Synthesis Plan\n\n## Approach\n\nCombine the improved collection script (v2.0 with WmiMonitorID, fallbacks, error tracking) with the analysis script into one file. The script will:\n\n1. **Collect** hardware inventory on the current PC\n2. **Append** to `PC_Inventory_Master.csv` in the same folder as the script (USB root)\n3. **Optionally analyze** the CSV for issues when `-Analyze` is passed\n\n## Script Structure\n\n```\nUSB-Inventory.ps1\n  [Parameters]\n    -OutputFile     (default: PC_Inventory_Master.csv in $PSScriptRoot)\n    -IncludePciDevices\n    -Analyze        (runs health check after collection)\n    -AnalyzeOnly    (skip collection, just analyze existing CSV)\n    -StaleDays      (default: 90)\n    -MinRamGB       (default: 8)\n\n  [Helper Functions]\n    Clean-Cell, Convert-UShortArrayToString\n    Get-MonitorInventory (WmiMonitorID preferred, EDID registry fallback)\n    Get-NetworkInventory (Get-NetAdapter preferred, CIM fallback)\n    Get-GpuInventory     (CIM + nvidia-smi if present)\n    Get-DiskInventory    (Get-PhysicalDisk preferred, CIM fallback)\n    Get-PciDeviceInventory (optional)\n    \n    # Analysis helpers\n    Parse-ScanDate, Normalize-Serial, Parse-RamGB, Is-MonitorMissing\n    Get-ColumnMap (tolerates renamed headers)\n\n  [Main]\n    IF NOT $AnalyzeOnly:\n      Collect system/BIOS/CPU/OS/baseboard info\n      Collect network/GPU/disk/monitor inventories\n      Build PSCustomObject record\n      Append to CSV (with header safety)\n      \n    IF $Analyze OR $AnalyzeOnly:\n      Import CSV\n      Detect duplicates, stale assets, low RAM, missing monitors\n      Output text report + optional CSV of issues\n```\n\n## Key Design Decisions\n\n| Decision | Rationale |\n|----------|-----------|\n| PowerShell 5.1 compatible | Ships with Windows 10/11; no `??` operator |\n| `$PSScriptRoot` for paths | Works correctly when run from USB |\n| Append mode with header check | Multiple PCs can be scanned to same CSV |\n| Error column in CSV | Non-fatal errors captured, not hidden |\n| WmiMonitorID first | More reliable than EDID registry decode |\n| Analysis is optional | Collection is the primary use case |\n\n## Output Files (on USB)\n\n- `PC_Inventory_Master.csv` - cumulative inventory\n- `Inventory_Issues_Report.txt` - human-readable (when `-Analyze`)\n- `Inventory_Issues_Report.csv` - sortable issues (when `-Analyze`)\n\n## Usage Examples\n\n```powershell\n# Basic: collect this PC\u0027s inventory\n.\\USB-Inventory.ps1\n\n# Collect with PCI devices and run analysis\n.\\USB-Inventory.ps1 -IncludePciDevices -Analyze\n\n# Just analyze existing data (no new collection)\n.\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\n```\n\n## File Location\n\nNew file: `USB-Inventory.ps1` (single ~600-line script in workspace root or user-specified location)","rawText":"# USB-Inventory.ps1 Synthesis Plan\n\n## Approach\n\nCombine the improved collection script (v2.0 with WmiMonitorID, fallbacks, error tracking) with the analysis script into one file. The script will:\n\n1. **Collect** hardware inventory on the current PC\n2. **Append** to `PC_Inventory_Master.csv` in the same folder as the script (USB root)\n3. **Optionally analyze** the CSV for issues when `-Analyze` is passed\n\n## Script Structure\n\n```\nUSB-Inventory.ps1\n  [Parameters]\n    -OutputFile     (default: PC_Inventory_Master.csv in $PSScriptRoot)\n    -IncludePciDevices\n    -Analyze        (runs health check after collection)\n    -AnalyzeOnly    (skip collection, just analyze existing CSV)\n    -StaleDays      (default: 90)\n    -MinRamGB       (default: 8)\n\n  [Helper Functions]\n    Clean-Cell, Convert-UShortArrayToString\n    Get-MonitorInventory (WmiMonitorID preferred, EDID registry fallback)\n    Get-NetworkInventory (Get-NetAdapter preferred, CIM fallback)\n    Get-GpuInventory     (CIM + nvidia-smi if present)\n    Get-DiskInventory    (Get-PhysicalDisk preferred, CIM fallback)\n    Get-PciDeviceInventory (optional)\n    \n    # Analysis helpers\n    Parse-ScanDate, Normalize-Serial, Parse-RamGB, Is-MonitorMissing\n    Get-ColumnMap (tolerates renamed headers)\n\n  [Main]\n    IF NOT $AnalyzeOnly:\n      Collect system/BIOS/CPU/OS/baseboard info\n      Collect network/GPU/disk/monitor inventories\n      Build PSCustomObject record\n      Append to CSV (with header safety)\n      \n    IF $Analyze OR $AnalyzeOnly:\n      Import CSV\n      Detect duplicates, stale assets, low RAM, missing monitors\n      Output text report + optional CSV of issues\n```\n\n## Key Design Decisions\n\n| Decision | Rationale |\n|----------|-----------|\n| PowerShell 5.1 compatible | Ships with Windows 10/11; no `??` operator |\n| `$PSScriptRoot` for paths | Works correctly when run from USB |\n| Append mode with header check | Multiple PCs can be scanned to same CSV |\n| Error column in CSV | Non-fatal errors captured, not hidden |\n| WmiMonitorID first | More reliable than EDID registry decode |\n| Analysis is optional | Collection is the primary use case |\n\n## Output Files (on USB)\n\n- `PC_Inventory_Master.csv` - cumulative inventory\n- `Inventory_Issues_Report.txt` - human-readable (when `-Analyze`)\n- `Inventory_Issues_Report.csv` - sortable issues (when `-Analyze`)\n\n## Usage Examples\n\n```powershell\n# Basic: collect this PC\u0027s inventory\n.\\USB-Inventory.ps1\n\n# Collect with PCI devices and run analysis\n.\\USB-Inventory.ps1 -IncludePciDevices -Analyze\n\n# Just analyze existing data (no new collection)\n.\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\n```\n\n## File Location\n\nNew file: `USB-Inventory.ps1` (single ~600-line script in workspace root or user-specified location)","range":{"selectionStartLineNumber":1,"selectionStartColumn":1,"positionLineNumber":80,"positionColumn":1},"addedWithoutMention":true}],"terminalSelections":[],"selectedDocs":[],"externalLinks":[],"cursorRules":[],"cursorCommands":[],"gitPRDiffSelections":[],"mentions":{"composers":{},"quotes":{},"selectedCommits":{},"selectedPullRequests":{},"gitDiff":[],"gitDiffFromBranchToMain":[],"selectedImages":{},"useWeb":[],"folderSelections":{},"fileSelections":{},"terminalFiles":{},"selections":{},"terminalSelections":{},"selectedDocs":{},"externalLinks":{},"useLinterErrors":[],"useDiffReview":[],"useGenerateRules":[],"useContextPicking":[],"useRememberThis":[],"diffHistory":[],"cursorRules":{},"cursorCommands":{},"autoContext":[],"uiElementSelections":[],"consoleLogs":[],"ideEditorsState":[],"gitPRDiffSelections":{}},"ideEditorsState":true},"checkpointId":"a2d791ce-d3de-4383-bc47-f6e716e74349"},"bubbleId":"90e85453-f902-410a-a296-bc1f83ce3d8d"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"9272f362-a8c3-479f-a2b3-d11d961ed624","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:00:02.640Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"cbf656aa-b678-4025-a2cb-949e3eccadc4","usageUuid":"3b7b3fab-6036-4c00-8d08-519ac1514a44","capabilityType":30,"thinking":{"text":"The inline `try {} catch {}` inside a hashtable value is causing issues with PowerShell 5.1. PowerShell 5.1 doesn\u0027t always handle inline try-catch well in expression contexts. I need to fix this by computing the value before the hashtable construction.","signature":"EqcDCkgICxACGAIqQNUCdKpZGvP71zs098jaZaeUsvBld4jG4hjoLW+O+2HBAaAnPQrVn+FlHDHQ/Zu5b19gtYmt5r25dtdLlw5mLEQSDMAyvTpsaJfPIixEPBoMXYN6QrqqtYeD7AtAIjCiErepqH412qWnAJMEgg+phlX2cC6geE4VgVmIQbl0zsAI7+rRkMxwaaYbeVxWxb8qjAL+WbTKPEeivymKoZpmizhdjcna0Z4flF2VMyDeA5UK9VScZebcu8YU2OSTnKTMvr6x61kCvp1pxPn/QLQ7qk81LNjoRgvfBMKpwjzOZ9mJ7ruQQtnCN1N+sksHsFFWJYIbCxAI+V8rERBpPRh5L5ncpPNo2oRokISqgg2t/do3Vo5WQcLgmPuKoyuHnJV/HApA8BPFUOD78bCD6lWgS865gFf/kH6Yse4miVTn6rNQG4gvDaoqxQLXiZqlLU7WCP5PXEWG/lbgmMfuzWPXF45nIBeWPq9TFiPIKnj9o1KBjvO+SNZAnLDn9rWzHL9+3eATfIZZa+95SN9G5GCbVbllGaKZOXm2PYpJKgmuGAE="},"thinkingStyle":1,"thinkingDurationMs":1951},"bubbleId":"9272f362-a8c3-479f-a2b3-d11d961ed624"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"96dc7589-3aa4-478c-b1a8-4981670d9f65","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:01:17.210Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"de8a968c-fcf3-4589-9dca-da3e5096f57e","usageUuid":"9f8b0953-bf52-46e5-b6f5-99c0c43e02a0","capabilityType":30,"thinking":{"text":"Let me also fix the `$latestByAsset.Count` and `$data.Count` since those could also fail if the result is null or a single item.","signature":"EqsCCkgICxACGAIqQHxxfno+1kMw/fLTyupQmOwL7Tn38xwhs3BNcaJ6eH9s1SaqRH5RV/n4mtx6kyPX3z0fkLs5BZqKhCBjRNlevvsSDH4TRslGo972uCPGBxoMaO5pz8AukRKFf6bSIjBXZn43wsK2MGkgNeIb8K8jPVaBChBI262TLxr4+q0d3qaNUr1PDxkBYGbBsbdN19cqkAHVSJ6LouEd0la9ZTRETp0rbVQYzK6XDXqzkCOR2V9kJzfO5RjAQO2w+SeBR0YZi1HKTBDYTgBS2WbD8l+/rq22RGPwoH9F4CKt+z0GwzUGkirpb33yGS3ltzk4D/aLR1Il29zNqCXc5CevwLQ7CvZu+h/s/clZydQfFX82cigZc3h04hkNp3xvD3E+n32GFisYAQ=="},"thinkingStyle":1,"thinkingDurationMs":1193},"bubbleId":"96dc7589-3aa4-478c-b1a8-4981670d9f65"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"989cb6c7-ee73-4045-b193-fc5a75975907","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:00:58.263Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"6bc88fa1-940e-466d-b9c4-9dae20d80d7a","usageUuid":"267670e9-91ab-44b8-8daa-0eb851a16703","capabilityType":30,"thinking":{"text":"There\u0027s an issue with accessing `.Count` property in strict mode. The strict mode in PowerShell 5.1 doesn\u0027t allow accessing properties that don\u0027t exist. Let me search for uses of `.Count` and fix them.","signature":"EvQCCkgICxACGAIqQCx+nVr9N31vkFC0VU5re3Tr54r8Nu7DIdPcaLne9DgarfDTqxz7Hw8uD5dV0xtuhP3xUDlGKIvS1SJrVaDs43gSDJxy3s2m3qvrfD3bqxoM8383dA193z+zDakGIjAqJHvygnabcw9YFS+tDdRLR0VQCGtp73lcjoqTdzDj4aOahIucS05vL5kERDITSMEq2QGiElMDqbfZqRiENt+r1VpFMBDlHsU2K99h+IrlOycdXMKRWF3BSs2wANADCwdvEW/E3OdAH/0bdB+u1YcthQGz/Lt9p7OHuXk06B/VYC2Pgc7R5toKhFDkZS69SMEnNcQFK7XbHZPEuXzSd3/2Qz8hoEDDaAcIZ+L3h9GS3NpZ5UPsHhXcMLSNl0INZbYB+KOkKBbcmANoNIQqfU8RS7hQWytQfQdK/lHYTZpDb7G5AmH0ItdUKkqA01UyvwzbeEHxE8bHIa3zfjMPHg5kb32AeQMdyBNxuWGhGAE="},"thinkingStyle":1,"thinkingDurationMs":1445},"bubbleId":"989cb6c7-ee73-4045-b193-fc5a75975907"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"9e24fab1-d523-4a60-af21-709343206b53","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":84539,"outputTokens":556},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:02:11.771Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"Done! I\u0027ve created `USB-Inventory.ps1` - a single portable PowerShell script that combines collection and analysis functionality.\n\n## Summary\n\n**File created:** `USB-Inventory.ps1` (~650 lines)\n\n### Features\n\n| Category | Details |\n|----------|---------|\n| **Collection** | System, BIOS, CPU, RAM, Network (MAC/IPv4/Gateway), GPU (+nvidia-smi), Disks (SN/Type/Size), Monitors (WmiMonitorID + EDID fallback), optional PCI devices |\n| **Analysis** | Duplicate serials, stale assets, low RAM, missing monitors, data quality checks |\n| **Output** | `PC_Inventory_Master.csv` (cumulative), optional `Inventory_Issues_Report.txt` and `.csv` |\n\n### Usage Examples\n\n```powershell\n# Basic: collect this PC\u0027s inventory\n.\\USB-Inventory.ps1\n\n# Collect with PCI devices and run analysis\n.\\USB-Inventory.ps1 -IncludePciDevices -Analyze\n\n# Just analyze existing data (no new collection)\n.\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\n```\n\n### Parameters\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `-OutputFile` | `PC_Inventory_Master.csv` | Path to master CSV |\n| `-IncludePciDevices` | off | Enumerate all PCI devices |\n| `-Analyze` | off | Run health analysis after collection |\n| `-AnalyzeOnly` | off | Skip collection, analyze existing CSV |\n| `-StaleDays` | 90 | Threshold for stale asset warnings |\n| `-MinRamGB` | 8 | Minimum RAM threshold |\n| `-NoCsv` | off | Skip generating issues CSV |\n\n### USB Deployment\n\nCopy `USB-Inventory.ps1` to a USB drive. Right-click and **Run with PowerShell** on each target PC (or run via command line with `powershell -ExecutionPolicy Bypass -File .\\USB-Inventory.ps1`). All PCs append to the same `PC_Inventory_Master.csv` on the USB.","usageUuid":"7c8ea77a-2be5-4e0d-808c-87a134c155c0","symbolLinks":["{\"symbolName\":\"USB-Inventory.ps1\",\"symbolSearchString\":\"USB-Inventory.ps1\",\"relativeWorkspacePath\":\"c:\\\\Users\\\\user\\\\.cursor\\\\plans\\\\usb_inventory_script_4c3f18cf.plan.md\",\"roughLineNumber\":14}","{\"symbolName\":\"PC_Inventory_Master.csv\",\"symbolSearchString\":\"PC_Inventory_Master.csv\",\"relativeWorkspacePath\":\"c:\\\\Users\\\\user\\\\.cursor\\\\plans\\\\usb_inventory_script_4c3f18cf.plan.md\",\"roughLineNumber\":8}","{\"symbolName\":\".csv\",\"symbolSearchString\":\".csv\",\"relativeWorkspacePath\":\"c:\\\\Users\\\\user\\\\.cursor\\\\plans\\\\usb_inventory_script_4c3f18cf.plan.md\",\"roughLineNumber\":63}"],"codeBlocks":[{"unregistered":true,"content":"# Basic: collect this PC\u0027s inventory\n.\\USB-Inventory.ps1\n\n# Collect with PCI devices and run analysis\n.\\USB-Inventory.ps1 -IncludePciDevices -Analyze\n\n# Just analyze existing data (no new collection)\n.\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60","languageId":"powershell","isGenerating":false,"isClickable":false,"codeBlockIdx":0}]},"bubbleId":"9e24fab1-d523-4a60-af21-709343206b53"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"a2d14a94-94a6-4808-9158-572562bf132e","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:02:04.964Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"61a9df72-33da-4a9e-8289-0f43560dedaf","usageUuid":"7c8ea77a-2be5-4e0d-808c-87a134c155c0","capabilityType":30,"thinking":{"text":"Both todos are completed. Let me summarize what was created.","signature":"EuYBCkgICxACGAIqQAAafotchN9a+4JNxxz4edK2zpXQU8wKXNtblVVGz5BCOtpvhcoOCcAG9wt7sOw23HWSxD+3H1LAws/PZrlXnsQSDO5gsGO1fHNXBonQSRoMeX7NwwoakVM2JkL9IjDcnY7NvCSuYG7bUG/Bct2SgL62vZ/NSZP/AYj3Stv0RVdsX5cwY4KujgNWsLgZsg8qTDbxx8dQny9F/wIOxcWEmSAEV0cAILL6+g+WU5FNfTOZ8sG3PUfpUZqtuLzVYJ2tDWcYBIkfTNKUXd/RO3QP9IqdQQUqPDZKlY8CwmMYAQ=="},"thinkingStyle":1,"thinkingDurationMs":436},"bubbleId":"a2d14a94-94a6-4808-9158-572562bf132e"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"ade14fb0-8ee4-43f9-8d2c-8e742dfe2ad9","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:01:52.202Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","capabilityType":15,"toolFormerData":{"tool":40,"toolCallId":"toolu_vrtx_01Vf4k6Vs6osZUkWKJqquQc1","toolIndex":2,"modelCallId":"d5574437-f0b0-4a80-b692-b6e0f5366b7a","status":"completed","rawArgs":"{\"target_file\": \"Inventory_Issues_Report.txt\"}","name":"read_file","params":"{\"targetFile\":\"Inventory_Issues_Report.txt\",\"charsLimit\":100000,\"effectiveUri\":\"file:///c%3A/Users/user/Downloads/Cursor_working_directory_misc/Inventory_Issues_Report.txt\"}","additionalData":{},"result":"{\"contents\":\"======================================================================\\r\\nIT INVENTORY HEALTH REPORT\\r\\nGenerated: 12/28/2025 18:01:47\\r\\nInput:     C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\PC_Inventory_Master.csv\\r\\nAssets:    1 (latest per asset)\\r\\nRows:      4 (raw rows in CSV)\\r\\nSettings:  MinRamGB=8, StaleDays=90\\r\\n======================================================================\\r\\n\\r\\n--- Duplicate System Serial (1) ---\\r\\nInfo | PF4VVA6F | Host=(no hostname) User= Serial=PF4VVA6F Scan= | Serial appears 4 times; Hosts=DESKTOP-7KTB236; Users=user; Entries: DESKTOP-7KTB236 (2025-12-28); DESKTOP-7KTB236 (2025-12-28); DESKTOP-7KTB236 (2025-12-28); DESKTOP-7KTB236 (2025-12-28)\\r\\n\\r\\n\",\"numCharactersInRequestedRange\":692,\"totalLinesInFile\":13}"}},"bubbleId":"ade14fb0-8ee4-43f9-8d2c-8e742dfe2ad9"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"ae12bdb9-eccd-442d-8b69-da4492810729","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:01:45.384Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"8caa379d-4945-4f80-a723-47ca875eabfa","usageUuid":"d66c932c-e7be-42d4-8286-c42be412c3fa","capabilityType":30,"thinking":{"text":"Perfect! The -AnalyzeOnly flag correctly skips collection. Let me also check the generated CSV to verify the inventory looks good.","signature":"Eq0CCkgICxACGAIqQCAjyVxXWZjbPYyDey+m4qopgiBQH6yqKDL7dAlTruY4xXO4/ATKliB9eOvx7oly6wv+1AKLMwoAd7tUo4BxHLsSDOqk4fkKCbe0yqDiShoMwguO+dZBlA+JAdZjIjDH0az6UkEciALfcW/OGx+zs3OlLsuCeE60Cy75nwEzTDsdNsBu3E20pqQGSxGHXYQqkgGu/1s9lgaDFy+uYs3ndzUOH5sIiYJH5b6L92LN1z+3o/R9nxXVv89kGwtR9oFSaOfx0I29HbLZ4vmMzmbQpfSWHaSosLZHXRoZF4kqKJ+HrdxvJeyFO5cxzEnNFPuYx8AMy7qT5tEg9kXxssSppa5yw+iQkCXbaw1FQ/v2tFrXBywPF17kpu9zL8DD/ZqxW31vXhgB"},"thinkingStyle":1,"thinkingDurationMs":1014},"bubbleId":"ae12bdb9-eccd-442d-8b69-da4492810729"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"b035b5c8-3079-4871-8532-1c6190dd0a87","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:00:45.483Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"73bfe74f-6573-4fc7-9989-82a92974fe96","codeBlocks":[],"capabilityType":15,"toolFormerData":{"tool":41,"toolCallId":"toolu_vrtx_01NfYzbppuH1G4yhxb3c7TJw","toolIndex":1,"modelCallId":"4a9339fb-333a-411f-9340-ba6882f8355c","status":"completed","rawArgs":"{\"pattern\": \"TryParseExact\", \"path\": \"USB-Inventory.ps1\", \"-C\": 3}","name":"grep","params":"{\"pattern\":\"TryParseExact\",\"path\":\"USB-Inventory.ps1\",\"outputMode\":\"content\",\"context\":3,\"caseInsensitive\":false}","additionalData":{},"result":"{\"success\":{\"pattern\":\"TryParseExact\",\"path\":\"USB-Inventory.ps1\",\"outputMode\":\"content\",\"workspaceResults\":{\"c:/Users/user/Downloads/Cursor_working_directory_misc\":{\"content\":{\"matches\":[{\"file\":\"USB-Inventory.ps1\",\"matches\":[{\"lineNumber\":430,\"isContextLine\":true},{\"lineNumber\":431,\"content\":\"    $dt = $null\",\"isContextLine\":true},{\"lineNumber\":432,\"isContextLine\":true},{\"lineNumber\":433,\"content\":\"    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\"},{\"lineNumber\":434,\"content\":\"    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\"},{\"lineNumber\":435,\"isContextLine\":true},{\"lineNumber\":436,\"content\":\"    if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\",\"isContextLine\":true},{\"lineNumber\":437,\"isContextLine\":true}]}],\"totalLines\":8,\"totalMatchedLines\":2}}}}}"}},"bubbleId":"b035b5c8-3079-4871-8532-1c6190dd0a87"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"b244b9ea-8f20-4a0d-af80-fe07161cf5c3","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:59:08.252Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","capabilityType":15,"toolFormerData":{"tool":39,"toolCallId":"toolu_vrtx_017FBuNHqACvm5Aa5SPNZqVr","toolIndex":2,"modelCallId":"dbae0edf-9714-4678-a07d-596d49604597","status":"completed","rawArgs":"{\"target_directory\": \"c:\\\\Users\\\\user\\\\.cursor\\\\projects\\\\c-Users-user-Downloads-Cursor-working-directory-misc\\\\terminals\"}","name":"list_dir","params":"{\"targetDirectory\":\"c:\\\\Users\\\\user\\\\.cursor\\\\projects\\\\c-Users-user-Downloads-Cursor-working-directory-misc\\\\terminals\",\"shouldEnrichTerminalMetadata\":true}","additionalData":{},"result":"{\"directoryTreeRoot\":{\"absPath\":\"c:\\\\Users\\\\user\\\\.cursor\\\\projects\\\\c-Users-user-Downloads-Cursor-working-directory-misc\\\\terminals\",\"childrenFiles\":[{\"name\":\"3.txt\",\"terminalMetadata\":{\"cwd\":\"/\",\"lastCommands\":[{\"command\":\"gh api \\\"repos/ludoplex/BallisticsCalculator-iOS/actions/workflows\\\" --jq \\\".workflows[] | .name + \\\\\\\": \\\\\\\" + .state\\\"\",\"exitCode\":1,\"timestampMs\":\"1766969911157\",\"durationMs\":\"1898\"},{\"command\":\"bash -c \u0027gh api repos/ludoplex/BallisticsCalculator-iOS/actions/workflows --jq \\\".workflows[] | .name\\\"\u0027\",\"exitCode\":127,\"timestampMs\":\"1766969917036\",\"durationMs\":\"1746\"},{\"command\":\"git checkout main; git pull origin main\",\"exitCode\":0,\"timestampMs\":\"1766969934399\",\"durationMs\":\"2736\"},{\"command\":\"git stash; git checkout main; git pull origin main\",\"exitCode\":0,\"timestampMs\":\"1766969941407\",\"durationMs\":\"2873\"},{\"command\":\"bash -c \\\"cd core/tests \u0026\u0026 ls -la test_*.c\\\"\",\"exitCode\":0,\"timestampMs\":\"1766969948685\",\"durationMs\":\"1666\"}],\"currentCommand\":{\"timestampMs\":\"1766969952848\",\"durationMs\":\"0\"}}}],\"childrenWereProcessed\":true,\"fullSubtreeExtensionCounts\":{\".txt\":1},\"numFiles\":1}}"}},"bubbleId":"b244b9ea-8f20-4a0d-af80-fe07161cf5c3"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"b4e2333e-3b8e-44ed-adf8-44b93b29ce74","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:55:18.820Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":""},"bubbleId":"b4e2333e-3b8e-44ed-adf8-44b93b29ce74"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"b5919024-6c97-4039-9301-78d4c0ab9046","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:59:41.552Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"c9ec0b0d-b5fe-46ef-9aa2-006c68bc0bb0","usageUuid":"e73b9a64-9d71-4962-8ea1-0bed7fe99de6","capabilityType":30,"thinking":{"text":"Now let me test the script again.","signature":"EssBCkgICxACGAIqQAtNj0qdCYOzEobWuv3OGCa7FXFWPBOiYxt5Ac0eqyUddOCI+vc8z5aUIpY7foVu+wpqcAkdq/vXBf9hElDVBekSDMQsSYgPwkS884opyxoMpAPZRUsl/EjKytvGIjATPrdv5BYo5A4Bnljsznp94GcL540Dt5NVrlCKEr8twOzl1FuqbbkpI68dBQ8fPlIqMWETCUbdlxLO4ipWrRhV+OsLunzrD09ee7y8Os7uPNYQCrEBORwtTIc6aFDvOKrTouUYAQ=="},"thinkingStyle":1,"thinkingDurationMs":848},"bubbleId":"b5919024-6c97-4039-9301-78d4c0ab9046"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"bb2536dd-2d15-45a5-8b4c-f8a7e01a8f38","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:00:45.492Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"d7a6d4a2-955d-4e69-b0b2-70fd0485513a","usageUuid":"1e1730f2-3378-4e5b-9f97-ac15549f1a4e","capabilityType":30,"thinking":{"text":"The syntax looks correct. The issue might be with `[Globalization.CultureInfo]::InvariantCulture` or the [ref] syntax when running in strict mode. Let me simplify the date parsing to be more compatible.","signature":"EvUCCkgICxACGAIqQJfo1OcL1Y8jvpAWCAgYygTFjm38QoYH2slzN2wk8sB53JaFkjtXLweYs2FuEIzLzA0TJQAT0grsb13IvJdKYKgSDAgOE1worRsbLZvZVhoMRbZrx0Ce0M8vVDEPIjA6JmSbTtVwJFprJSNuiyN3GPclNQA9wymxpnr+cHWUg3I4i6V0B7/TPd6/mL/egeAq2gF/oVBo+HMLYLGZvwvSHtHjmWIhxQXCunFKqTRVcVIjejm4X1sPC4EBTINbtP3qnU7FDagLEJgw2bEJpKDMxkI4IGEPRkDY55TCsCuQ4nilZuyquxu6mNebvUsFROOhwal2ywc28Jk5WCSs9hbTMoV0Qgd2uxmfPngA8s0huiEd5w8CSnCXsyHVS53ehw7UCu0HjdTDxFnbVYK3GQ6zWLbd1Lv4Jtko9tUi5lZw3X4qG2+7wlQ+t1JVNC4YyXdclIj4prBJmHtohWOrJb7eGACd9SSyRsptc48/zhgB"},"thinkingStyle":1,"thinkingDurationMs":1254},"bubbleId":"bb2536dd-2d15-45a5-8b4c-f8a7e01a8f38"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"c0450ca8-ef36-4aa1-a969-d4cda43ed7c3","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:01:27.810Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"9f8b0953-bf52-46e5-b6f5-99c0c43e02a0","codeBlocks":[{"uri":{"scheme":"file","authority":"","path":"/c:/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1","query":"","fragment":"","_formatted":"file:///c%3A/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1","_fsPath":"c:\\Users\\user\\Downloads\\Cursor_working_directory_misc\\USB-Inventory.ps1"},"codeblockId":"686d945b-6d8a-4978-9283-3c2a8a6b4c12","codeBlockIdx":0,"content":"#requires -Version 5.1\n\u003c#\n.SYNOPSIS\n    USB-portable PC hardware inventory collection and analysis tool.\n\n.DESCRIPTION\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\n    script. Optionally runs health analysis to detect duplicates, stale assets,\n    low RAM, and missing monitor data.\n\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\n\n.PARAMETER OutputFile\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\n\n.PARAMETER IncludePciDevices\n    Include detailed PCI device enumeration (can produce large output).\n\n.PARAMETER Analyze\n    After collection, run health analysis on the CSV file.\n\n.PARAMETER AnalyzeOnly\n    Skip collection; only run health analysis on existing CSV.\n\n.PARAMETER StaleDays\n    Threshold in days for flagging stale assets. Default: 90.\n\n.PARAMETER MinRamGB\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\n\n.PARAMETER NoCsv\n    Do not output Inventory_Issues_Report.csv (text report only).\n\n.EXAMPLE\n    .\\USB-Inventory.ps1\n    Collect inventory from this PC into PC_Inventory_Master.csv.\n\n.EXAMPLE\n    .\\USB-Inventory.ps1 -IncludePciDevices -Analyze\n    Collect inventory with PCI devices, then run health analysis.\n\n.EXAMPLE\n    .\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\n    Analyze existing CSV with custom thresholds (no new collection).\n#\u003e\n\n[CmdletBinding()]\nparam(\n    [string]$OutputFile,\n    [switch]$IncludePciDevices,\n    [switch]$Analyze,\n    [switch]$AnalyzeOnly,\n    [int]$StaleDays = 90,\n    [int]$MinRamGB = 8,\n    [switch]$NoCsv\n)\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = \u0027Stop\u0027\n\n# Resolve script root (handles -File invocation where $PSScriptRoot may be empty)\n$ScriptDir = $PSScriptRoot\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\n    $ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition\n}\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\n    $ScriptDir = $PWD.Path\n}\n\n# Default OutputFile if not specified\nif ([string]::IsNullOrWhiteSpace($OutputFile)) {\n    $OutputFile = Join-Path -Path $ScriptDir -ChildPath \u0027PC_Inventory_Master.csv\u0027\n}\n\n# ============================================================================\n# HELPER FUNCTIONS - COLLECTION\n# ============================================================================\n\nfunction Clean-Cell {\n    param([AllowNull()][string]$Text)\n    if ($null -eq $Text) { return \u0027\u0027 }\n    return ($Text -replace \"(`r`n|`n|`r|`t)+\", \u0027 \u0027).Trim()\n}\n\nfunction Convert-UShortArrayToString {\n    param([AllowNull()]$Arr)\n    if ($null -eq $Arr) { return \u0027\u0027 }\n    $chars = foreach ($x in $Arr) {\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\n    }\n    return ( -join $chars ).Trim()\n}\n\nfunction Get-MonitorInventory {\n    \u003c#\n      Preferred: root\\wmi:WmiMonitorID (easy, consistent, usually no admin)\n      Fallback: registry EDID decode under HKLM:\\SYSTEM\\CCS\\Enum\\DISPLAY\n    #\u003e\n\n    $results = New-Object System.Collections.Generic.List[string]\n\n    # --- Preferred path: WmiMonitorID ---\n    try {\n        $wmiMons = Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorID -ErrorAction Stop\n        foreach ($m in $wmiMons) {\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\n\n            $label = @()\n            if ($mfg)  { $label += $mfg }\n            if ($name) { $label += $name }\n\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\n            $serialPart  = if ($sn) { \"SN:$sn\" } else { \u0027SN:(none)\u0027 }\n\n            $results.Add(\"$displayName ($serialPart)\")\n        }\n    } catch {\n        # WmiMonitorID not available; fall through to EDID fallback\n    }\n\n    if ($results.Count -gt 0) {\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n    }\n\n    # --- Fallback path: registry EDID decode ---\n    function Get-EdidDescriptorString {\n        param(\n            [byte[]]$Edid,\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\n        )\n\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\n\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\n\n        foreach ($offset in 54,72,90,108) {\n            if (($offset + 18) -gt $Edid.Length) { continue }\n\n            # Descriptor: 00 00 00 {tag} 00 ...\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\n\n                $bytes = $Edid[($offset+5)..($offset+17)]\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\n                $text = ($text -replace \"[`0`n`r]+\", \u0027\u0027).Trim()\n                if ($text) { return $text }\n            }\n        }\n\n        return \u0027\u0027\n    }\n\n    try {\n        $root = \u0027HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\DISPLAY\u0027\n        if (Test-Path -LiteralPath $root) {\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\n                    if (Test-Path -LiteralPath $params) {\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\n                        if ($edid -is [byte[]]) {\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\n\n                            # Numeric serial (bytes 12-15 LE) sometimes present\n                            $num = [BitConverter]::ToUInt32($edid, 12)\n                            $numStr = if ($num -ne 0) { \"NUM:$num\" } else { \u0027\u0027 }\n\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\n                            $serialPart  = if ($sn) { \"SN:$sn\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\n\n                            $results.Add(\"$displayName ($serialPart)\")\n                        }\n                    }\n                }\n            }\n        }\n    } catch {\n        # EDID fallback failed silently\n    }\n\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-NetworkInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\n\n    if ($hasNetAdapter -and $hasNetIpCfg) {\n        try {\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\n            foreach ($a in $adapters) {\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\n                $ipv4 = @()\n                if ($cfg -and $cfg.IPv4Address) {\n                    $ipv4 = $cfg.IPv4Address |\n                        ForEach-Object { $_.IPAddress } |\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\n                }\n                $gw = @()\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\n                }\n\n                $parts = @()\n                $parts += (Clean-Cell $a.Name)\n                if ($a.MacAddress) { $parts += \"MAC:$($a.MacAddress)\" }\n                if ($ipv4.Count -gt 0) { $parts += (\"IPv4:\" + ($ipv4 -join \u0027;\u0027)) }\n                if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n                $items.Add(($parts -join \u0027 \u0027))\n            }\n        } catch {\n            # Fall back to CIM below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\n            Where-Object { $_.IPEnabled -eq $true }\n\n        foreach ($n in $net) {\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\n            $mac  = $n.MACAddress\n            $ips  = @()\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\n            $gw   = @()\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\n\n            $parts = @()\n            $parts += (Clean-Cell $name)\n            if ($mac) { $parts += \"MAC:$mac\" }\n            if ($ips.Count -gt 0) { $parts += (\"IP:\" + ($ips -join \u0027;\u0027)) }\n            if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n            $items.Add(($parts -join \u0027 \u0027))\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-GpuInventory {\n    $gpus = New-Object System.Collections.Generic.List[string]\n\n    # CIM GPUs\n    try {\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\n        foreach ($g in $vc) {\n            $name = Clean-Cell $g.Name\n            $pnp  = Clean-Cell $g.PNPDeviceID\n            if ($name -or $pnp) {\n                $gpus.Add((\"{0}{1}\" -f $name, $(if ($pnp) { \" [ID:$pnp]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    # Optional NVIDIA serials if nvidia-smi exists\n    try {\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\n        if ($nvsmi) {\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\n            foreach ($line in @($raw)) {\n                $t = Clean-Cell $line\n                if ($t) { $gpus.Add(\"NVIDIA $t\") }\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-DiskInventory {\n    $disks = New-Object System.Collections.Generic.List[string]\n\n    # Prefer Storage module when available\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\n    if ($hasPhysicalDisk) {\n        try {\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\n                $name = Clean-Cell $d.FriendlyName\n                $sn   = Clean-Cell $d.SerialNumber\n                $mt   = Clean-Cell ([string]$d.MediaType)\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n                $parts = @()\n                if ($name) { $parts += $name }\n                if ($sn)   { $parts += \"SN:$sn\" }\n                if ($mt)   { $parts += \"Type:$mt\" }\n                if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n            }\n        } catch {\n            # Fall back below\n        }\n    }\n\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\n            $model = Clean-Cell $d.Model\n            $sn = \u0027\u0027\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\n            $devId = Clean-Cell $d.DeviceID\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n            $parts = @()\n            if ($model) { $parts += $model }\n            if ($sn)    { $parts += \"SN:$sn\" }\n            if ($devId) { $parts += \"Dev:$devId\" }\n            if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-PciDeviceInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\n    if ($hasGetPnpDevice) {\n        try {\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\n                Where-Object { $_.InstanceId -like \u0027PCI\\*\u0027 } |\n                Sort-Object -Property Class, FriendlyName, Name\n\n            foreach ($d in $devs) {\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\n                $name = Clean-Cell $name\n                $cls  = Clean-Cell $d.Class\n                $id   = Clean-Cell $d.InstanceId\n                if ($name -or $id) {\n                    $items.Add((\"{0}{1}{2}\" -f $name, $(if ($cls) { \" [Class:$cls]\" } else { \u0027\u0027 }), $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n                }\n            }\n        } catch {\n            # Fall back below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM Win32_PnPEntity\n    try {\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\*\u0027 } |\n            Sort-Object -Property Name\n\n        foreach ($d in $devs) {\n            $name = Clean-Cell $d.Name\n            $id   = Clean-Cell $d.PNPDeviceID\n            if ($name -or $id) {\n                $items.Add((\"{0}{1}\" -f $name, $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\n# ============================================================================\n# HELPER FUNCTIONS - ANALYSIS\n# ============================================================================\n\nfunction Get-ColumnMap {\n    param([string[]]$Headers)\n\n    $map = @{\n        Hostname        = \u0027Hostname\u0027\n        User            = \u0027User\u0027\n        System_Serial   = \u0027System_Serial\u0027\n        RAM_GB          = \u0027RAM_GB\u0027\n        Monitor_Serials = \u0027Monitor_Serials\u0027\n        Scan_Date       = \u0027Scan_Date\u0027\n    }\n\n    foreach ($k in @($map.Keys)) {\n        if ($Headers -notcontains $map[$k]) {\n            $alts = switch ($k) {\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\n                default           { @() }\n            }\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\n            if ($found) { $map[$k] = $found }\n        }\n    }\n\n    return $map\n}\n\nfunction Parse-ScanDate {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    # Try common date formats\n    $formats = @(\u0027yyyy-MM-dd\u0027, \u0027yyyy-MM-dd HH:mm:ss\u0027, \u0027MM/dd/yyyy\u0027, \u0027dd/MM/yyyy\u0027)\n    foreach ($fmt in $formats) {\n        try {\n            $result = [datetime]::ParseExact($s, $fmt, [System.Globalization.CultureInfo]::InvariantCulture)\n            return $result\n        } catch {\n            # Continue to next format\n        }\n    }\n\n    # Fallback: general parse\n    try {\n        return [datetime]::Parse($s)\n    } catch {\n        return $null\n    }\n}\n\nfunction Normalize-Serial {\n    param([AllowNull()][string]$Serial)\n\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\n    $s = ($Serial.Trim())\n\n    $bad = @(\n        \u0027To Be Filled By O.E.M.\u0027,\n        \u0027To Be Filled By OEM\u0027,\n        \u0027Default string\u0027,\n        \u0027System Serial Number\u0027,\n        \u0027None\u0027,\n        \u0027N/A\u0027,\n        \u0027NA\u0027,\n        \u00270\u0027,\n        \u002700000000\u0027,\n        \u00270000000000\u0027,\n        \u00270000000000000000\u0027\n    )\n\n    if ($bad -contains $s) { return \u0027\u0027 }\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\n\n    return $s.ToUpperInvariant()\n}\n\nfunction Parse-RamGB {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    $m = [regex]::Match($s, \u0027(\\d+)(\\.\\d+)?\u0027)\n    if (-not $m.Success) { return $null }\n\n    $n = $null\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\n        return [int][math]::Round($n, 0)\n    }\n\n    return $null\n}\n\nfunction Is-MonitorMissing {\n    param([AllowNull()][string]$Value)\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\n    $t = $Value.Trim()\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\n}\n\n# ============================================================================\n# MAIN: COLLECTION\n# ============================================================================\n\nfunction Invoke-Collection {\n    param([string]$OutPath, [switch]$IncludePci)\n\n    $errors = New-Object System.Collections.Generic.List[string]\n\n    Write-Host \"`n========================================================\" -ForegroundColor Cyan\n    Write-Host \"   GATHERING HARDWARE SPECS... PLEASE WAIT\" -ForegroundColor Cyan\n    Write-Host \"========================================================\" -ForegroundColor Cyan\n\n    # --- Collect core system info ---\n    $sys  = $null\n    $bios = $null\n    $cpu  = $null\n    $os   = $null\n    $bb   = $null\n\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_ComputerSystem: $($_.Exception.Message)\") }\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\"Win32_BIOS: $($_.Exception.Message)\") }\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_Processor: $($_.Exception.Message)\") }\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_OperatingSystem: $($_.Exception.Message)\") }\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_BaseBoard: $($_.Exception.Message)\") }\n\n    # --- Derived values ---\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\n\n    $ramGB = $null\n    try {\n        if ($sys -and $sys.TotalPhysicalMemory) {\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\n        }\n    } catch {\n        $errors.Add(\"RAM calc: $($_.Exception.Message)\")\n    }\n\n    # --- Other sections ---\n    $netStr  = \u0027\u0027\n    $gpuStr  = \u0027\u0027\n    $diskStr = \u0027\u0027\n    $monStr  = \u0027\u0027\n    $pciStr  = \u0027\u0027\n\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\"Network: $($_.Exception.Message)\") }\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\"GPU: $($_.Exception.Message)\") }\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\"Disks: $($_.Exception.Message)\") }\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\"Monitors: $($_.Exception.Message)\") }\n\n    if ($IncludePci) {\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\"PCI devices: $($_.Exception.Message)\") }\n    }\n\n    # Pre-compute BIOS release date (inline try-catch not reliable in PS 5.1)\n    $biosReleaseDate = \u0027\u0027\n    try {\n        if ($bios -and $bios.ReleaseDate) {\n            $biosReleaseDate = ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027)\n        }\n    } catch {\n        $biosReleaseDate = \u0027\u0027\n    }\n\n    # --- Build record ---\n    $record = [pscustomobject]@{\n        Hostname          = Clean-Cell $hostname\n        User              = Clean-Cell $env:USERNAME\n\n        Make_Model        = Clean-Cell ((\"{0} {1}\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\n\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\n        Baseboard_Product = Clean-Cell ($bb.Product)\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\n\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\n        BIOS_ReleaseDate  = Clean-Cell $biosReleaseDate\n\n        OS_Caption        = Clean-Cell ($os.Caption)\n        OS_Version        = Clean-Cell ($os.Version)\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\n\n        CPU               = Clean-Cell ($cpu.Name)\n        RAM_GB            = $ramGB\n\n        Network_Adapters  = Clean-Cell $netStr\n        GPUs              = Clean-Cell $gpuStr\n        Disk_Serials      = Clean-Cell $diskStr\n        Monitor_Serials   = Clean-Cell $monStr\n\n        PCI_Devices       = Clean-Cell $pciStr\n\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\n        Collector_Version = \u00272.0\u0027\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\n    }\n\n    # --- CSV append with header safety ---\n    $needHeader = $true\n    if (Test-Path -LiteralPath $OutPath) {\n        try {\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\n            if ($fi.Length -gt 0) { $needHeader = $false }\n        } catch { $needHeader = $true }\n    }\n\n    if ($needHeader) {\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\n    } else {\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\n    }\n\n    Write-Host \"`nSUCCESS!\" -ForegroundColor Green\n    Write-Host \"Data saved to: $OutPath\" -ForegroundColor Gray\n    if ($record.Errors) {\n        Write-Host (\"Warnings captured in Errors column: {0}\" -f $record.Errors) -ForegroundColor Yellow\n    }\n}\n\n# ============================================================================\n# MAIN: ANALYSIS\n# ============================================================================\n\nfunction Invoke-Analysis {\n    param(\n        [string]$InputPath,\n        [int]$StaleDaysThreshold,\n        [int]$MinRam,\n        [switch]$SkipCsv,\n        [string]$BaseDir\n    )\n\n    $ReportFile = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.txt\u0027\n    $IssuesCsv  = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.csv\u0027\n\n    if (-not (Test-Path -LiteralPath $InputPath)) {\n        Write-Warning \"Input file not found: $InputPath\"\n        Write-Warning \"Run the script without -AnalyzeOnly first to collect data.\"\n        return\n    }\n\n    $raw = Import-Csv -LiteralPath $InputPath\n    if (-not $raw -or $raw.Count -eq 0) {\n        Write-Warning \"Input file contains no rows: $InputPath\"\n        return\n    }\n\n    $headers = @()\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\n    $col = Get-ColumnMap -Headers $headers\n\n    $today = Get-Date\n\n    # Normalize data and add helper properties\n    $data = foreach ($r in $raw) {\n        $hostname = if (@($r.PSObject.Properties.Match($col.Hostname)).Count -gt 0) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\n        $user     = if (@($r.PSObject.Properties.Match($col.User)).Count -gt 0)     { [string]$r.($col.User) } else { \u0027\u0027 }\n        $serial   = if (@($r.PSObject.Properties.Match($col.System_Serial)).Count -gt 0) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\n        $ram      = if (@($r.PSObject.Properties.Match($col.RAM_GB)).Count -gt 0)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\n        $mon      = if (@($r.PSObject.Properties.Match($col.Monitor_Serials)).Count -gt 0) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\n        $scan     = if (@($r.PSObject.Properties.Match($col.Scan_Date)).Count -gt 0) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\n\n        $serialN = Normalize-Serial $serial\n        $scanDt  = Parse-ScanDate $scan\n        $ramGb   = Parse-RamGB $ram\n\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\n\n        # Asset key: prefer System Serial, fallback to Hostname\n        $assetKey = \u0027\u0027\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\n            $assetKey = $serialN\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\n            $assetKey = $h.Trim().ToUpperInvariant()\n        }\n\n        [pscustomobject]@{\n            Hostname        = $h.Trim()\n            User            = $u.Trim()\n            System_Serial   = $serialN\n            RAM_GB          = $ramGb\n            Monitor_Serials = $m.Trim()\n            Scan_Date       = $s.Trim()\n\n            ScanDateParsed  = $scanDt\n            AssetKey        = $assetKey\n            RawRow          = $r\n        }\n    }\n\n    # Latest record per asset\n    $latestByAsset = $data |\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\n        Group-Object -Property AssetKey |\n        ForEach-Object { $_.Group | Select-Object -First 1 }\n\n    $issues = New-Object System.Collections.Generic.List[object]\n\n    function Add-Issue {\n        param(\n            [Parameter(Mandatory)][string]$IssueType,\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\n            [string]$AssetKey,\n            [string]$Hostname,\n            [string]$User,\n            [string]$SystemSerial,\n            [string]$ScanDate,\n            [string]$Details\n        )\n\n        $issues.Add([pscustomobject]@{\n            IssueType     = $IssueType\n            Severity      = $Severity\n            AssetKey      = $AssetKey\n            Hostname      = $Hostname\n            User          = $User\n            System_Serial = $SystemSerial\n            Scan_Date     = $ScanDate\n            Details       = $Details\n        })\n    }\n\n    # 0) Data quality (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\n        }\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\n        }\n        if (-not $pc.ScanDateParsed) {\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\n        }\n    }\n\n    # 1) Duplicate serials (all rows; ignore blanks)\n    $dupeGroups = $data |\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\n        Group-Object -Property System_Serial |\n        Where-Object { $_.Count -gt 1 }\n\n    foreach ($g in $dupeGroups) {\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\n\n        $severity =\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\n            else { \u0027Info\u0027 }\n\n        $entries = $g.Group |\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\n            ForEach-Object {\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\n                \"{0} ({1})\" -f $_.Hostname, $d\n            }\n\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\n    }\n\n    # 2) Low RAM (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\"RAM_GB={0} (min {1})\" -f $pc.RAM_GB, $MinRam)\n        } elseif ($null -eq $pc.RAM_GB) {\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\n        }\n    }\n\n    # 3) Stale assets (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ($pc.ScanDateParsed) {\n            $ageDays = ($today - $pc.ScanDateParsed).Days\n            if ($ageDays -gt $StaleDaysThreshold) {\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\"Last seen {0} days ago (threshold {1})\" -f $ageDays, $StaleDaysThreshold)\n            }\n        }\n    }\n\n    # 4) Missing monitor serials (latest records)\n    foreach ($pc in $latestByAsset) {\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\n        }\n    }\n\n    # --- Build text report ---\n    $generated = Get-Date\n    $line = (\u0027=\u0027 * 70)\n\n    $txt = New-Object System.Collections.Generic.List[string]\n    $txt.Add($line)\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\n    $txt.Add(\"Generated: $generated\")\n    $txt.Add(\"Input:     $InputPath\")\n    $txt.Add((\"Assets:    {0} (latest per asset)\" -f @($latestByAsset).Count))\n    $txt.Add((\"Rows:      {0} (raw rows in CSV)\" -f @($data).Count))\n    $txt.Add((\"Settings:  MinRamGB={0}, StaleDays={1}\" -f $MinRam, $StaleDaysThreshold))\n    $txt.Add($line)\n    $txt.Add(\u0027\u0027)\n\n    if ($issues.Count -eq 0) {\n        $txt.Add(\u0027No issues found.\u0027)\n    } else {\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\n        foreach ($t in $byType) {\n            $txt.Add((\"--- {0} ({1}) ---\" -f $t.Name, $t.Count))\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\n\n                $txt.Add((\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\n            }\n            $txt.Add(\u0027\u0027)\n        }\n    }\n\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\n\n    if (-not $SkipCsv) {\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\n    }\n\n    # --- Console summary ---\n    Write-Host \"`n$line\" -ForegroundColor Cyan\n    Write-Host (\"Report saved: {0}\" -f $ReportFile) -ForegroundColor Green\n    if (-not $SkipCsv) { Write-Host (\"Issues CSV:   {0}\" -f $IssuesCsv) -ForegroundColor Green }\n    Write-Host (\"Issues found: {0}\" -f $issues.Count) -ForegroundColor Yellow\n    Write-Host $line -ForegroundColor Cyan\n\n    if ($issues.Count -gt 0) {\n        $sev = $issues | Group-Object Severity | Sort-Object Name\n        foreach ($s in $sev) {\n            $c = switch ($s.Name) {\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\n                default    { [ConsoleColor]::Gray }\n            }\n            Write-Host (\"{0}: {1}\" -f $s.Name, $s.Count) -ForegroundColor $c\n        }\n    }\n}\n\n# ============================================================================\n# ENTRY POINT\n# ============================================================================\n\nif (-not $AnalyzeOnly) {\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\n}\n\nif ($Analyze -or $AnalyzeOnly) {\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv -BaseDir $ScriptDir\n}\n\nif (-not $AnalyzeOnly -and -not $Analyze) {\n    Write-Host \"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\" -ForegroundColor DarkGray\n}\n\n","languageId":"powershell"}],"capabilityType":15,"toolFormerData":{"tool":38,"toolCallId":"toolu_vrtx_01HbhW9szhDzEgm1pU8RPsz9","toolIndex":1,"modelCallId":"f6cbb926-bce6-4832-b548-4e8671da45e1","status":"completed","rawArgs":"{\"file_path\": \"USB-Inventory.ps1\", \"old_string\": \"    $txt.Add(\\\"Input:     $InputPath\\\")\\n    $txt.Add((\\\"Assets:    {0} (latest per asset)\\\" -f $latestByAsset.Count))\\n    $txt.Add((\\\"Rows:      {0} (raw rows in CSV)\\\" -f $data.Count))\", \"new_string\": \"    $txt.Add(\\\"Input:     $InputPath\\\")\\n    $txt.Add((\\\"Assets:    {0} (latest per asset)\\\" -f @($latestByAsset).Count))\\n    $txt.Add((\\\"Rows:      {0} (raw rows in CSV)\\\" -f @($data).Count))\"}","name":"search_replace","params":"{\"relativeWorkspacePath\":\"USB-Inventory.ps1\"}","additionalData":{"codeblockId":"686d945b-6d8a-4978-9283-3c2a8a6b4c12"},"userDecision":"accepted","result":"{\"diff\":{\"chunks\":[{\"diffString\":\"      $txt.Add(\\\"Generated: $generated\\\")\\n      $txt.Add(\\\"Input:     $InputPath\\\")\\n-     $txt.Add((\\\"Assets:    {0} (latest per asset)\\\" -f $latestByAsset.Count))\\n-     $txt.Add((\\\"Rows:      {0} (raw rows in CSV)\\\" -f $data.Count))\\n+     $txt.Add((\\\"Assets:    {0} (latest per asset)\\\" -f @($latestByAsset).Count))\\n+     $txt.Add((\\\"Rows:      {0} (raw rows in CSV)\\\" -f @($data).Count))\\n      $txt.Add((\\\"Settings:  MinRamGB={0}, StaleDays={1}\\\" -f $MinRam, $StaleDaysThreshold))\\n      $txt.Add($line)\",\"oldStart\":799,\"newStart\":799,\"oldLines\":6,\"newLines\":6,\"linesRemoved\":2,\"linesAdded\":2}],\"editor\":\"EDITOR_AI\"},\"shouldAutoFixLints\":true,\"resultForModel\":\"The file USB-Inventory.ps1 has been updated.\",\"contentsAfterEdit\":\"#requires -Version 5.1\\n\u003c#\\n.SYNOPSIS\\n    USB-portable PC hardware inventory collection and analysis tool.\\n\\n.DESCRIPTION\\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\\n    script. Optionally runs health analysis to detect duplicates, stale assets,\\n    low RAM, and missing monitor data.\\n\\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\\n\\n.PARAMETER OutputFile\\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\\n\\n.PARAMETER IncludePciDevices\\n    Include detailed PCI device enumeration (can produce large output).\\n\\n.PARAMETER Analyze\\n    After collection, run health analysis on the CSV file.\\n\\n.PARAMETER AnalyzeOnly\\n    Skip collection; only run health analysis on existing CSV.\\n\\n.PARAMETER StaleDays\\n    Threshold in days for flagging stale assets. Default: 90.\\n\\n.PARAMETER MinRamGB\\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\\n\\n.PARAMETER NoCsv\\n    Do not output Inventory_Issues_Report.csv (text report only).\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1\\n    Collect inventory from this PC into PC_Inventory_Master.csv.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -IncludePciDevices -Analyze\\n    Collect inventory with PCI devices, then run health analysis.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\\n    Analyze existing CSV with custom thresholds (no new collection).\\n#\u003e\\n\\n[CmdletBinding()]\\nparam(\\n    [string]$OutputFile,\\n    [switch]$IncludePciDevices,\\n    [switch]$Analyze,\\n    [switch]$AnalyzeOnly,\\n    [int]$StaleDays = 90,\\n    [int]$MinRamGB = 8,\\n    [switch]$NoCsv\\n)\\n\\nSet-StrictMode -Version Latest\\n$ErrorActionPreference = \u0027Stop\u0027\\n\\n# Resolve script root (handles -File invocation where $PSScriptRoot may be empty)\\n$ScriptDir = $PSScriptRoot\\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n    $ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition\\n}\\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n    $ScriptDir = $PWD.Path\\n}\\n\\n# Default OutputFile if not specified\\nif ([string]::IsNullOrWhiteSpace($OutputFile)) {\\n    $OutputFile = Join-Path -Path $ScriptDir -ChildPath \u0027PC_Inventory_Master.csv\u0027\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - COLLECTION\\n# ============================================================================\\n\\nfunction Clean-Cell {\\n    param([AllowNull()][string]$Text)\\n    if ($null -eq $Text) { return \u0027\u0027 }\\n    return ($Text -replace \\\"(`r`n|`n|`r|`t)+\\\", \u0027 \u0027).Trim()\\n}\\n\\nfunction Convert-UShortArrayToString {\\n    param([AllowNull()]$Arr)\\n    if ($null -eq $Arr) { return \u0027\u0027 }\\n    $chars = foreach ($x in $Arr) {\\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\\n    }\\n    return ( -join $chars ).Trim()\\n}\\n\\nfunction Get-MonitorInventory {\\n    \u003c#\\n      Preferred: root\\\\wmi:WmiMonitorID (easy, consistent, usually no admin)\\n      Fallback: registry EDID decode under HKLM:\\\\SYSTEM\\\\CCS\\\\Enum\\\\DISPLAY\\n    #\u003e\\n\\n    $results = New-Object System.Collections.Generic.List[string]\\n\\n    # --- Preferred path: WmiMonitorID ---\\n    try {\\n        $wmiMons = Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorID -ErrorAction Stop\\n        foreach ($m in $wmiMons) {\\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\\n\\n            $label = @()\\n            if ($mfg)  { $label += $mfg }\\n            if ($name) { $label += $name }\\n\\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\\n            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } else { \u0027SN:(none)\u0027 }\\n\\n            $results.Add(\\\"$displayName ($serialPart)\\\")\\n        }\\n    } catch {\\n        # WmiMonitorID not available; fall through to EDID fallback\\n    }\\n\\n    if ($results.Count -gt 0) {\\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n    }\\n\\n    # --- Fallback path: registry EDID decode ---\\n    function Get-EdidDescriptorString {\\n        param(\\n            [byte[]]$Edid,\\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\\n        )\\n\\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\\n\\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\\n\\n        foreach ($offset in 54,72,90,108) {\\n            if (($offset + 18) -gt $Edid.Length) { continue }\\n\\n            # Descriptor: 00 00 00 {tag} 00 ...\\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\\n\\n                $bytes = $Edid[($offset+5)..($offset+17)]\\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\\n                $text = ($text -replace \\\"[`0`n`r]+\\\", \u0027\u0027).Trim()\\n                if ($text) { return $text }\\n            }\\n        }\\n\\n        return \u0027\u0027\\n    }\\n\\n    try {\\n        $root = \u0027HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Enum\\\\DISPLAY\u0027\\n        if (Test-Path -LiteralPath $root) {\\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\\n                    if (Test-Path -LiteralPath $params) {\\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\\n                        if ($edid -is [byte[]]) {\\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\\n\\n                            # Numeric serial (bytes 12-15 LE) sometimes present\\n                            $num = [BitConverter]::ToUInt32($edid, 12)\\n                            $numStr = if ($num -ne 0) { \\\"NUM:$num\\\" } else { \u0027\u0027 }\\n\\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\\n                            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\\n\\n                            $results.Add(\\\"$displayName ($serialPart)\\\")\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    } catch {\\n        # EDID fallback failed silently\\n    }\\n\\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-NetworkInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\\n\\n    if ($hasNetAdapter -and $hasNetIpCfg) {\\n        try {\\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\\n            foreach ($a in $adapters) {\\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\\n                $ipv4 = @()\\n                if ($cfg -and $cfg.IPv4Address) {\\n                    $ipv4 = $cfg.IPv4Address |\\n                        ForEach-Object { $_.IPAddress } |\\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\\n                }\\n                $gw = @()\\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\\n                }\\n\\n                $parts = @()\\n                $parts += (Clean-Cell $a.Name)\\n                if ($a.MacAddress) { $parts += \\\"MAC:$($a.MacAddress)\\\" }\\n                if ($ipv4.Count -gt 0) { $parts += (\\\"IPv4:\\\" + ($ipv4 -join \u0027;\u0027)) }\\n                if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n                $items.Add(($parts -join \u0027 \u0027))\\n            }\\n        } catch {\\n            # Fall back to CIM below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\\n            Where-Object { $_.IPEnabled -eq $true }\\n\\n        foreach ($n in $net) {\\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\\n            $mac  = $n.MACAddress\\n            $ips  = @()\\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\\n            $gw   = @()\\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\\n\\n            $parts = @()\\n            $parts += (Clean-Cell $name)\\n            if ($mac) { $parts += \\\"MAC:$mac\\\" }\\n            if ($ips.Count -gt 0) { $parts += (\\\"IP:\\\" + ($ips -join \u0027;\u0027)) }\\n            if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n            $items.Add(($parts -join \u0027 \u0027))\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-GpuInventory {\\n    $gpus = New-Object System.Collections.Generic.List[string]\\n\\n    # CIM GPUs\\n    try {\\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\\n        foreach ($g in $vc) {\\n            $name = Clean-Cell $g.Name\\n            $pnp  = Clean-Cell $g.PNPDeviceID\\n            if ($name -or $pnp) {\\n                $gpus.Add((\\\"{0}{1}\\\" -f $name, $(if ($pnp) { \\\" [ID:$pnp]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    # Optional NVIDIA serials if nvidia-smi exists\\n    try {\\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\\n        if ($nvsmi) {\\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\\n            foreach ($line in @($raw)) {\\n                $t = Clean-Cell $line\\n                if ($t) { $gpus.Add(\\\"NVIDIA $t\\\") }\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-DiskInventory {\\n    $disks = New-Object System.Collections.Generic.List[string]\\n\\n    # Prefer Storage module when available\\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasPhysicalDisk) {\\n        try {\\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\\n                $name = Clean-Cell $d.FriendlyName\\n                $sn   = Clean-Cell $d.SerialNumber\\n                $mt   = Clean-Cell ([string]$d.MediaType)\\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n                $parts = @()\\n                if ($name) { $parts += $name }\\n                if ($sn)   { $parts += \\\"SN:$sn\\\" }\\n                if ($mt)   { $parts += \\\"Type:$mt\\\" }\\n                if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\\n            $model = Clean-Cell $d.Model\\n            $sn = \u0027\u0027\\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\\n            $devId = Clean-Cell $d.DeviceID\\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n            $parts = @()\\n            if ($model) { $parts += $model }\\n            if ($sn)    { $parts += \\\"SN:$sn\\\" }\\n            if ($devId) { $parts += \\\"Dev:$devId\\\" }\\n            if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-PciDeviceInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasGetPnpDevice) {\\n        try {\\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\\n                Where-Object { $_.InstanceId -like \u0027PCI\\\\*\u0027 } |\\n                Sort-Object -Property Class, FriendlyName, Name\\n\\n            foreach ($d in $devs) {\\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\\n                $name = Clean-Cell $name\\n                $cls  = Clean-Cell $d.Class\\n                $id   = Clean-Cell $d.InstanceId\\n                if ($name -or $id) {\\n                    $items.Add((\\\"{0}{1}{2}\\\" -f $name, $(if ($cls) { \\\" [Class:$cls]\\\" } else { \u0027\u0027 }), $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n                }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM Win32_PnPEntity\\n    try {\\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\\\*\u0027 } |\\n            Sort-Object -Property Name\\n\\n        foreach ($d in $devs) {\\n            $name = Clean-Cell $d.Name\\n            $id   = Clean-Cell $d.PNPDeviceID\\n            if ($name -or $id) {\\n                $items.Add((\\\"{0}{1}\\\" -f $name, $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - ANALYSIS\\n# ============================================================================\\n\\nfunction Get-ColumnMap {\\n    param([string[]]$Headers)\\n\\n    $map = @{\\n        Hostname        = \u0027Hostname\u0027\\n        User            = \u0027User\u0027\\n        System_Serial   = \u0027System_Serial\u0027\\n        RAM_GB          = \u0027RAM_GB\u0027\\n        Monitor_Serials = \u0027Monitor_Serials\u0027\\n        Scan_Date       = \u0027Scan_Date\u0027\\n    }\\n\\n    foreach ($k in @($map.Keys)) {\\n        if ($Headers -notcontains $map[$k]) {\\n            $alts = switch ($k) {\\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\\n                default           { @() }\\n            }\\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\\n            if ($found) { $map[$k] = $found }\\n        }\\n    }\\n\\n    return $map\\n}\\n\\nfunction Parse-ScanDate {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    # Try common date formats\\n    $formats = @(\u0027yyyy-MM-dd\u0027, \u0027yyyy-MM-dd HH:mm:ss\u0027, \u0027MM/dd/yyyy\u0027, \u0027dd/MM/yyyy\u0027)\\n    foreach ($fmt in $formats) {\\n        try {\\n            $result = [datetime]::ParseExact($s, $fmt, [System.Globalization.CultureInfo]::InvariantCulture)\\n            return $result\\n        } catch {\\n            # Continue to next format\\n        }\\n    }\\n\\n    # Fallback: general parse\\n    try {\\n        return [datetime]::Parse($s)\\n    } catch {\\n        return $null\\n    }\\n}\\n\\nfunction Normalize-Serial {\\n    param([AllowNull()][string]$Serial)\\n\\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\\n    $s = ($Serial.Trim())\\n\\n    $bad = @(\\n        \u0027To Be Filled By O.E.M.\u0027,\\n        \u0027To Be Filled By OEM\u0027,\\n        \u0027Default string\u0027,\\n        \u0027System Serial Number\u0027,\\n        \u0027None\u0027,\\n        \u0027N/A\u0027,\\n        \u0027NA\u0027,\\n        \u00270\u0027,\\n        \u002700000000\u0027,\\n        \u00270000000000\u0027,\\n        \u00270000000000000000\u0027\\n    )\\n\\n    if ($bad -contains $s) { return \u0027\u0027 }\\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\\n\\n    return $s.ToUpperInvariant()\\n}\\n\\nfunction Parse-RamGB {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    $m = [regex]::Match($s, \u0027(\\\\d+)(\\\\.\\\\d+)?\u0027)\\n    if (-not $m.Success) { return $null }\\n\\n    $n = $null\\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\\n        return [int][math]::Round($n, 0)\\n    }\\n\\n    return $null\\n}\\n\\nfunction Is-MonitorMissing {\\n    param([AllowNull()][string]$Value)\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\\n    $t = $Value.Trim()\\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\\n}\\n\\n# ============================================================================\\n# MAIN: COLLECTION\\n# ============================================================================\\n\\nfunction Invoke-Collection {\\n    param([string]$OutPath, [switch]$IncludePci)\\n\\n    $errors = New-Object System.Collections.Generic.List[string]\\n\\n    Write-Host \\\"`n========================================================\\\" -ForegroundColor Cyan\\n    Write-Host \\\"   GATHERING HARDWARE SPECS... PLEASE WAIT\\\" -ForegroundColor Cyan\\n    Write-Host \\\"========================================================\\\" -ForegroundColor Cyan\\n\\n    # --- Collect core system info ---\\n    $sys  = $null\\n    $bios = $null\\n    $cpu  = $null\\n    $os   = $null\\n    $bb   = $null\\n\\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_ComputerSystem: $($_.Exception.Message)\\\") }\\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\\\"Win32_BIOS: $($_.Exception.Message)\\\") }\\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_Processor: $($_.Exception.Message)\\\") }\\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_OperatingSystem: $($_.Exception.Message)\\\") }\\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_BaseBoard: $($_.Exception.Message)\\\") }\\n\\n    # --- Derived values ---\\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\\n\\n    $ramGB = $null\\n    try {\\n        if ($sys -and $sys.TotalPhysicalMemory) {\\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\\n        }\\n    } catch {\\n        $errors.Add(\\\"RAM calc: $($_.Exception.Message)\\\")\\n    }\\n\\n    # --- Other sections ---\\n    $netStr  = \u0027\u0027\\n    $gpuStr  = \u0027\u0027\\n    $diskStr = \u0027\u0027\\n    $monStr  = \u0027\u0027\\n    $pciStr  = \u0027\u0027\\n\\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\\\"Network: $($_.Exception.Message)\\\") }\\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\\\"GPU: $($_.Exception.Message)\\\") }\\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\\\"Disks: $($_.Exception.Message)\\\") }\\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\\\"Monitors: $($_.Exception.Message)\\\") }\\n\\n    if ($IncludePci) {\\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\\\"PCI devices: $($_.Exception.Message)\\\") }\\n    }\\n\\n    # Pre-compute BIOS release date (inline try-catch not reliable in PS 5.1)\\n    $biosReleaseDate = \u0027\u0027\\n    try {\\n        if ($bios -and $bios.ReleaseDate) {\\n            $biosReleaseDate = ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027)\\n        }\\n    } catch {\\n        $biosReleaseDate = \u0027\u0027\\n    }\\n\\n    # --- Build record ---\\n    $record = [pscustomobject]@{\\n        Hostname          = Clean-Cell $hostname\\n        User              = Clean-Cell $env:USERNAME\\n\\n        Make_Model        = Clean-Cell ((\\\"{0} {1}\\\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\\n\\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\\n        Baseboard_Product = Clean-Cell ($bb.Product)\\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\\n\\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\\n        BIOS_ReleaseDate  = Clean-Cell $biosReleaseDate\\n\\n        OS_Caption        = Clean-Cell ($os.Caption)\\n        OS_Version        = Clean-Cell ($os.Version)\\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\\n\\n        CPU               = Clean-Cell ($cpu.Name)\\n        RAM_GB            = $ramGB\\n\\n        Network_Adapters  = Clean-Cell $netStr\\n        GPUs              = Clean-Cell $gpuStr\\n        Disk_Serials      = Clean-Cell $diskStr\\n        Monitor_Serials   = Clean-Cell $monStr\\n\\n        PCI_Devices       = Clean-Cell $pciStr\\n\\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\\n        Collector_Version = \u00272.0\u0027\\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\\n    }\\n\\n    # --- CSV append with header safety ---\\n    $needHeader = $true\\n    if (Test-Path -LiteralPath $OutPath) {\\n        try {\\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\\n            if ($fi.Length -gt 0) { $needHeader = $false }\\n        } catch { $needHeader = $true }\\n    }\\n\\n    if ($needHeader) {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\\n    } else {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\\n    }\\n\\n    Write-Host \\\"`nSUCCESS!\\\" -ForegroundColor Green\\n    Write-Host \\\"Data saved to: $OutPath\\\" -ForegroundColor Gray\\n    if ($record.Errors) {\\n        Write-Host (\\\"Warnings captured in Errors column: {0}\\\" -f $record.Errors) -ForegroundColor Yellow\\n    }\\n}\\n\\n# ============================================================================\\n# MAIN: ANALYSIS\\n# ============================================================================\\n\\nfunction Invoke-Analysis {\\n    param(\\n        [string]$InputPath,\\n        [int]$StaleDaysThreshold,\\n        [int]$MinRam,\\n        [switch]$SkipCsv,\\n        [string]$BaseDir\\n    )\\n\\n    $ReportFile = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.txt\u0027\\n    $IssuesCsv  = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.csv\u0027\\n\\n    if (-not (Test-Path -LiteralPath $InputPath)) {\\n        Write-Warning \\\"Input file not found: $InputPath\\\"\\n        Write-Warning \\\"Run the script without -AnalyzeOnly first to collect data.\\\"\\n        return\\n    }\\n\\n    $raw = Import-Csv -LiteralPath $InputPath\\n    if (-not $raw -or $raw.Count -eq 0) {\\n        Write-Warning \\\"Input file contains no rows: $InputPath\\\"\\n        return\\n    }\\n\\n    $headers = @()\\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\\n    $col = Get-ColumnMap -Headers $headers\\n\\n    $today = Get-Date\\n\\n    # Normalize data and add helper properties\\n    $data = foreach ($r in $raw) {\\n        $hostname = if (@($r.PSObject.Properties.Match($col.Hostname)).Count -gt 0) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\\n        $user     = if (@($r.PSObject.Properties.Match($col.User)).Count -gt 0)     { [string]$r.($col.User) } else { \u0027\u0027 }\\n        $serial   = if (@($r.PSObject.Properties.Match($col.System_Serial)).Count -gt 0) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\\n        $ram      = if (@($r.PSObject.Properties.Match($col.RAM_GB)).Count -gt 0)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\\n        $mon      = if (@($r.PSObject.Properties.Match($col.Monitor_Serials)).Count -gt 0) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\\n        $scan     = if (@($r.PSObject.Properties.Match($col.Scan_Date)).Count -gt 0) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\\n\\n        $serialN = Normalize-Serial $serial\\n        $scanDt  = Parse-ScanDate $scan\\n        $ramGb   = Parse-RamGB $ram\\n\\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\\n\\n        # Asset key: prefer System Serial, fallback to Hostname\\n        $assetKey = \u0027\u0027\\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\\n            $assetKey = $serialN\\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\\n            $assetKey = $h.Trim().ToUpperInvariant()\\n        }\\n\\n        [pscustomobject]@{\\n            Hostname        = $h.Trim()\\n            User            = $u.Trim()\\n            System_Serial   = $serialN\\n            RAM_GB          = $ramGb\\n            Monitor_Serials = $m.Trim()\\n            Scan_Date       = $s.Trim()\\n\\n            ScanDateParsed  = $scanDt\\n            AssetKey        = $assetKey\\n            RawRow          = $r\\n        }\\n    }\\n\\n    # Latest record per asset\\n    $latestByAsset = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\\n        Group-Object -Property AssetKey |\\n        ForEach-Object { $_.Group | Select-Object -First 1 }\\n\\n    $issues = New-Object System.Collections.Generic.List[object]\\n\\n    function Add-Issue {\\n        param(\\n            [Parameter(Mandatory)][string]$IssueType,\\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\\n            [string]$AssetKey,\\n            [string]$Hostname,\\n            [string]$User,\\n            [string]$SystemSerial,\\n            [string]$ScanDate,\\n            [string]$Details\\n        )\\n\\n        $issues.Add([pscustomobject]@{\\n            IssueType     = $IssueType\\n            Severity      = $Severity\\n            AssetKey      = $AssetKey\\n            Hostname      = $Hostname\\n            User          = $User\\n            System_Serial = $SystemSerial\\n            Scan_Date     = $ScanDate\\n            Details       = $Details\\n        })\\n    }\\n\\n    # 0) Data quality (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\\n        }\\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\\n        }\\n        if (-not $pc.ScanDateParsed) {\\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\\n        }\\n    }\\n\\n    # 1) Duplicate serials (all rows; ignore blanks)\\n    $dupeGroups = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\\n        Group-Object -Property System_Serial |\\n        Where-Object { $_.Count -gt 1 }\\n\\n    foreach ($g in $dupeGroups) {\\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\\n\\n        $severity =\\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\\n            else { \u0027Info\u0027 }\\n\\n        $entries = $g.Group |\\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\\n            ForEach-Object {\\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\\n                \\\"{0} ({1})\\\" -f $_.Hostname, $d\\n            }\\n\\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\\\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\\\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\\n    }\\n\\n    # 2) Low RAM (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\\\"RAM_GB={0} (min {1})\\\" -f $pc.RAM_GB, $MinRam)\\n        } elseif ($null -eq $pc.RAM_GB) {\\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\\n        }\\n    }\\n\\n    # 3) Stale assets (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($pc.ScanDateParsed) {\\n            $ageDays = ($today - $pc.ScanDateParsed).Days\\n            if ($ageDays -gt $StaleDaysThreshold) {\\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\\\"Last seen {0} days ago (threshold {1})\\\" -f $ageDays, $StaleDaysThreshold)\\n            }\\n        }\\n    }\\n\\n    # 4) Missing monitor serials (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\\n        }\\n    }\\n\\n    # --- Build text report ---\\n    $generated = Get-Date\\n    $line = (\u0027=\u0027 * 70)\\n\\n    $txt = New-Object System.Collections.Generic.List[string]\\n    $txt.Add($line)\\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\\n    $txt.Add(\\\"Generated: $generated\\\")\\n    $txt.Add(\\\"Input:     $InputPath\\\")\\n    $txt.Add((\\\"Assets:    {0} (latest per asset)\\\" -f @($latestByAsset).Count))\\n    $txt.Add((\\\"Rows:      {0} (raw rows in CSV)\\\" -f @($data).Count))\\n    $txt.Add((\\\"Settings:  MinRamGB={0}, StaleDays={1}\\\" -f $MinRam, $StaleDaysThreshold))\\n    $txt.Add($line)\\n    $txt.Add(\u0027\u0027)\\n\\n    if ($issues.Count -eq 0) {\\n        $txt.Add(\u0027No issues found.\u0027)\\n    } else {\\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\\n        foreach ($t in $byType) {\\n            $txt.Add((\\\"--- {0} ({1}) ---\\\" -f $t.Name, $t.Count))\\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\\n\\n                $txt.Add((\\\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\\\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\\n            }\\n            $txt.Add(\u0027\u0027)\\n        }\\n    }\\n\\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\\n\\n    if (-not $SkipCsv) {\\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\\n    }\\n\\n    # --- Console summary ---\\n    Write-Host \\\"`n$line\\\" -ForegroundColor Cyan\\n    Write-Host (\\\"Report saved: {0}\\\" -f $ReportFile) -ForegroundColor Green\\n    if (-not $SkipCsv) { Write-Host (\\\"Issues CSV:   {0}\\\" -f $IssuesCsv) -ForegroundColor Green }\\n    Write-Host (\\\"Issues found: {0}\\\" -f $issues.Count) -ForegroundColor Yellow\\n    Write-Host $line -ForegroundColor Cyan\\n\\n    if ($issues.Count -gt 0) {\\n        $sev = $issues | Group-Object Severity | Sort-Object Name\\n        foreach ($s in $sev) {\\n            $c = switch ($s.Name) {\\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\\n                default    { [ConsoleColor]::Gray }\\n            }\\n            Write-Host (\\\"{0}: {1}\\\" -f $s.Name, $s.Count) -ForegroundColor $c\\n        }\\n    }\\n}\\n\\n# ============================================================================\\n# ENTRY POINT\\n# ============================================================================\\n\\nif (-not $AnalyzeOnly) {\\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\\n}\\n\\nif ($Analyze -or $AnalyzeOnly) {\\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv -BaseDir $ScriptDir\\n}\\n\\nif (-not $AnalyzeOnly -and -not $Analyze) {\\n    Write-Host \\\"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\\\" -ForegroundColor DarkGray\\n}\\n\\n\"}"},"checkpointId":"f75bdd1e-b2ad-4441-bb5d-d5248689a918"},"bubbleId":"c0450ca8-ef36-4aa1-a969-d4cda43ed7c3"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"c1f3a384-dbdf-4a08-8d9c-94e93d6ac1e6","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:00:11.491Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"9834a312-ae5e-47ea-9e41-56bf61ee4ab6","usageUuid":"d83eee54-96f4-4e5d-a87d-5cddffabc34d","capabilityType":30,"thinking":{"text":"Now let me test again.","signature":"EsABCkgICxACGAIqQDqnGrVWu+ELyPWOOaS4SQLuSk9N8TIU6d+2iy4MqBtiqDQVLOUltJlA+bBA3axs6h1Yp1ecUCBq0BNjcaDQqF4SDF/Fc30v/yRcIqBE9xoMkSFtSDoc03sKSLuqIjBn2uu8RaCpjt4DrrH3XukxFMPTqs8EleM/LbSGBK5LXkn/CMg0xgVKK0A3ZA/cK5IqJmWMEviJMSj5DlHpx2veeT5OEVqEkQZQYjO4AaamECAXFjw5K5vVGAE="},"thinkingStyle":1,"thinkingDurationMs":743},"bubbleId":"c1f3a384-dbdf-4a08-8d9c-94e93d6ac1e6"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"ca8b0e82-9039-4ef1-ae47-65fabd041c99","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:59:22.154Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"The `$PSScriptRoot` is empty when run via `powershell -File` from the command line. Let me fix that:","usageUuid":"bdd3d57c-9e19-4d02-b932-ab4804ad6503","symbolLinks":["{\"symbolName\":\"powershell -File\",\"symbolSearchString\":\"powershell\",\"relativeWorkspacePath\":\"c:\\\\Users\\\\user\\\\.cursor\\\\plans\\\\usb_inventory_script_4c3f18cf.plan.md\",\"roughLineNumber\":67}"]},"bubbleId":"ca8b0e82-9039-4ef1-ae47-65fabd041c99"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"cb319736-5999-43ab-a1a5-f797fe6fea9b","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:00:49.274Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"1e1730f2-3378-4e5b-9f97-ac15549f1a4e","codeBlocks":[{"uri":{"scheme":"file","authority":"","path":"/c:/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1","query":"","fragment":"","_formatted":"file:///c%3A/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1","_fsPath":"c:\\Users\\user\\Downloads\\Cursor_working_directory_misc\\USB-Inventory.ps1"},"codeblockId":"6217e76c-4e58-4fe1-a14e-6e31a69962c3","codeBlockIdx":0,"content":"#requires -Version 5.1\n\u003c#\n.SYNOPSIS\n    USB-portable PC hardware inventory collection and analysis tool.\n\n.DESCRIPTION\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\n    script. Optionally runs health analysis to detect duplicates, stale assets,\n    low RAM, and missing monitor data.\n\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\n\n.PARAMETER OutputFile\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\n\n.PARAMETER IncludePciDevices\n    Include detailed PCI device enumeration (can produce large output).\n\n.PARAMETER Analyze\n    After collection, run health analysis on the CSV file.\n\n.PARAMETER AnalyzeOnly\n    Skip collection; only run health analysis on existing CSV.\n\n.PARAMETER StaleDays\n    Threshold in days for flagging stale assets. Default: 90.\n\n.PARAMETER MinRamGB\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\n\n.PARAMETER NoCsv\n    Do not output Inventory_Issues_Report.csv (text report only).\n\n.EXAMPLE\n    .\\USB-Inventory.ps1\n    Collect inventory from this PC into PC_Inventory_Master.csv.\n\n.EXAMPLE\n    .\\USB-Inventory.ps1 -IncludePciDevices -Analyze\n    Collect inventory with PCI devices, then run health analysis.\n\n.EXAMPLE\n    .\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\n    Analyze existing CSV with custom thresholds (no new collection).\n#\u003e\n\n[CmdletBinding()]\nparam(\n    [string]$OutputFile,\n    [switch]$IncludePciDevices,\n    [switch]$Analyze,\n    [switch]$AnalyzeOnly,\n    [int]$StaleDays = 90,\n    [int]$MinRamGB = 8,\n    [switch]$NoCsv\n)\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = \u0027Stop\u0027\n\n# Resolve script root (handles -File invocation where $PSScriptRoot may be empty)\n$ScriptDir = $PSScriptRoot\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\n    $ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition\n}\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\n    $ScriptDir = $PWD.Path\n}\n\n# Default OutputFile if not specified\nif ([string]::IsNullOrWhiteSpace($OutputFile)) {\n    $OutputFile = Join-Path -Path $ScriptDir -ChildPath \u0027PC_Inventory_Master.csv\u0027\n}\n\n# ============================================================================\n# HELPER FUNCTIONS - COLLECTION\n# ============================================================================\n\nfunction Clean-Cell {\n    param([AllowNull()][string]$Text)\n    if ($null -eq $Text) { return \u0027\u0027 }\n    return ($Text -replace \"(`r`n|`n|`r|`t)+\", \u0027 \u0027).Trim()\n}\n\nfunction Convert-UShortArrayToString {\n    param([AllowNull()]$Arr)\n    if ($null -eq $Arr) { return \u0027\u0027 }\n    $chars = foreach ($x in $Arr) {\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\n    }\n    return ( -join $chars ).Trim()\n}\n\nfunction Get-MonitorInventory {\n    \u003c#\n      Preferred: root\\wmi:WmiMonitorID (easy, consistent, usually no admin)\n      Fallback: registry EDID decode under HKLM:\\SYSTEM\\CCS\\Enum\\DISPLAY\n    #\u003e\n\n    $results = New-Object System.Collections.Generic.List[string]\n\n    # --- Preferred path: WmiMonitorID ---\n    try {\n        $wmiMons = Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorID -ErrorAction Stop\n        foreach ($m in $wmiMons) {\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\n\n            $label = @()\n            if ($mfg)  { $label += $mfg }\n            if ($name) { $label += $name }\n\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\n            $serialPart  = if ($sn) { \"SN:$sn\" } else { \u0027SN:(none)\u0027 }\n\n            $results.Add(\"$displayName ($serialPart)\")\n        }\n    } catch {\n        # WmiMonitorID not available; fall through to EDID fallback\n    }\n\n    if ($results.Count -gt 0) {\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n    }\n\n    # --- Fallback path: registry EDID decode ---\n    function Get-EdidDescriptorString {\n        param(\n            [byte[]]$Edid,\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\n        )\n\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\n\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\n\n        foreach ($offset in 54,72,90,108) {\n            if (($offset + 18) -gt $Edid.Length) { continue }\n\n            # Descriptor: 00 00 00 {tag} 00 ...\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\n\n                $bytes = $Edid[($offset+5)..($offset+17)]\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\n                $text = ($text -replace \"[`0`n`r]+\", \u0027\u0027).Trim()\n                if ($text) { return $text }\n            }\n        }\n\n        return \u0027\u0027\n    }\n\n    try {\n        $root = \u0027HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\DISPLAY\u0027\n        if (Test-Path -LiteralPath $root) {\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\n                    if (Test-Path -LiteralPath $params) {\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\n                        if ($edid -is [byte[]]) {\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\n\n                            # Numeric serial (bytes 12-15 LE) sometimes present\n                            $num = [BitConverter]::ToUInt32($edid, 12)\n                            $numStr = if ($num -ne 0) { \"NUM:$num\" } else { \u0027\u0027 }\n\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\n                            $serialPart  = if ($sn) { \"SN:$sn\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\n\n                            $results.Add(\"$displayName ($serialPart)\")\n                        }\n                    }\n                }\n            }\n        }\n    } catch {\n        # EDID fallback failed silently\n    }\n\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-NetworkInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\n\n    if ($hasNetAdapter -and $hasNetIpCfg) {\n        try {\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\n            foreach ($a in $adapters) {\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\n                $ipv4 = @()\n                if ($cfg -and $cfg.IPv4Address) {\n                    $ipv4 = $cfg.IPv4Address |\n                        ForEach-Object { $_.IPAddress } |\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\n                }\n                $gw = @()\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\n                }\n\n                $parts = @()\n                $parts += (Clean-Cell $a.Name)\n                if ($a.MacAddress) { $parts += \"MAC:$($a.MacAddress)\" }\n                if ($ipv4.Count -gt 0) { $parts += (\"IPv4:\" + ($ipv4 -join \u0027;\u0027)) }\n                if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n                $items.Add(($parts -join \u0027 \u0027))\n            }\n        } catch {\n            # Fall back to CIM below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\n            Where-Object { $_.IPEnabled -eq $true }\n\n        foreach ($n in $net) {\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\n            $mac  = $n.MACAddress\n            $ips  = @()\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\n            $gw   = @()\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\n\n            $parts = @()\n            $parts += (Clean-Cell $name)\n            if ($mac) { $parts += \"MAC:$mac\" }\n            if ($ips.Count -gt 0) { $parts += (\"IP:\" + ($ips -join \u0027;\u0027)) }\n            if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n            $items.Add(($parts -join \u0027 \u0027))\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-GpuInventory {\n    $gpus = New-Object System.Collections.Generic.List[string]\n\n    # CIM GPUs\n    try {\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\n        foreach ($g in $vc) {\n            $name = Clean-Cell $g.Name\n            $pnp  = Clean-Cell $g.PNPDeviceID\n            if ($name -or $pnp) {\n                $gpus.Add((\"{0}{1}\" -f $name, $(if ($pnp) { \" [ID:$pnp]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    # Optional NVIDIA serials if nvidia-smi exists\n    try {\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\n        if ($nvsmi) {\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\n            foreach ($line in @($raw)) {\n                $t = Clean-Cell $line\n                if ($t) { $gpus.Add(\"NVIDIA $t\") }\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-DiskInventory {\n    $disks = New-Object System.Collections.Generic.List[string]\n\n    # Prefer Storage module when available\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\n    if ($hasPhysicalDisk) {\n        try {\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\n                $name = Clean-Cell $d.FriendlyName\n                $sn   = Clean-Cell $d.SerialNumber\n                $mt   = Clean-Cell ([string]$d.MediaType)\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n                $parts = @()\n                if ($name) { $parts += $name }\n                if ($sn)   { $parts += \"SN:$sn\" }\n                if ($mt)   { $parts += \"Type:$mt\" }\n                if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n            }\n        } catch {\n            # Fall back below\n        }\n    }\n\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\n            $model = Clean-Cell $d.Model\n            $sn = \u0027\u0027\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\n            $devId = Clean-Cell $d.DeviceID\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n            $parts = @()\n            if ($model) { $parts += $model }\n            if ($sn)    { $parts += \"SN:$sn\" }\n            if ($devId) { $parts += \"Dev:$devId\" }\n            if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-PciDeviceInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\n    if ($hasGetPnpDevice) {\n        try {\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\n                Where-Object { $_.InstanceId -like \u0027PCI\\*\u0027 } |\n                Sort-Object -Property Class, FriendlyName, Name\n\n            foreach ($d in $devs) {\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\n                $name = Clean-Cell $name\n                $cls  = Clean-Cell $d.Class\n                $id   = Clean-Cell $d.InstanceId\n                if ($name -or $id) {\n                    $items.Add((\"{0}{1}{2}\" -f $name, $(if ($cls) { \" [Class:$cls]\" } else { \u0027\u0027 }), $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n                }\n            }\n        } catch {\n            # Fall back below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM Win32_PnPEntity\n    try {\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\*\u0027 } |\n            Sort-Object -Property Name\n\n        foreach ($d in $devs) {\n            $name = Clean-Cell $d.Name\n            $id   = Clean-Cell $d.PNPDeviceID\n            if ($name -or $id) {\n                $items.Add((\"{0}{1}\" -f $name, $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\n# ============================================================================\n# HELPER FUNCTIONS - ANALYSIS\n# ============================================================================\n\nfunction Get-ColumnMap {\n    param([string[]]$Headers)\n\n    $map = @{\n        Hostname        = \u0027Hostname\u0027\n        User            = \u0027User\u0027\n        System_Serial   = \u0027System_Serial\u0027\n        RAM_GB          = \u0027RAM_GB\u0027\n        Monitor_Serials = \u0027Monitor_Serials\u0027\n        Scan_Date       = \u0027Scan_Date\u0027\n    }\n\n    foreach ($k in @($map.Keys)) {\n        if ($Headers -notcontains $map[$k]) {\n            $alts = switch ($k) {\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\n                default           { @() }\n            }\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\n            if ($found) { $map[$k] = $found }\n        }\n    }\n\n    return $map\n}\n\nfunction Parse-ScanDate {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    # Try common date formats\n    $formats = @(\u0027yyyy-MM-dd\u0027, \u0027yyyy-MM-dd HH:mm:ss\u0027, \u0027MM/dd/yyyy\u0027, \u0027dd/MM/yyyy\u0027)\n    foreach ($fmt in $formats) {\n        try {\n            $result = [datetime]::ParseExact($s, $fmt, [System.Globalization.CultureInfo]::InvariantCulture)\n            return $result\n        } catch {\n            # Continue to next format\n        }\n    }\n\n    # Fallback: general parse\n    try {\n        return [datetime]::Parse($s)\n    } catch {\n        return $null\n    }\n}\n\nfunction Normalize-Serial {\n    param([AllowNull()][string]$Serial)\n\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\n    $s = ($Serial.Trim())\n\n    $bad = @(\n        \u0027To Be Filled By O.E.M.\u0027,\n        \u0027To Be Filled By OEM\u0027,\n        \u0027Default string\u0027,\n        \u0027System Serial Number\u0027,\n        \u0027None\u0027,\n        \u0027N/A\u0027,\n        \u0027NA\u0027,\n        \u00270\u0027,\n        \u002700000000\u0027,\n        \u00270000000000\u0027,\n        \u00270000000000000000\u0027\n    )\n\n    if ($bad -contains $s) { return \u0027\u0027 }\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\n\n    return $s.ToUpperInvariant()\n}\n\nfunction Parse-RamGB {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    $m = [regex]::Match($s, \u0027(\\d+)(\\.\\d+)?\u0027)\n    if (-not $m.Success) { return $null }\n\n    $n = $null\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\n        return [int][math]::Round($n, 0)\n    }\n\n    return $null\n}\n\nfunction Is-MonitorMissing {\n    param([AllowNull()][string]$Value)\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\n    $t = $Value.Trim()\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\n}\n\n# ============================================================================\n# MAIN: COLLECTION\n# ============================================================================\n\nfunction Invoke-Collection {\n    param([string]$OutPath, [switch]$IncludePci)\n\n    $errors = New-Object System.Collections.Generic.List[string]\n\n    Write-Host \"`n========================================================\" -ForegroundColor Cyan\n    Write-Host \"   GATHERING HARDWARE SPECS... PLEASE WAIT\" -ForegroundColor Cyan\n    Write-Host \"========================================================\" -ForegroundColor Cyan\n\n    # --- Collect core system info ---\n    $sys  = $null\n    $bios = $null\n    $cpu  = $null\n    $os   = $null\n    $bb   = $null\n\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_ComputerSystem: $($_.Exception.Message)\") }\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\"Win32_BIOS: $($_.Exception.Message)\") }\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_Processor: $($_.Exception.Message)\") }\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_OperatingSystem: $($_.Exception.Message)\") }\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_BaseBoard: $($_.Exception.Message)\") }\n\n    # --- Derived values ---\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\n\n    $ramGB = $null\n    try {\n        if ($sys -and $sys.TotalPhysicalMemory) {\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\n        }\n    } catch {\n        $errors.Add(\"RAM calc: $($_.Exception.Message)\")\n    }\n\n    # --- Other sections ---\n    $netStr  = \u0027\u0027\n    $gpuStr  = \u0027\u0027\n    $diskStr = \u0027\u0027\n    $monStr  = \u0027\u0027\n    $pciStr  = \u0027\u0027\n\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\"Network: $($_.Exception.Message)\") }\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\"GPU: $($_.Exception.Message)\") }\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\"Disks: $($_.Exception.Message)\") }\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\"Monitors: $($_.Exception.Message)\") }\n\n    if ($IncludePci) {\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\"PCI devices: $($_.Exception.Message)\") }\n    }\n\n    # Pre-compute BIOS release date (inline try-catch not reliable in PS 5.1)\n    $biosReleaseDate = \u0027\u0027\n    try {\n        if ($bios -and $bios.ReleaseDate) {\n            $biosReleaseDate = ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027)\n        }\n    } catch {\n        $biosReleaseDate = \u0027\u0027\n    }\n\n    # --- Build record ---\n    $record = [pscustomobject]@{\n        Hostname          = Clean-Cell $hostname\n        User              = Clean-Cell $env:USERNAME\n\n        Make_Model        = Clean-Cell ((\"{0} {1}\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\n\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\n        Baseboard_Product = Clean-Cell ($bb.Product)\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\n\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\n        BIOS_ReleaseDate  = Clean-Cell $biosReleaseDate\n\n        OS_Caption        = Clean-Cell ($os.Caption)\n        OS_Version        = Clean-Cell ($os.Version)\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\n\n        CPU               = Clean-Cell ($cpu.Name)\n        RAM_GB            = $ramGB\n\n        Network_Adapters  = Clean-Cell $netStr\n        GPUs              = Clean-Cell $gpuStr\n        Disk_Serials      = Clean-Cell $diskStr\n        Monitor_Serials   = Clean-Cell $monStr\n\n        PCI_Devices       = Clean-Cell $pciStr\n\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\n        Collector_Version = \u00272.0\u0027\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\n    }\n\n    # --- CSV append with header safety ---\n    $needHeader = $true\n    if (Test-Path -LiteralPath $OutPath) {\n        try {\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\n            if ($fi.Length -gt 0) { $needHeader = $false }\n        } catch { $needHeader = $true }\n    }\n\n    if ($needHeader) {\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\n    } else {\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\n    }\n\n    Write-Host \"`nSUCCESS!\" -ForegroundColor Green\n    Write-Host \"Data saved to: $OutPath\" -ForegroundColor Gray\n    if ($record.Errors) {\n        Write-Host (\"Warnings captured in Errors column: {0}\" -f $record.Errors) -ForegroundColor Yellow\n    }\n}\n\n# ============================================================================\n# MAIN: ANALYSIS\n# ============================================================================\n\nfunction Invoke-Analysis {\n    param(\n        [string]$InputPath,\n        [int]$StaleDaysThreshold,\n        [int]$MinRam,\n        [switch]$SkipCsv,\n        [string]$BaseDir\n    )\n\n    $ReportFile = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.txt\u0027\n    $IssuesCsv  = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.csv\u0027\n\n    if (-not (Test-Path -LiteralPath $InputPath)) {\n        Write-Warning \"Input file not found: $InputPath\"\n        Write-Warning \"Run the script without -AnalyzeOnly first to collect data.\"\n        return\n    }\n\n    $raw = Import-Csv -LiteralPath $InputPath\n    if (-not $raw -or $raw.Count -eq 0) {\n        Write-Warning \"Input file contains no rows: $InputPath\"\n        return\n    }\n\n    $headers = @()\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\n    $col = Get-ColumnMap -Headers $headers\n\n    $today = Get-Date\n\n    # Normalize data and add helper properties\n    $data = foreach ($r in $raw) {\n        $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\n        $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\n        $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\n        $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\n        $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\n        $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\n\n        $serialN = Normalize-Serial $serial\n        $scanDt  = Parse-ScanDate $scan\n        $ramGb   = Parse-RamGB $ram\n\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\n\n        # Asset key: prefer System Serial, fallback to Hostname\n        $assetKey = \u0027\u0027\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\n            $assetKey = $serialN\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\n            $assetKey = $h.Trim().ToUpperInvariant()\n        }\n\n        [pscustomobject]@{\n            Hostname        = $h.Trim()\n            User            = $u.Trim()\n            System_Serial   = $serialN\n            RAM_GB          = $ramGb\n            Monitor_Serials = $m.Trim()\n            Scan_Date       = $s.Trim()\n\n            ScanDateParsed  = $scanDt\n            AssetKey        = $assetKey\n            RawRow          = $r\n        }\n    }\n\n    # Latest record per asset\n    $latestByAsset = $data |\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\n        Group-Object -Property AssetKey |\n        ForEach-Object { $_.Group | Select-Object -First 1 }\n\n    $issues = New-Object System.Collections.Generic.List[object]\n\n    function Add-Issue {\n        param(\n            [Parameter(Mandatory)][string]$IssueType,\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\n            [string]$AssetKey,\n            [string]$Hostname,\n            [string]$User,\n            [string]$SystemSerial,\n            [string]$ScanDate,\n            [string]$Details\n        )\n\n        $issues.Add([pscustomobject]@{\n            IssueType     = $IssueType\n            Severity      = $Severity\n            AssetKey      = $AssetKey\n            Hostname      = $Hostname\n            User          = $User\n            System_Serial = $SystemSerial\n            Scan_Date     = $ScanDate\n            Details       = $Details\n        })\n    }\n\n    # 0) Data quality (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\n        }\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\n        }\n        if (-not $pc.ScanDateParsed) {\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\n        }\n    }\n\n    # 1) Duplicate serials (all rows; ignore blanks)\n    $dupeGroups = $data |\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\n        Group-Object -Property System_Serial |\n        Where-Object { $_.Count -gt 1 }\n\n    foreach ($g in $dupeGroups) {\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\n\n        $severity =\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\n            else { \u0027Info\u0027 }\n\n        $entries = $g.Group |\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\n            ForEach-Object {\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\n                \"{0} ({1})\" -f $_.Hostname, $d\n            }\n\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\n    }\n\n    # 2) Low RAM (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\"RAM_GB={0} (min {1})\" -f $pc.RAM_GB, $MinRam)\n        } elseif ($null -eq $pc.RAM_GB) {\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\n        }\n    }\n\n    # 3) Stale assets (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ($pc.ScanDateParsed) {\n            $ageDays = ($today - $pc.ScanDateParsed).Days\n            if ($ageDays -gt $StaleDaysThreshold) {\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\"Last seen {0} days ago (threshold {1})\" -f $ageDays, $StaleDaysThreshold)\n            }\n        }\n    }\n\n    # 4) Missing monitor serials (latest records)\n    foreach ($pc in $latestByAsset) {\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\n        }\n    }\n\n    # --- Build text report ---\n    $generated = Get-Date\n    $line = (\u0027=\u0027 * 70)\n\n    $txt = New-Object System.Collections.Generic.List[string]\n    $txt.Add($line)\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\n    $txt.Add(\"Generated: $generated\")\n    $txt.Add(\"Input:     $InputPath\")\n    $txt.Add((\"Assets:    {0} (latest per asset)\" -f $latestByAsset.Count))\n    $txt.Add((\"Rows:      {0} (raw rows in CSV)\" -f $data.Count))\n    $txt.Add((\"Settings:  MinRamGB={0}, StaleDays={1}\" -f $MinRam, $StaleDaysThreshold))\n    $txt.Add($line)\n    $txt.Add(\u0027\u0027)\n\n    if ($issues.Count -eq 0) {\n        $txt.Add(\u0027No issues found.\u0027)\n    } else {\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\n        foreach ($t in $byType) {\n            $txt.Add((\"--- {0} ({1}) ---\" -f $t.Name, $t.Count))\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\n\n                $txt.Add((\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\n            }\n            $txt.Add(\u0027\u0027)\n        }\n    }\n\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\n\n    if (-not $SkipCsv) {\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\n    }\n\n    # --- Console summary ---\n    Write-Host \"`n$line\" -ForegroundColor Cyan\n    Write-Host (\"Report saved: {0}\" -f $ReportFile) -ForegroundColor Green\n    if (-not $SkipCsv) { Write-Host (\"Issues CSV:   {0}\" -f $IssuesCsv) -ForegroundColor Green }\n    Write-Host (\"Issues found: {0}\" -f $issues.Count) -ForegroundColor Yellow\n    Write-Host $line -ForegroundColor Cyan\n\n    if ($issues.Count -gt 0) {\n        $sev = $issues | Group-Object Severity | Sort-Object Name\n        foreach ($s in $sev) {\n            $c = switch ($s.Name) {\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\n                default    { [ConsoleColor]::Gray }\n            }\n            Write-Host (\"{0}: {1}\" -f $s.Name, $s.Count) -ForegroundColor $c\n        }\n    }\n}\n\n# ============================================================================\n# ENTRY POINT\n# ============================================================================\n\nif (-not $AnalyzeOnly) {\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\n}\n\nif ($Analyze -or $AnalyzeOnly) {\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv -BaseDir $ScriptDir\n}\n\nif (-not $AnalyzeOnly -and -not $Analyze) {\n    Write-Host \"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\" -ForegroundColor DarkGray\n}\n\n","languageId":"powershell"}],"capabilityType":15,"toolFormerData":{"tool":38,"toolCallId":"toolu_vrtx_0113Ym2r2psQxXJhoo3915DN","toolIndex":1,"modelCallId":"f8d4380b-a6e4-4eee-b3ad-cfc4fccb1e20","status":"completed","rawArgs":"{\"file_path\": \"USB-Inventory.ps1\", \"old_string\": \"function Parse-ScanDate {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    $dt = $null\\n\\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n\\n    if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\\n\\n    return $null\\n}\", \"new_string\": \"function Parse-ScanDate {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    # Try common date formats\\n    $formats = @(\u0027yyyy-MM-dd\u0027, \u0027yyyy-MM-dd HH:mm:ss\u0027, \u0027MM/dd/yyyy\u0027, \u0027dd/MM/yyyy\u0027)\\n    foreach ($fmt in $formats) {\\n        try {\\n            $result = [datetime]::ParseExact($s, $fmt, [System.Globalization.CultureInfo]::InvariantCulture)\\n            return $result\\n        } catch {\\n            # Continue to next format\\n        }\\n    }\\n\\n    # Fallback: general parse\\n    try {\\n        return [datetime]::Parse($s)\\n    } catch {\\n        return $null\\n    }\\n}\"}","name":"search_replace","params":"{\"relativeWorkspacePath\":\"USB-Inventory.ps1\"}","additionalData":{"codeblockId":"6217e76c-4e58-4fe1-a14e-6e31a69962c3"},"userDecision":"accepted","result":"{\"diff\":{\"chunks\":[{\"diffString\":\"      $s = $Value.Trim()\\n  \\n-     $dt = $null\\n- \\n-     if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n-     if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n- \\n-     if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\\n- \\n-     return $null\\n+     # Try common date formats\\n+     $formats = @(\u0027yyyy-MM-dd\u0027, \u0027yyyy-MM-dd HH:mm:ss\u0027, \u0027MM/dd/yyyy\u0027, \u0027dd/MM/yyyy\u0027)\\n+     foreach ($fmt in $formats) {\\n+         try {\\n+             $result = [datetime]::ParseExact($s, $fmt, [System.Globalization.CultureInfo]::InvariantCulture)\\n+             return $result\\n+         } catch {\\n+             # Continue to next format\\n+         }\\n+     }\\n+ \\n+     # Fallback: general parse\\n+     try {\\n+         return [datetime]::Parse($s)\\n+     } catch {\\n+         return $null\\n+     }\\n  }\\n  \",\"oldStart\":429,\"newStart\":429,\"oldLines\":12,\"newLines\":21,\"linesRemoved\":8,\"linesAdded\":17}],\"editor\":\"EDITOR_AI\"},\"shouldAutoFixLints\":true,\"resultForModel\":\"The file USB-Inventory.ps1 has been updated.\",\"contentsAfterEdit\":\"#requires -Version 5.1\\n\u003c#\\n.SYNOPSIS\\n    USB-portable PC hardware inventory collection and analysis tool.\\n\\n.DESCRIPTION\\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\\n    script. Optionally runs health analysis to detect duplicates, stale assets,\\n    low RAM, and missing monitor data.\\n\\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\\n\\n.PARAMETER OutputFile\\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\\n\\n.PARAMETER IncludePciDevices\\n    Include detailed PCI device enumeration (can produce large output).\\n\\n.PARAMETER Analyze\\n    After collection, run health analysis on the CSV file.\\n\\n.PARAMETER AnalyzeOnly\\n    Skip collection; only run health analysis on existing CSV.\\n\\n.PARAMETER StaleDays\\n    Threshold in days for flagging stale assets. Default: 90.\\n\\n.PARAMETER MinRamGB\\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\\n\\n.PARAMETER NoCsv\\n    Do not output Inventory_Issues_Report.csv (text report only).\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1\\n    Collect inventory from this PC into PC_Inventory_Master.csv.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -IncludePciDevices -Analyze\\n    Collect inventory with PCI devices, then run health analysis.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\\n    Analyze existing CSV with custom thresholds (no new collection).\\n#\u003e\\n\\n[CmdletBinding()]\\nparam(\\n    [string]$OutputFile,\\n    [switch]$IncludePciDevices,\\n    [switch]$Analyze,\\n    [switch]$AnalyzeOnly,\\n    [int]$StaleDays = 90,\\n    [int]$MinRamGB = 8,\\n    [switch]$NoCsv\\n)\\n\\nSet-StrictMode -Version Latest\\n$ErrorActionPreference = \u0027Stop\u0027\\n\\n# Resolve script root (handles -File invocation where $PSScriptRoot may be empty)\\n$ScriptDir = $PSScriptRoot\\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n    $ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition\\n}\\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n    $ScriptDir = $PWD.Path\\n}\\n\\n# Default OutputFile if not specified\\nif ([string]::IsNullOrWhiteSpace($OutputFile)) {\\n    $OutputFile = Join-Path -Path $ScriptDir -ChildPath \u0027PC_Inventory_Master.csv\u0027\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - COLLECTION\\n# ============================================================================\\n\\nfunction Clean-Cell {\\n    param([AllowNull()][string]$Text)\\n    if ($null -eq $Text) { return \u0027\u0027 }\\n    return ($Text -replace \\\"(`r`n|`n|`r|`t)+\\\", \u0027 \u0027).Trim()\\n}\\n\\nfunction Convert-UShortArrayToString {\\n    param([AllowNull()]$Arr)\\n    if ($null -eq $Arr) { return \u0027\u0027 }\\n    $chars = foreach ($x in $Arr) {\\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\\n    }\\n    return ( -join $chars ).Trim()\\n}\\n\\nfunction Get-MonitorInventory {\\n    \u003c#\\n      Preferred: root\\\\wmi:WmiMonitorID (easy, consistent, usually no admin)\\n      Fallback: registry EDID decode under HKLM:\\\\SYSTEM\\\\CCS\\\\Enum\\\\DISPLAY\\n    #\u003e\\n\\n    $results = New-Object System.Collections.Generic.List[string]\\n\\n    # --- Preferred path: WmiMonitorID ---\\n    try {\\n        $wmiMons = Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorID -ErrorAction Stop\\n        foreach ($m in $wmiMons) {\\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\\n\\n            $label = @()\\n            if ($mfg)  { $label += $mfg }\\n            if ($name) { $label += $name }\\n\\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\\n            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } else { \u0027SN:(none)\u0027 }\\n\\n            $results.Add(\\\"$displayName ($serialPart)\\\")\\n        }\\n    } catch {\\n        # WmiMonitorID not available; fall through to EDID fallback\\n    }\\n\\n    if ($results.Count -gt 0) {\\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n    }\\n\\n    # --- Fallback path: registry EDID decode ---\\n    function Get-EdidDescriptorString {\\n        param(\\n            [byte[]]$Edid,\\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\\n        )\\n\\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\\n\\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\\n\\n        foreach ($offset in 54,72,90,108) {\\n            if (($offset + 18) -gt $Edid.Length) { continue }\\n\\n            # Descriptor: 00 00 00 {tag} 00 ...\\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\\n\\n                $bytes = $Edid[($offset+5)..($offset+17)]\\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\\n                $text = ($text -replace \\\"[`0`n`r]+\\\", \u0027\u0027).Trim()\\n                if ($text) { return $text }\\n            }\\n        }\\n\\n        return \u0027\u0027\\n    }\\n\\n    try {\\n        $root = \u0027HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Enum\\\\DISPLAY\u0027\\n        if (Test-Path -LiteralPath $root) {\\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\\n                    if (Test-Path -LiteralPath $params) {\\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\\n                        if ($edid -is [byte[]]) {\\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\\n\\n                            # Numeric serial (bytes 12-15 LE) sometimes present\\n                            $num = [BitConverter]::ToUInt32($edid, 12)\\n                            $numStr = if ($num -ne 0) { \\\"NUM:$num\\\" } else { \u0027\u0027 }\\n\\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\\n                            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\\n\\n                            $results.Add(\\\"$displayName ($serialPart)\\\")\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    } catch {\\n        # EDID fallback failed silently\\n    }\\n\\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-NetworkInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\\n\\n    if ($hasNetAdapter -and $hasNetIpCfg) {\\n        try {\\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\\n            foreach ($a in $adapters) {\\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\\n                $ipv4 = @()\\n                if ($cfg -and $cfg.IPv4Address) {\\n                    $ipv4 = $cfg.IPv4Address |\\n                        ForEach-Object { $_.IPAddress } |\\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\\n                }\\n                $gw = @()\\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\\n                }\\n\\n                $parts = @()\\n                $parts += (Clean-Cell $a.Name)\\n                if ($a.MacAddress) { $parts += \\\"MAC:$($a.MacAddress)\\\" }\\n                if ($ipv4.Count -gt 0) { $parts += (\\\"IPv4:\\\" + ($ipv4 -join \u0027;\u0027)) }\\n                if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n                $items.Add(($parts -join \u0027 \u0027))\\n            }\\n        } catch {\\n            # Fall back to CIM below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\\n            Where-Object { $_.IPEnabled -eq $true }\\n\\n        foreach ($n in $net) {\\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\\n            $mac  = $n.MACAddress\\n            $ips  = @()\\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\\n            $gw   = @()\\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\\n\\n            $parts = @()\\n            $parts += (Clean-Cell $name)\\n            if ($mac) { $parts += \\\"MAC:$mac\\\" }\\n            if ($ips.Count -gt 0) { $parts += (\\\"IP:\\\" + ($ips -join \u0027;\u0027)) }\\n            if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n            $items.Add(($parts -join \u0027 \u0027))\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-GpuInventory {\\n    $gpus = New-Object System.Collections.Generic.List[string]\\n\\n    # CIM GPUs\\n    try {\\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\\n        foreach ($g in $vc) {\\n            $name = Clean-Cell $g.Name\\n            $pnp  = Clean-Cell $g.PNPDeviceID\\n            if ($name -or $pnp) {\\n                $gpus.Add((\\\"{0}{1}\\\" -f $name, $(if ($pnp) { \\\" [ID:$pnp]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    # Optional NVIDIA serials if nvidia-smi exists\\n    try {\\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\\n        if ($nvsmi) {\\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\\n            foreach ($line in @($raw)) {\\n                $t = Clean-Cell $line\\n                if ($t) { $gpus.Add(\\\"NVIDIA $t\\\") }\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-DiskInventory {\\n    $disks = New-Object System.Collections.Generic.List[string]\\n\\n    # Prefer Storage module when available\\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasPhysicalDisk) {\\n        try {\\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\\n                $name = Clean-Cell $d.FriendlyName\\n                $sn   = Clean-Cell $d.SerialNumber\\n                $mt   = Clean-Cell ([string]$d.MediaType)\\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n                $parts = @()\\n                if ($name) { $parts += $name }\\n                if ($sn)   { $parts += \\\"SN:$sn\\\" }\\n                if ($mt)   { $parts += \\\"Type:$mt\\\" }\\n                if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\\n            $model = Clean-Cell $d.Model\\n            $sn = \u0027\u0027\\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\\n            $devId = Clean-Cell $d.DeviceID\\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n            $parts = @()\\n            if ($model) { $parts += $model }\\n            if ($sn)    { $parts += \\\"SN:$sn\\\" }\\n            if ($devId) { $parts += \\\"Dev:$devId\\\" }\\n            if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-PciDeviceInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasGetPnpDevice) {\\n        try {\\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\\n                Where-Object { $_.InstanceId -like \u0027PCI\\\\*\u0027 } |\\n                Sort-Object -Property Class, FriendlyName, Name\\n\\n            foreach ($d in $devs) {\\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\\n                $name = Clean-Cell $name\\n                $cls  = Clean-Cell $d.Class\\n                $id   = Clean-Cell $d.InstanceId\\n                if ($name -or $id) {\\n                    $items.Add((\\\"{0}{1}{2}\\\" -f $name, $(if ($cls) { \\\" [Class:$cls]\\\" } else { \u0027\u0027 }), $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n                }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM Win32_PnPEntity\\n    try {\\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\\\*\u0027 } |\\n            Sort-Object -Property Name\\n\\n        foreach ($d in $devs) {\\n            $name = Clean-Cell $d.Name\\n            $id   = Clean-Cell $d.PNPDeviceID\\n            if ($name -or $id) {\\n                $items.Add((\\\"{0}{1}\\\" -f $name, $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - ANALYSIS\\n# ============================================================================\\n\\nfunction Get-ColumnMap {\\n    param([string[]]$Headers)\\n\\n    $map = @{\\n        Hostname        = \u0027Hostname\u0027\\n        User            = \u0027User\u0027\\n        System_Serial   = \u0027System_Serial\u0027\\n        RAM_GB          = \u0027RAM_GB\u0027\\n        Monitor_Serials = \u0027Monitor_Serials\u0027\\n        Scan_Date       = \u0027Scan_Date\u0027\\n    }\\n\\n    foreach ($k in @($map.Keys)) {\\n        if ($Headers -notcontains $map[$k]) {\\n            $alts = switch ($k) {\\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\\n                default           { @() }\\n            }\\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\\n            if ($found) { $map[$k] = $found }\\n        }\\n    }\\n\\n    return $map\\n}\\n\\nfunction Parse-ScanDate {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    # Try common date formats\\n    $formats = @(\u0027yyyy-MM-dd\u0027, \u0027yyyy-MM-dd HH:mm:ss\u0027, \u0027MM/dd/yyyy\u0027, \u0027dd/MM/yyyy\u0027)\\n    foreach ($fmt in $formats) {\\n        try {\\n            $result = [datetime]::ParseExact($s, $fmt, [System.Globalization.CultureInfo]::InvariantCulture)\\n            return $result\\n        } catch {\\n            # Continue to next format\\n        }\\n    }\\n\\n    # Fallback: general parse\\n    try {\\n        return [datetime]::Parse($s)\\n    } catch {\\n        return $null\\n    }\\n}\\n\\nfunction Normalize-Serial {\\n    param([AllowNull()][string]$Serial)\\n\\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\\n    $s = ($Serial.Trim())\\n\\n    $bad = @(\\n        \u0027To Be Filled By O.E.M.\u0027,\\n        \u0027To Be Filled By OEM\u0027,\\n        \u0027Default string\u0027,\\n        \u0027System Serial Number\u0027,\\n        \u0027None\u0027,\\n        \u0027N/A\u0027,\\n        \u0027NA\u0027,\\n        \u00270\u0027,\\n        \u002700000000\u0027,\\n        \u00270000000000\u0027,\\n        \u00270000000000000000\u0027\\n    )\\n\\n    if ($bad -contains $s) { return \u0027\u0027 }\\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\\n\\n    return $s.ToUpperInvariant()\\n}\\n\\nfunction Parse-RamGB {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    $m = [regex]::Match($s, \u0027(\\\\d+)(\\\\.\\\\d+)?\u0027)\\n    if (-not $m.Success) { return $null }\\n\\n    $n = $null\\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\\n        return [int][math]::Round($n, 0)\\n    }\\n\\n    return $null\\n}\\n\\nfunction Is-MonitorMissing {\\n    param([AllowNull()][string]$Value)\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\\n    $t = $Value.Trim()\\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\\n}\\n\\n# ============================================================================\\n# MAIN: COLLECTION\\n# ============================================================================\\n\\nfunction Invoke-Collection {\\n    param([string]$OutPath, [switch]$IncludePci)\\n\\n    $errors = New-Object System.Collections.Generic.List[string]\\n\\n    Write-Host \\\"`n========================================================\\\" -ForegroundColor Cyan\\n    Write-Host \\\"   GATHERING HARDWARE SPECS... PLEASE WAIT\\\" -ForegroundColor Cyan\\n    Write-Host \\\"========================================================\\\" -ForegroundColor Cyan\\n\\n    # --- Collect core system info ---\\n    $sys  = $null\\n    $bios = $null\\n    $cpu  = $null\\n    $os   = $null\\n    $bb   = $null\\n\\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_ComputerSystem: $($_.Exception.Message)\\\") }\\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\\\"Win32_BIOS: $($_.Exception.Message)\\\") }\\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_Processor: $($_.Exception.Message)\\\") }\\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_OperatingSystem: $($_.Exception.Message)\\\") }\\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_BaseBoard: $($_.Exception.Message)\\\") }\\n\\n    # --- Derived values ---\\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\\n\\n    $ramGB = $null\\n    try {\\n        if ($sys -and $sys.TotalPhysicalMemory) {\\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\\n        }\\n    } catch {\\n        $errors.Add(\\\"RAM calc: $($_.Exception.Message)\\\")\\n    }\\n\\n    # --- Other sections ---\\n    $netStr  = \u0027\u0027\\n    $gpuStr  = \u0027\u0027\\n    $diskStr = \u0027\u0027\\n    $monStr  = \u0027\u0027\\n    $pciStr  = \u0027\u0027\\n\\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\\\"Network: $($_.Exception.Message)\\\") }\\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\\\"GPU: $($_.Exception.Message)\\\") }\\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\\\"Disks: $($_.Exception.Message)\\\") }\\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\\\"Monitors: $($_.Exception.Message)\\\") }\\n\\n    if ($IncludePci) {\\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\\\"PCI devices: $($_.Exception.Message)\\\") }\\n    }\\n\\n    # Pre-compute BIOS release date (inline try-catch not reliable in PS 5.1)\\n    $biosReleaseDate = \u0027\u0027\\n    try {\\n        if ($bios -and $bios.ReleaseDate) {\\n            $biosReleaseDate = ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027)\\n        }\\n    } catch {\\n        $biosReleaseDate = \u0027\u0027\\n    }\\n\\n    # --- Build record ---\\n    $record = [pscustomobject]@{\\n        Hostname          = Clean-Cell $hostname\\n        User              = Clean-Cell $env:USERNAME\\n\\n        Make_Model        = Clean-Cell ((\\\"{0} {1}\\\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\\n\\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\\n        Baseboard_Product = Clean-Cell ($bb.Product)\\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\\n\\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\\n        BIOS_ReleaseDate  = Clean-Cell $biosReleaseDate\\n\\n        OS_Caption        = Clean-Cell ($os.Caption)\\n        OS_Version        = Clean-Cell ($os.Version)\\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\\n\\n        CPU               = Clean-Cell ($cpu.Name)\\n        RAM_GB            = $ramGB\\n\\n        Network_Adapters  = Clean-Cell $netStr\\n        GPUs              = Clean-Cell $gpuStr\\n        Disk_Serials      = Clean-Cell $diskStr\\n        Monitor_Serials   = Clean-Cell $monStr\\n\\n        PCI_Devices       = Clean-Cell $pciStr\\n\\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\\n        Collector_Version = \u00272.0\u0027\\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\\n    }\\n\\n    # --- CSV append with header safety ---\\n    $needHeader = $true\\n    if (Test-Path -LiteralPath $OutPath) {\\n        try {\\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\\n            if ($fi.Length -gt 0) { $needHeader = $false }\\n        } catch { $needHeader = $true }\\n    }\\n\\n    if ($needHeader) {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\\n    } else {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\\n    }\\n\\n    Write-Host \\\"`nSUCCESS!\\\" -ForegroundColor Green\\n    Write-Host \\\"Data saved to: $OutPath\\\" -ForegroundColor Gray\\n    if ($record.Errors) {\\n        Write-Host (\\\"Warnings captured in Errors column: {0}\\\" -f $record.Errors) -ForegroundColor Yellow\\n    }\\n}\\n\\n# ============================================================================\\n# MAIN: ANALYSIS\\n# ============================================================================\\n\\nfunction Invoke-Analysis {\\n    param(\\n        [string]$InputPath,\\n        [int]$StaleDaysThreshold,\\n        [int]$MinRam,\\n        [switch]$SkipCsv,\\n        [string]$BaseDir\\n    )\\n\\n    $ReportFile = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.txt\u0027\\n    $IssuesCsv  = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.csv\u0027\\n\\n    if (-not (Test-Path -LiteralPath $InputPath)) {\\n        Write-Warning \\\"Input file not found: $InputPath\\\"\\n        Write-Warning \\\"Run the script without -AnalyzeOnly first to collect data.\\\"\\n        return\\n    }\\n\\n    $raw = Import-Csv -LiteralPath $InputPath\\n    if (-not $raw -or $raw.Count -eq 0) {\\n        Write-Warning \\\"Input file contains no rows: $InputPath\\\"\\n        return\\n    }\\n\\n    $headers = @()\\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\\n    $col = Get-ColumnMap -Headers $headers\\n\\n    $today = Get-Date\\n\\n    # Normalize data and add helper properties\\n    $data = foreach ($r in $raw) {\\n        $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\\n        $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\\n        $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\\n        $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\\n        $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\\n        $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\\n\\n        $serialN = Normalize-Serial $serial\\n        $scanDt  = Parse-ScanDate $scan\\n        $ramGb   = Parse-RamGB $ram\\n\\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\\n\\n        # Asset key: prefer System Serial, fallback to Hostname\\n        $assetKey = \u0027\u0027\\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\\n            $assetKey = $serialN\\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\\n            $assetKey = $h.Trim().ToUpperInvariant()\\n        }\\n\\n        [pscustomobject]@{\\n            Hostname        = $h.Trim()\\n            User            = $u.Trim()\\n            System_Serial   = $serialN\\n            RAM_GB          = $ramGb\\n            Monitor_Serials = $m.Trim()\\n            Scan_Date       = $s.Trim()\\n\\n            ScanDateParsed  = $scanDt\\n            AssetKey        = $assetKey\\n            RawRow          = $r\\n        }\\n    }\\n\\n    # Latest record per asset\\n    $latestByAsset = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\\n        Group-Object -Property AssetKey |\\n        ForEach-Object { $_.Group | Select-Object -First 1 }\\n\\n    $issues = New-Object System.Collections.Generic.List[object]\\n\\n    function Add-Issue {\\n        param(\\n            [Parameter(Mandatory)][string]$IssueType,\\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\\n            [string]$AssetKey,\\n            [string]$Hostname,\\n            [string]$User,\\n            [string]$SystemSerial,\\n            [string]$ScanDate,\\n            [string]$Details\\n        )\\n\\n        $issues.Add([pscustomobject]@{\\n            IssueType     = $IssueType\\n            Severity      = $Severity\\n            AssetKey      = $AssetKey\\n            Hostname      = $Hostname\\n            User          = $User\\n            System_Serial = $SystemSerial\\n            Scan_Date     = $ScanDate\\n            Details       = $Details\\n        })\\n    }\\n\\n    # 0) Data quality (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\\n        }\\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\\n        }\\n        if (-not $pc.ScanDateParsed) {\\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\\n        }\\n    }\\n\\n    # 1) Duplicate serials (all rows; ignore blanks)\\n    $dupeGroups = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\\n        Group-Object -Property System_Serial |\\n        Where-Object { $_.Count -gt 1 }\\n\\n    foreach ($g in $dupeGroups) {\\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\\n\\n        $severity =\\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\\n            else { \u0027Info\u0027 }\\n\\n        $entries = $g.Group |\\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\\n            ForEach-Object {\\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\\n                \\\"{0} ({1})\\\" -f $_.Hostname, $d\\n            }\\n\\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\\\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\\\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\\n    }\\n\\n    # 2) Low RAM (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\\\"RAM_GB={0} (min {1})\\\" -f $pc.RAM_GB, $MinRam)\\n        } elseif ($null -eq $pc.RAM_GB) {\\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\\n        }\\n    }\\n\\n    # 3) Stale assets (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($pc.ScanDateParsed) {\\n            $ageDays = ($today - $pc.ScanDateParsed).Days\\n            if ($ageDays -gt $StaleDaysThreshold) {\\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\\\"Last seen {0} days ago (threshold {1})\\\" -f $ageDays, $StaleDaysThreshold)\\n            }\\n        }\\n    }\\n\\n    # 4) Missing monitor serials (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\\n        }\\n    }\\n\\n    # --- Build text report ---\\n    $generated = Get-Date\\n    $line = (\u0027=\u0027 * 70)\\n\\n    $txt = New-Object System.Collections.Generic.List[string]\\n    $txt.Add($line)\\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\\n    $txt.Add(\\\"Generated: $generated\\\")\\n    $txt.Add(\\\"Input:     $InputPath\\\")\\n    $txt.Add((\\\"Assets:    {0} (latest per asset)\\\" -f $latestByAsset.Count))\\n    $txt.Add((\\\"Rows:      {0} (raw rows in CSV)\\\" -f $data.Count))\\n    $txt.Add((\\\"Settings:  MinRamGB={0}, StaleDays={1}\\\" -f $MinRam, $StaleDaysThreshold))\\n    $txt.Add($line)\\n    $txt.Add(\u0027\u0027)\\n\\n    if ($issues.Count -eq 0) {\\n        $txt.Add(\u0027No issues found.\u0027)\\n    } else {\\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\\n        foreach ($t in $byType) {\\n            $txt.Add((\\\"--- {0} ({1}) ---\\\" -f $t.Name, $t.Count))\\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\\n\\n                $txt.Add((\\\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\\\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\\n            }\\n            $txt.Add(\u0027\u0027)\\n        }\\n    }\\n\\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\\n\\n    if (-not $SkipCsv) {\\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\\n    }\\n\\n    # --- Console summary ---\\n    Write-Host \\\"`n$line\\\" -ForegroundColor Cyan\\n    Write-Host (\\\"Report saved: {0}\\\" -f $ReportFile) -ForegroundColor Green\\n    if (-not $SkipCsv) { Write-Host (\\\"Issues CSV:   {0}\\\" -f $IssuesCsv) -ForegroundColor Green }\\n    Write-Host (\\\"Issues found: {0}\\\" -f $issues.Count) -ForegroundColor Yellow\\n    Write-Host $line -ForegroundColor Cyan\\n\\n    if ($issues.Count -gt 0) {\\n        $sev = $issues | Group-Object Severity | Sort-Object Name\\n        foreach ($s in $sev) {\\n            $c = switch ($s.Name) {\\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\\n                default    { [ConsoleColor]::Gray }\\n            }\\n            Write-Host (\\\"{0}: {1}\\\" -f $s.Name, $s.Count) -ForegroundColor $c\\n        }\\n    }\\n}\\n\\n# ============================================================================\\n# ENTRY POINT\\n# ============================================================================\\n\\nif (-not $AnalyzeOnly) {\\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\\n}\\n\\nif ($Analyze -or $AnalyzeOnly) {\\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv -BaseDir $ScriptDir\\n}\\n\\nif (-not $AnalyzeOnly -and -not $Analyze) {\\n    Write-Host \\\"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\\\" -ForegroundColor DarkGray\\n}\\n\\n\"}"},"checkpointId":"c334fea8-5bbd-464f-ab8a-a05783a60f90"},"bubbleId":"cb319736-5999-43ab-a1a5-f797fe6fea9b"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"d5ac9315-900b-49cc-b96a-55205c7a5408","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:00:34.072Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"11f099f5-17f3-4a84-bdbf-9f242bbb6f14","codeBlocks":[],"capabilityType":15,"toolFormerData":{"tool":15,"toolCallId":"toolu_vrtx_0124KoUFD6Wj3DA7iJoA1he9","toolIndex":1,"modelCallId":"c6a78666-fece-41c3-9a5c-0046b949a131","status":"completed","rawArgs":"{\"command\": \"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\" -Analyze\", \"is_background\": false, \"explanation\": \"Testing the -Analyze functionality to verify the full script works.\"}","name":"run_terminal_cmd","params":"{\"command\":\"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\" -Analyze\",\"requireUserApproval\":true,\"parsingResult\":{\"executableCommands\":[{\"name\":\"powershell\",\"args\":[{\"type\":\"word\",\"value\":\"-ExecutionPolicy\"},{\"type\":\"word\",\"value\":\"Bypass\"},{\"type\":\"word\",\"value\":\"-File\"},{\"type\":\"string\",\"value\":\"\\\".\\\\USB-Inventory.ps1\\\"\"},{\"type\":\"word\",\"value\":\"-Analyze\"}],\"fullText\":\"powershell -ExecutionPolicy Bypass -File \\\".\\\\USB-Inventory.ps1\\\" -Analyze\"}]},\"fileOutputThresholdBytes\":\"20000\"}","additionalData":{"status":"success","reviewData":{"status":"Done","selectedOption":"run","isShowingInput":false,"candidatesForAllowlist":["powershell"],"approvalType":"allowlist"},"sessionId":"5dd745c9-3368-496b-b5ac-9b78458b05d4","startAtBufferLine":0,"previousAttempt":"{\"output\":\"\\n========================================================\\n   GATHERING HARDWARE SPECS... PLEASE WAIT\\n========================================================\\n\\nSUCCESS!\\nData saved to: C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\PC_Inventory_Master.csv\\nC:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\USB-Inventory.ps1 : Cannot find an overload for \\\"TryParseExact\\\" \\r\\nand the argument count: \\\"5\\\".\\r\\n    + CategoryInfo          : NotSpecified: (:) [USB-Inventory.ps1], MethodException\\r\\n    + FullyQualifiedErrorId : MethodCountCouldNotFindBest,USB-Inventory.ps1\\r\\n \\r\\n\",\"rejected\":false,\"notInterrupted\":true,\"endedReason\":\"RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED\",\"exitCodeV2\":1,\"effectiveSandboxPolicy\":{\"type\":\"TYPE_INSECURE_NONE\"}}"},"result":"{\"output\":\"\\n========================================================\\n   GATHERING HARDWARE SPECS... PLEASE WAIT\\n========================================================\\n\\nSUCCESS!\\nData saved to: C:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\PC_Inventory_Master.csv\\nC:\\\\Users\\\\user\\\\Downloads\\\\Cursor_working_directory_misc\\\\USB-Inventory.ps1 : Cannot find an overload for \\\"TryParseExact\\\" \\r\\nand the argument count: \\\"5\\\".\\r\\n    + CategoryInfo          : NotSpecified: (:) [USB-Inventory.ps1], MethodException\\r\\n    + FullyQualifiedErrorId : MethodCountCouldNotFindBest,USB-Inventory.ps1\\r\\n \\r\\n\",\"rejected\":false,\"notInterrupted\":true,\"endedReason\":\"RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED\",\"exitCodeV2\":1,\"effectiveSandboxPolicy\":{\"type\":\"TYPE_INSECURE_NONE\"}}"}},"bubbleId":"d5ac9315-900b-49cc-b96a-55205c7a5408"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"de793b56-cbc3-4a27-9d52-bf853c692683","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:00:02.634Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"72440367-d3eb-476a-adb8-eb99fdc7e0fe","codeBlocks":[],"capabilityType":15,"toolFormerData":{"tool":41,"toolCallId":"toolu_vrtx_01JEcaoUTvbVBoK71EyQuheL","toolIndex":1,"modelCallId":"b9ba3b9d-61c7-46e2-8a8d-37270478dfef","status":"completed","rawArgs":"{\"pattern\": \"BIOS_ReleaseDate\", \"path\": \"USB-Inventory.ps1\", \"-C\": 2}","name":"grep","params":"{\"pattern\":\"BIOS_ReleaseDate\",\"path\":\"USB-Inventory.ps1\",\"outputMode\":\"content\",\"context\":2,\"caseInsensitive\":false}","additionalData":{},"result":"{\"success\":{\"pattern\":\"BIOS_ReleaseDate\",\"path\":\"USB-Inventory.ps1\",\"outputMode\":\"content\",\"workspaceResults\":{\"c:/Users/user/Downloads/Cursor_working_directory_misc\":{\"content\":{\"matches\":[{\"file\":\"USB-Inventory.ps1\",\"matches\":[{\"lineNumber\":557,\"isContextLine\":true},{\"lineNumber\":558,\"content\":\"        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\",\"isContextLine\":true},{\"lineNumber\":559,\"content\":\"        BIOS_ReleaseDate  = Clean-Cell (try { ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027) } catch { \u0027\u0027 })\"},{\"lineNumber\":560,\"isContextLine\":true},{\"lineNumber\":561,\"content\":\"        OS_Caption        = Clean-Cell ($os.Caption)\",\"isContextLine\":true}]}],\"totalLines\":5,\"totalMatchedLines\":1}}}}}"}},"bubbleId":"de793b56-cbc3-4a27-9d52-bf853c692683"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"e13d9e14-a985-4e11-a11b-ab4a817cc882","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:59:35.203Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"924f6f52-e856-495a-a244-0ec5f3329fbf","usageUuid":"647c39f5-37d9-4c80-b8f1-a4049431cfce","capabilityType":30,"thinking":{"text":"Now I need to update the call to Invoke-Analysis to pass the $ScriptDir parameter.","signature":"EvwBCkgICxACGAIqQLzV43F7IlLu7FPiFIfdoF0whK9pm1WtuzNkOaEWvyg3BokBfA7QhpvwlrCPtw6Ka37H+ZOL/SJ6lhrGzohYCeUSDP6h8g2jwJ92BPd31BoM97rYAGj4zYMA6cXtIjBoZoexRiPrwJBx2nW3QaZCUy0hjuB6KYn4Q8Tz8fNVcecJ45oeab6E8FVVRO04pBEqYpERr/6ksH7QdbKkft7sk4oyKnD4RTEgZrQ0X3fM1K+1cCItlpqHUxROFXo86aMqm0wObmOQLUwVcXHBIMqdafQC0UtjVHnUg2vpUpsz8YWO5gVTBuTSz9DLpBNYzfaDY2RlGAE="},"thinkingStyle":1,"thinkingDurationMs":623},"bubbleId":"e13d9e14-a985-4e11-a11b-ab4a817cc882"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"e140636c-0767-4417-a73e-a60c5f1b7e70","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:00:07.712Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"3b7b3fab-6036-4c00-8d08-519ac1514a44","codeBlocks":[],"capabilityType":15,"toolFormerData":{"tool":40,"toolCallId":"toolu_vrtx_01KwfrQyi6BMDvBd1G2QX1kE","toolIndex":1,"modelCallId":"731e2760-b4d2-4874-9390-e56c1ce2a254","status":"completed","rawArgs":"{\"target_file\": \"USB-Inventory.ps1\", \"offset\": 530, \"limit\": 60}","name":"read_file","params":"{\"targetFile\":\"USB-Inventory.ps1\",\"offset\":530,\"limit\":60,\"charsLimit\":100000,\"effectiveUri\":\"file:///c%3A/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1\"}","additionalData":{},"result":"{\"contents\":\"    # --- Other sections ---\\n    $netStr  = \u0027\u0027\\n    $gpuStr  = \u0027\u0027\\n    $diskStr = \u0027\u0027\\n    $monStr  = \u0027\u0027\\n    $pciStr  = \u0027\u0027\\n\\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\\\"Network: $($_.Exception.Message)\\\") }\\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\\\"GPU: $($_.Exception.Message)\\\") }\\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\\\"Disks: $($_.Exception.Message)\\\") }\\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\\\"Monitors: $($_.Exception.Message)\\\") }\\n\\n    if ($IncludePci) {\\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\\\"PCI devices: $($_.Exception.Message)\\\") }\\n    }\\n\\n    # --- Build record ---\\n    $record = [pscustomobject]@{\\n        Hostname          = Clean-Cell $hostname\\n        User              = Clean-Cell $env:USERNAME\\n\\n        Make_Model        = Clean-Cell ((\\\"{0} {1}\\\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\\n\\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\\n        Baseboard_Product = Clean-Cell ($bb.Product)\\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\\n\\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\\n        BIOS_ReleaseDate  = Clean-Cell (try { ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027) } catch { \u0027\u0027 })\\n\\n        OS_Caption        = Clean-Cell ($os.Caption)\\n        OS_Version        = Clean-Cell ($os.Version)\\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\\n\\n        CPU               = Clean-Cell ($cpu.Name)\\n        RAM_GB            = $ramGB\\n\\n        Network_Adapters  = Clean-Cell $netStr\\n        GPUs              = Clean-Cell $gpuStr\\n        Disk_Serials      = Clean-Cell $diskStr\\n        Monitor_Serials   = Clean-Cell $monStr\\n\\n        PCI_Devices       = Clean-Cell $pciStr\\n\\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\\n        Collector_Version = \u00272.0\u0027\\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\\n    }\\n\\n    # --- CSV append with header safety ---\\n    $needHeader = $true\\n    if (Test-Path -LiteralPath $OutPath) {\\n        try {\\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\\n            if ($fi.Length -gt 0) { $needHeader = $false }\\n        } catch { $needHeader = $true }\\n    }\\n\",\"numCharactersInRequestedRange\":2484,\"totalLinesInFile\":850}"}},"bubbleId":"e140636c-0767-4417-a73e-a60c5f1b7e70"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"e15fb027-c792-41ad-8672-372d0da9827d","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":["{\"content\":\"Create USB-Inventory.ps1 combining collection + analysis logic\",\"status\":\"in_progress\",\"id\":\"synth-script\"}","{\"content\":\"Test script execution on local machine\",\"status\":\"pending\",\"id\":\"test-local\"}"],"createdAt":"2025-12-29T00:55:49.358Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"8260971b-a940-4daf-be09-b8d59af492b8","codeBlocks":[],"capabilityType":15,"toolFormerData":{"tool":35,"toolCallId":"toolu_vrtx_011tMNJuw3ogPV4qxDaJYtqE","toolIndex":1,"modelCallId":"4a62ef7e-fe24-40e3-9b5e-12ea2e579b12","status":"completed","rawArgs":"{\"todos\": [{\"id\": \"synth-script\", \"content\": \"Create USB-Inventory.ps1 combining collection + analysis logic\", \"status\": \"in_progress\"}, {\"id\": \"test-local\", \"content\": \"Test script execution on local machine\", \"status\": \"pending\"}], \"merge\": true}","name":"todo_write","params":"{\"todos\":[{\"content\":\"Create USB-Inventory.ps1 combining collection + analysis logic\",\"status\":\"in_progress\",\"id\":\"synth-script\"}]}","additionalData":{},"result":"{\"success\":true,\"finalTodos\":[{\"content\":\"Create USB-Inventory.ps1 combining collection + analysis logic\",\"status\":\"in_progress\",\"id\":\"synth-script\"},{\"content\":\"Test script execution on local machine\",\"status\":\"pending\",\"id\":\"test-local\"}],\"initialTodos\":[{\"content\":\"Create USB-Inventory.ps1 combining collection + analysis logic\",\"status\":\"pending\",\"id\":\"synth-script\"},{\"content\":\"Test script execution on local machine\",\"status\":\"pending\",\"id\":\"test-local\"}],\"wasMerge\":true}"}},"bubbleId":"e15fb027-c792-41ad-8672-372d0da9827d"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"e27dce98-9c52-4b61-b735-d0563eb5a91e","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:00:11.483Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"2d531f96-080b-4694-8c51-844012b6dfbd","codeBlocks":[{"uri":{"scheme":"file","authority":"","path":"/c:/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1","query":"","fragment":"","_formatted":"file:///c%3A/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1","_fsPath":"c:\\Users\\user\\Downloads\\Cursor_working_directory_misc\\USB-Inventory.ps1"},"codeblockId":"44dfbaec-3417-4658-b3ed-e2a1d993f9e5","codeBlockIdx":0,"content":"#requires -Version 5.1\n\u003c#\n.SYNOPSIS\n    USB-portable PC hardware inventory collection and analysis tool.\n\n.DESCRIPTION\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\n    script. Optionally runs health analysis to detect duplicates, stale assets,\n    low RAM, and missing monitor data.\n\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\n\n.PARAMETER OutputFile\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\n\n.PARAMETER IncludePciDevices\n    Include detailed PCI device enumeration (can produce large output).\n\n.PARAMETER Analyze\n    After collection, run health analysis on the CSV file.\n\n.PARAMETER AnalyzeOnly\n    Skip collection; only run health analysis on existing CSV.\n\n.PARAMETER StaleDays\n    Threshold in days for flagging stale assets. Default: 90.\n\n.PARAMETER MinRamGB\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\n\n.PARAMETER NoCsv\n    Do not output Inventory_Issues_Report.csv (text report only).\n\n.EXAMPLE\n    .\\USB-Inventory.ps1\n    Collect inventory from this PC into PC_Inventory_Master.csv.\n\n.EXAMPLE\n    .\\USB-Inventory.ps1 -IncludePciDevices -Analyze\n    Collect inventory with PCI devices, then run health analysis.\n\n.EXAMPLE\n    .\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\n    Analyze existing CSV with custom thresholds (no new collection).\n#\u003e\n\n[CmdletBinding()]\nparam(\n    [string]$OutputFile,\n    [switch]$IncludePciDevices,\n    [switch]$Analyze,\n    [switch]$AnalyzeOnly,\n    [int]$StaleDays = 90,\n    [int]$MinRamGB = 8,\n    [switch]$NoCsv\n)\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = \u0027Stop\u0027\n\n# Resolve script root (handles -File invocation where $PSScriptRoot may be empty)\n$ScriptDir = $PSScriptRoot\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\n    $ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition\n}\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\n    $ScriptDir = $PWD.Path\n}\n\n# Default OutputFile if not specified\nif ([string]::IsNullOrWhiteSpace($OutputFile)) {\n    $OutputFile = Join-Path -Path $ScriptDir -ChildPath \u0027PC_Inventory_Master.csv\u0027\n}\n\n# ============================================================================\n# HELPER FUNCTIONS - COLLECTION\n# ============================================================================\n\nfunction Clean-Cell {\n    param([AllowNull()][string]$Text)\n    if ($null -eq $Text) { return \u0027\u0027 }\n    return ($Text -replace \"(`r`n|`n|`r|`t)+\", \u0027 \u0027).Trim()\n}\n\nfunction Convert-UShortArrayToString {\n    param([AllowNull()]$Arr)\n    if ($null -eq $Arr) { return \u0027\u0027 }\n    $chars = foreach ($x in $Arr) {\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\n    }\n    return ( -join $chars ).Trim()\n}\n\nfunction Get-MonitorInventory {\n    \u003c#\n      Preferred: root\\wmi:WmiMonitorID (easy, consistent, usually no admin)\n      Fallback: registry EDID decode under HKLM:\\SYSTEM\\CCS\\Enum\\DISPLAY\n    #\u003e\n\n    $results = New-Object System.Collections.Generic.List[string]\n\n    # --- Preferred path: WmiMonitorID ---\n    try {\n        $wmiMons = Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorID -ErrorAction Stop\n        foreach ($m in $wmiMons) {\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\n\n            $label = @()\n            if ($mfg)  { $label += $mfg }\n            if ($name) { $label += $name }\n\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\n            $serialPart  = if ($sn) { \"SN:$sn\" } else { \u0027SN:(none)\u0027 }\n\n            $results.Add(\"$displayName ($serialPart)\")\n        }\n    } catch {\n        # WmiMonitorID not available; fall through to EDID fallback\n    }\n\n    if ($results.Count -gt 0) {\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n    }\n\n    # --- Fallback path: registry EDID decode ---\n    function Get-EdidDescriptorString {\n        param(\n            [byte[]]$Edid,\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\n        )\n\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\n\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\n\n        foreach ($offset in 54,72,90,108) {\n            if (($offset + 18) -gt $Edid.Length) { continue }\n\n            # Descriptor: 00 00 00 {tag} 00 ...\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\n\n                $bytes = $Edid[($offset+5)..($offset+17)]\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\n                $text = ($text -replace \"[`0`n`r]+\", \u0027\u0027).Trim()\n                if ($text) { return $text }\n            }\n        }\n\n        return \u0027\u0027\n    }\n\n    try {\n        $root = \u0027HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\DISPLAY\u0027\n        if (Test-Path -LiteralPath $root) {\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\n                    if (Test-Path -LiteralPath $params) {\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\n                        if ($edid -is [byte[]]) {\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\n\n                            # Numeric serial (bytes 12-15 LE) sometimes present\n                            $num = [BitConverter]::ToUInt32($edid, 12)\n                            $numStr = if ($num -ne 0) { \"NUM:$num\" } else { \u0027\u0027 }\n\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\n                            $serialPart  = if ($sn) { \"SN:$sn\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\n\n                            $results.Add(\"$displayName ($serialPart)\")\n                        }\n                    }\n                }\n            }\n        }\n    } catch {\n        # EDID fallback failed silently\n    }\n\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-NetworkInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\n\n    if ($hasNetAdapter -and $hasNetIpCfg) {\n        try {\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\n            foreach ($a in $adapters) {\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\n                $ipv4 = @()\n                if ($cfg -and $cfg.IPv4Address) {\n                    $ipv4 = $cfg.IPv4Address |\n                        ForEach-Object { $_.IPAddress } |\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\n                }\n                $gw = @()\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\n                }\n\n                $parts = @()\n                $parts += (Clean-Cell $a.Name)\n                if ($a.MacAddress) { $parts += \"MAC:$($a.MacAddress)\" }\n                if ($ipv4.Count -gt 0) { $parts += (\"IPv4:\" + ($ipv4 -join \u0027;\u0027)) }\n                if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n                $items.Add(($parts -join \u0027 \u0027))\n            }\n        } catch {\n            # Fall back to CIM below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\n            Where-Object { $_.IPEnabled -eq $true }\n\n        foreach ($n in $net) {\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\n            $mac  = $n.MACAddress\n            $ips  = @()\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\n            $gw   = @()\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\n\n            $parts = @()\n            $parts += (Clean-Cell $name)\n            if ($mac) { $parts += \"MAC:$mac\" }\n            if ($ips.Count -gt 0) { $parts += (\"IP:\" + ($ips -join \u0027;\u0027)) }\n            if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n            $items.Add(($parts -join \u0027 \u0027))\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-GpuInventory {\n    $gpus = New-Object System.Collections.Generic.List[string]\n\n    # CIM GPUs\n    try {\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\n        foreach ($g in $vc) {\n            $name = Clean-Cell $g.Name\n            $pnp  = Clean-Cell $g.PNPDeviceID\n            if ($name -or $pnp) {\n                $gpus.Add((\"{0}{1}\" -f $name, $(if ($pnp) { \" [ID:$pnp]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    # Optional NVIDIA serials if nvidia-smi exists\n    try {\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\n        if ($nvsmi) {\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\n            foreach ($line in @($raw)) {\n                $t = Clean-Cell $line\n                if ($t) { $gpus.Add(\"NVIDIA $t\") }\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-DiskInventory {\n    $disks = New-Object System.Collections.Generic.List[string]\n\n    # Prefer Storage module when available\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\n    if ($hasPhysicalDisk) {\n        try {\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\n                $name = Clean-Cell $d.FriendlyName\n                $sn   = Clean-Cell $d.SerialNumber\n                $mt   = Clean-Cell ([string]$d.MediaType)\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n                $parts = @()\n                if ($name) { $parts += $name }\n                if ($sn)   { $parts += \"SN:$sn\" }\n                if ($mt)   { $parts += \"Type:$mt\" }\n                if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n            }\n        } catch {\n            # Fall back below\n        }\n    }\n\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\n            $model = Clean-Cell $d.Model\n            $sn = \u0027\u0027\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\n            $devId = Clean-Cell $d.DeviceID\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n            $parts = @()\n            if ($model) { $parts += $model }\n            if ($sn)    { $parts += \"SN:$sn\" }\n            if ($devId) { $parts += \"Dev:$devId\" }\n            if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-PciDeviceInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\n    if ($hasGetPnpDevice) {\n        try {\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\n                Where-Object { $_.InstanceId -like \u0027PCI\\*\u0027 } |\n                Sort-Object -Property Class, FriendlyName, Name\n\n            foreach ($d in $devs) {\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\n                $name = Clean-Cell $name\n                $cls  = Clean-Cell $d.Class\n                $id   = Clean-Cell $d.InstanceId\n                if ($name -or $id) {\n                    $items.Add((\"{0}{1}{2}\" -f $name, $(if ($cls) { \" [Class:$cls]\" } else { \u0027\u0027 }), $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n                }\n            }\n        } catch {\n            # Fall back below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM Win32_PnPEntity\n    try {\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\*\u0027 } |\n            Sort-Object -Property Name\n\n        foreach ($d in $devs) {\n            $name = Clean-Cell $d.Name\n            $id   = Clean-Cell $d.PNPDeviceID\n            if ($name -or $id) {\n                $items.Add((\"{0}{1}\" -f $name, $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\n# ============================================================================\n# HELPER FUNCTIONS - ANALYSIS\n# ============================================================================\n\nfunction Get-ColumnMap {\n    param([string[]]$Headers)\n\n    $map = @{\n        Hostname        = \u0027Hostname\u0027\n        User            = \u0027User\u0027\n        System_Serial   = \u0027System_Serial\u0027\n        RAM_GB          = \u0027RAM_GB\u0027\n        Monitor_Serials = \u0027Monitor_Serials\u0027\n        Scan_Date       = \u0027Scan_Date\u0027\n    }\n\n    foreach ($k in @($map.Keys)) {\n        if ($Headers -notcontains $map[$k]) {\n            $alts = switch ($k) {\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\n                default           { @() }\n            }\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\n            if ($found) { $map[$k] = $found }\n        }\n    }\n\n    return $map\n}\n\nfunction Parse-ScanDate {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    $dt = $null\n\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\n\n    if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\n\n    return $null\n}\n\nfunction Normalize-Serial {\n    param([AllowNull()][string]$Serial)\n\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\n    $s = ($Serial.Trim())\n\n    $bad = @(\n        \u0027To Be Filled By O.E.M.\u0027,\n        \u0027To Be Filled By OEM\u0027,\n        \u0027Default string\u0027,\n        \u0027System Serial Number\u0027,\n        \u0027None\u0027,\n        \u0027N/A\u0027,\n        \u0027NA\u0027,\n        \u00270\u0027,\n        \u002700000000\u0027,\n        \u00270000000000\u0027,\n        \u00270000000000000000\u0027\n    )\n\n    if ($bad -contains $s) { return \u0027\u0027 }\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\n\n    return $s.ToUpperInvariant()\n}\n\nfunction Parse-RamGB {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    $m = [regex]::Match($s, \u0027(\\d+)(\\.\\d+)?\u0027)\n    if (-not $m.Success) { return $null }\n\n    $n = $null\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\n        return [int][math]::Round($n, 0)\n    }\n\n    return $null\n}\n\nfunction Is-MonitorMissing {\n    param([AllowNull()][string]$Value)\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\n    $t = $Value.Trim()\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\n}\n\n# ============================================================================\n# MAIN: COLLECTION\n# ============================================================================\n\nfunction Invoke-Collection {\n    param([string]$OutPath, [switch]$IncludePci)\n\n    $errors = New-Object System.Collections.Generic.List[string]\n\n    Write-Host \"`n========================================================\" -ForegroundColor Cyan\n    Write-Host \"   GATHERING HARDWARE SPECS... PLEASE WAIT\" -ForegroundColor Cyan\n    Write-Host \"========================================================\" -ForegroundColor Cyan\n\n    # --- Collect core system info ---\n    $sys  = $null\n    $bios = $null\n    $cpu  = $null\n    $os   = $null\n    $bb   = $null\n\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_ComputerSystem: $($_.Exception.Message)\") }\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\"Win32_BIOS: $($_.Exception.Message)\") }\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_Processor: $($_.Exception.Message)\") }\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_OperatingSystem: $($_.Exception.Message)\") }\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_BaseBoard: $($_.Exception.Message)\") }\n\n    # --- Derived values ---\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\n\n    $ramGB = $null\n    try {\n        if ($sys -and $sys.TotalPhysicalMemory) {\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\n        }\n    } catch {\n        $errors.Add(\"RAM calc: $($_.Exception.Message)\")\n    }\n\n    # --- Other sections ---\n    $netStr  = \u0027\u0027\n    $gpuStr  = \u0027\u0027\n    $diskStr = \u0027\u0027\n    $monStr  = \u0027\u0027\n    $pciStr  = \u0027\u0027\n\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\"Network: $($_.Exception.Message)\") }\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\"GPU: $($_.Exception.Message)\") }\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\"Disks: $($_.Exception.Message)\") }\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\"Monitors: $($_.Exception.Message)\") }\n\n    if ($IncludePci) {\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\"PCI devices: $($_.Exception.Message)\") }\n    }\n\n    # Pre-compute BIOS release date (inline try-catch not reliable in PS 5.1)\n    $biosReleaseDate = \u0027\u0027\n    try {\n        if ($bios -and $bios.ReleaseDate) {\n            $biosReleaseDate = ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027)\n        }\n    } catch {\n        $biosReleaseDate = \u0027\u0027\n    }\n\n    # --- Build record ---\n    $record = [pscustomobject]@{\n        Hostname          = Clean-Cell $hostname\n        User              = Clean-Cell $env:USERNAME\n\n        Make_Model        = Clean-Cell ((\"{0} {1}\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\n\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\n        Baseboard_Product = Clean-Cell ($bb.Product)\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\n\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\n        BIOS_ReleaseDate  = Clean-Cell $biosReleaseDate\n\n        OS_Caption        = Clean-Cell ($os.Caption)\n        OS_Version        = Clean-Cell ($os.Version)\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\n\n        CPU               = Clean-Cell ($cpu.Name)\n        RAM_GB            = $ramGB\n\n        Network_Adapters  = Clean-Cell $netStr\n        GPUs              = Clean-Cell $gpuStr\n        Disk_Serials      = Clean-Cell $diskStr\n        Monitor_Serials   = Clean-Cell $monStr\n\n        PCI_Devices       = Clean-Cell $pciStr\n\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\n        Collector_Version = \u00272.0\u0027\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\n    }\n\n    # --- CSV append with header safety ---\n    $needHeader = $true\n    if (Test-Path -LiteralPath $OutPath) {\n        try {\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\n            if ($fi.Length -gt 0) { $needHeader = $false }\n        } catch { $needHeader = $true }\n    }\n\n    if ($needHeader) {\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\n    } else {\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\n    }\n\n    Write-Host \"`nSUCCESS!\" -ForegroundColor Green\n    Write-Host \"Data saved to: $OutPath\" -ForegroundColor Gray\n    if ($record.Errors) {\n        Write-Host (\"Warnings captured in Errors column: {0}\" -f $record.Errors) -ForegroundColor Yellow\n    }\n}\n\n# ============================================================================\n# MAIN: ANALYSIS\n# ============================================================================\n\nfunction Invoke-Analysis {\n    param(\n        [string]$InputPath,\n        [int]$StaleDaysThreshold,\n        [int]$MinRam,\n        [switch]$SkipCsv,\n        [string]$BaseDir\n    )\n\n    $ReportFile = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.txt\u0027\n    $IssuesCsv  = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.csv\u0027\n\n    if (-not (Test-Path -LiteralPath $InputPath)) {\n        Write-Warning \"Input file not found: $InputPath\"\n        Write-Warning \"Run the script without -AnalyzeOnly first to collect data.\"\n        return\n    }\n\n    $raw = Import-Csv -LiteralPath $InputPath\n    if (-not $raw -or $raw.Count -eq 0) {\n        Write-Warning \"Input file contains no rows: $InputPath\"\n        return\n    }\n\n    $headers = @()\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\n    $col = Get-ColumnMap -Headers $headers\n\n    $today = Get-Date\n\n    # Normalize data and add helper properties\n    $data = foreach ($r in $raw) {\n        $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\n        $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\n        $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\n        $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\n        $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\n        $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\n\n        $serialN = Normalize-Serial $serial\n        $scanDt  = Parse-ScanDate $scan\n        $ramGb   = Parse-RamGB $ram\n\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\n\n        # Asset key: prefer System Serial, fallback to Hostname\n        $assetKey = \u0027\u0027\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\n            $assetKey = $serialN\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\n            $assetKey = $h.Trim().ToUpperInvariant()\n        }\n\n        [pscustomobject]@{\n            Hostname        = $h.Trim()\n            User            = $u.Trim()\n            System_Serial   = $serialN\n            RAM_GB          = $ramGb\n            Monitor_Serials = $m.Trim()\n            Scan_Date       = $s.Trim()\n\n            ScanDateParsed  = $scanDt\n            AssetKey        = $assetKey\n            RawRow          = $r\n        }\n    }\n\n    # Latest record per asset\n    $latestByAsset = $data |\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\n        Group-Object -Property AssetKey |\n        ForEach-Object { $_.Group | Select-Object -First 1 }\n\n    $issues = New-Object System.Collections.Generic.List[object]\n\n    function Add-Issue {\n        param(\n            [Parameter(Mandatory)][string]$IssueType,\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\n            [string]$AssetKey,\n            [string]$Hostname,\n            [string]$User,\n            [string]$SystemSerial,\n            [string]$ScanDate,\n            [string]$Details\n        )\n\n        $issues.Add([pscustomobject]@{\n            IssueType     = $IssueType\n            Severity      = $Severity\n            AssetKey      = $AssetKey\n            Hostname      = $Hostname\n            User          = $User\n            System_Serial = $SystemSerial\n            Scan_Date     = $ScanDate\n            Details       = $Details\n        })\n    }\n\n    # 0) Data quality (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\n        }\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\n        }\n        if (-not $pc.ScanDateParsed) {\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\n        }\n    }\n\n    # 1) Duplicate serials (all rows; ignore blanks)\n    $dupeGroups = $data |\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\n        Group-Object -Property System_Serial |\n        Where-Object { $_.Count -gt 1 }\n\n    foreach ($g in $dupeGroups) {\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\n\n        $severity =\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\n            else { \u0027Info\u0027 }\n\n        $entries = $g.Group |\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\n            ForEach-Object {\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\n                \"{0} ({1})\" -f $_.Hostname, $d\n            }\n\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\n    }\n\n    # 2) Low RAM (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\"RAM_GB={0} (min {1})\" -f $pc.RAM_GB, $MinRam)\n        } elseif ($null -eq $pc.RAM_GB) {\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\n        }\n    }\n\n    # 3) Stale assets (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ($pc.ScanDateParsed) {\n            $ageDays = ($today - $pc.ScanDateParsed).Days\n            if ($ageDays -gt $StaleDaysThreshold) {\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\"Last seen {0} days ago (threshold {1})\" -f $ageDays, $StaleDaysThreshold)\n            }\n        }\n    }\n\n    # 4) Missing monitor serials (latest records)\n    foreach ($pc in $latestByAsset) {\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\n        }\n    }\n\n    # --- Build text report ---\n    $generated = Get-Date\n    $line = (\u0027=\u0027 * 70)\n\n    $txt = New-Object System.Collections.Generic.List[string]\n    $txt.Add($line)\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\n    $txt.Add(\"Generated: $generated\")\n    $txt.Add(\"Input:     $InputPath\")\n    $txt.Add((\"Assets:    {0} (latest per asset)\" -f $latestByAsset.Count))\n    $txt.Add((\"Rows:      {0} (raw rows in CSV)\" -f $data.Count))\n    $txt.Add((\"Settings:  MinRamGB={0}, StaleDays={1}\" -f $MinRam, $StaleDaysThreshold))\n    $txt.Add($line)\n    $txt.Add(\u0027\u0027)\n\n    if ($issues.Count -eq 0) {\n        $txt.Add(\u0027No issues found.\u0027)\n    } else {\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\n        foreach ($t in $byType) {\n            $txt.Add((\"--- {0} ({1}) ---\" -f $t.Name, $t.Count))\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\n\n                $txt.Add((\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\n            }\n            $txt.Add(\u0027\u0027)\n        }\n    }\n\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\n\n    if (-not $SkipCsv) {\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\n    }\n\n    # --- Console summary ---\n    Write-Host \"`n$line\" -ForegroundColor Cyan\n    Write-Host (\"Report saved: {0}\" -f $ReportFile) -ForegroundColor Green\n    if (-not $SkipCsv) { Write-Host (\"Issues CSV:   {0}\" -f $IssuesCsv) -ForegroundColor Green }\n    Write-Host (\"Issues found: {0}\" -f $issues.Count) -ForegroundColor Yellow\n    Write-Host $line -ForegroundColor Cyan\n\n    if ($issues.Count -gt 0) {\n        $sev = $issues | Group-Object Severity | Sort-Object Name\n        foreach ($s in $sev) {\n            $c = switch ($s.Name) {\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\n                default    { [ConsoleColor]::Gray }\n            }\n            Write-Host (\"{0}: {1}\" -f $s.Name, $s.Count) -ForegroundColor $c\n        }\n    }\n}\n\n# ============================================================================\n# ENTRY POINT\n# ============================================================================\n\nif (-not $AnalyzeOnly) {\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\n}\n\nif ($Analyze -or $AnalyzeOnly) {\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv -BaseDir $ScriptDir\n}\n\nif (-not $AnalyzeOnly -and -not $Analyze) {\n    Write-Host \"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\" -ForegroundColor DarkGray\n}\n\n","languageId":"powershell"}],"capabilityType":15,"toolFormerData":{"tool":38,"toolCallId":"toolu_vrtx_016Uj5RWnHFV6LswGpxe9UHa","toolIndex":1,"modelCallId":"084e2d7c-41cc-4c9b-94e4-789855578047","status":"completed","rawArgs":"{\"file_path\": \"USB-Inventory.ps1\", \"old_string\": \"    if ($IncludePci) {\\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\\\"PCI devices: $($_.Exception.Message)\\\") }\\n    }\\n\\n    # --- Build record ---\\n    $record = [pscustomobject]@{\\n        Hostname          = Clean-Cell $hostname\\n        User              = Clean-Cell $env:USERNAME\\n\\n        Make_Model        = Clean-Cell ((\\\"{0} {1}\\\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\\n\\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\\n        Baseboard_Product = Clean-Cell ($bb.Product)\\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\\n\\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\\n        BIOS_ReleaseDate  = Clean-Cell (try { ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027) } catch { \u0027\u0027 })\", \"new_string\": \"    if ($IncludePci) {\\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\\\"PCI devices: $($_.Exception.Message)\\\") }\\n    }\\n\\n    # Pre-compute BIOS release date (inline try-catch not reliable in PS 5.1)\\n    $biosReleaseDate = \u0027\u0027\\n    try {\\n        if ($bios -and $bios.ReleaseDate) {\\n            $biosReleaseDate = ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027)\\n        }\\n    } catch {\\n        $biosReleaseDate = \u0027\u0027\\n    }\\n\\n    # --- Build record ---\\n    $record = [pscustomobject]@{\\n        Hostname          = Clean-Cell $hostname\\n        User              = Clean-Cell $env:USERNAME\\n\\n        Make_Model        = Clean-Cell ((\\\"{0} {1}\\\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\\n\\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\\n        Baseboard_Product = Clean-Cell ($bb.Product)\\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\\n\\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\\n        BIOS_ReleaseDate  = Clean-Cell $biosReleaseDate\"}","name":"search_replace","params":"{\"relativeWorkspacePath\":\"USB-Inventory.ps1\"}","additionalData":{"codeblockId":"44dfbaec-3417-4658-b3ed-e2a1d993f9e5"},"userDecision":"accepted","result":"{\"diff\":{\"chunks\":[{\"diffString\":\"          try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\\\"PCI devices: $($_.Exception.Message)\\\") }\\n      }\\n+ \\n+     # Pre-compute BIOS release date (inline try-catch not reliable in PS 5.1)\\n+     $biosReleaseDate = \u0027\u0027\\n+     try {\\n+         if ($bios -and $bios.ReleaseDate) {\\n+             $biosReleaseDate = ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027)\\n+         }\\n+     } catch {\\n+         $biosReleaseDate = \u0027\u0027\\n+     }\\n  \\n      # --- Build record ---\",\"oldStart\":543,\"newStart\":543,\"oldLines\":4,\"newLines\":14,\"linesAdded\":10},{\"diffString\":\"  \\n          BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\\n-         BIOS_ReleaseDate  = Clean-Cell (try { ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027) } catch { \u0027\u0027 })\\n+         BIOS_ReleaseDate  = Clean-Cell $biosReleaseDate\\n  \\n          OS_Caption        = Clean-Cell ($os.Caption)\",\"oldStart\":557,\"newStart\":567,\"oldLines\":5,\"newLines\":5,\"linesRemoved\":1,\"linesAdded\":1}],\"editor\":\"EDITOR_AI\"},\"shouldAutoFixLints\":true,\"resultForModel\":\"The file USB-Inventory.ps1 has been updated.\",\"contentsAfterEdit\":\"#requires -Version 5.1\\n\u003c#\\n.SYNOPSIS\\n    USB-portable PC hardware inventory collection and analysis tool.\\n\\n.DESCRIPTION\\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\\n    script. Optionally runs health analysis to detect duplicates, stale assets,\\n    low RAM, and missing monitor data.\\n\\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\\n\\n.PARAMETER OutputFile\\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\\n\\n.PARAMETER IncludePciDevices\\n    Include detailed PCI device enumeration (can produce large output).\\n\\n.PARAMETER Analyze\\n    After collection, run health analysis on the CSV file.\\n\\n.PARAMETER AnalyzeOnly\\n    Skip collection; only run health analysis on existing CSV.\\n\\n.PARAMETER StaleDays\\n    Threshold in days for flagging stale assets. Default: 90.\\n\\n.PARAMETER MinRamGB\\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\\n\\n.PARAMETER NoCsv\\n    Do not output Inventory_Issues_Report.csv (text report only).\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1\\n    Collect inventory from this PC into PC_Inventory_Master.csv.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -IncludePciDevices -Analyze\\n    Collect inventory with PCI devices, then run health analysis.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\\n    Analyze existing CSV with custom thresholds (no new collection).\\n#\u003e\\n\\n[CmdletBinding()]\\nparam(\\n    [string]$OutputFile,\\n    [switch]$IncludePciDevices,\\n    [switch]$Analyze,\\n    [switch]$AnalyzeOnly,\\n    [int]$StaleDays = 90,\\n    [int]$MinRamGB = 8,\\n    [switch]$NoCsv\\n)\\n\\nSet-StrictMode -Version Latest\\n$ErrorActionPreference = \u0027Stop\u0027\\n\\n# Resolve script root (handles -File invocation where $PSScriptRoot may be empty)\\n$ScriptDir = $PSScriptRoot\\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n    $ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition\\n}\\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n    $ScriptDir = $PWD.Path\\n}\\n\\n# Default OutputFile if not specified\\nif ([string]::IsNullOrWhiteSpace($OutputFile)) {\\n    $OutputFile = Join-Path -Path $ScriptDir -ChildPath \u0027PC_Inventory_Master.csv\u0027\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - COLLECTION\\n# ============================================================================\\n\\nfunction Clean-Cell {\\n    param([AllowNull()][string]$Text)\\n    if ($null -eq $Text) { return \u0027\u0027 }\\n    return ($Text -replace \\\"(`r`n|`n|`r|`t)+\\\", \u0027 \u0027).Trim()\\n}\\n\\nfunction Convert-UShortArrayToString {\\n    param([AllowNull()]$Arr)\\n    if ($null -eq $Arr) { return \u0027\u0027 }\\n    $chars = foreach ($x in $Arr) {\\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\\n    }\\n    return ( -join $chars ).Trim()\\n}\\n\\nfunction Get-MonitorInventory {\\n    \u003c#\\n      Preferred: root\\\\wmi:WmiMonitorID (easy, consistent, usually no admin)\\n      Fallback: registry EDID decode under HKLM:\\\\SYSTEM\\\\CCS\\\\Enum\\\\DISPLAY\\n    #\u003e\\n\\n    $results = New-Object System.Collections.Generic.List[string]\\n\\n    # --- Preferred path: WmiMonitorID ---\\n    try {\\n        $wmiMons = Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorID -ErrorAction Stop\\n        foreach ($m in $wmiMons) {\\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\\n\\n            $label = @()\\n            if ($mfg)  { $label += $mfg }\\n            if ($name) { $label += $name }\\n\\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\\n            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } else { \u0027SN:(none)\u0027 }\\n\\n            $results.Add(\\\"$displayName ($serialPart)\\\")\\n        }\\n    } catch {\\n        # WmiMonitorID not available; fall through to EDID fallback\\n    }\\n\\n    if ($results.Count -gt 0) {\\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n    }\\n\\n    # --- Fallback path: registry EDID decode ---\\n    function Get-EdidDescriptorString {\\n        param(\\n            [byte[]]$Edid,\\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\\n        )\\n\\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\\n\\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\\n\\n        foreach ($offset in 54,72,90,108) {\\n            if (($offset + 18) -gt $Edid.Length) { continue }\\n\\n            # Descriptor: 00 00 00 {tag} 00 ...\\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\\n\\n                $bytes = $Edid[($offset+5)..($offset+17)]\\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\\n                $text = ($text -replace \\\"[`0`n`r]+\\\", \u0027\u0027).Trim()\\n                if ($text) { return $text }\\n            }\\n        }\\n\\n        return \u0027\u0027\\n    }\\n\\n    try {\\n        $root = \u0027HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Enum\\\\DISPLAY\u0027\\n        if (Test-Path -LiteralPath $root) {\\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\\n                    if (Test-Path -LiteralPath $params) {\\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\\n                        if ($edid -is [byte[]]) {\\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\\n\\n                            # Numeric serial (bytes 12-15 LE) sometimes present\\n                            $num = [BitConverter]::ToUInt32($edid, 12)\\n                            $numStr = if ($num -ne 0) { \\\"NUM:$num\\\" } else { \u0027\u0027 }\\n\\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\\n                            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\\n\\n                            $results.Add(\\\"$displayName ($serialPart)\\\")\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    } catch {\\n        # EDID fallback failed silently\\n    }\\n\\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-NetworkInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\\n\\n    if ($hasNetAdapter -and $hasNetIpCfg) {\\n        try {\\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\\n            foreach ($a in $adapters) {\\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\\n                $ipv4 = @()\\n                if ($cfg -and $cfg.IPv4Address) {\\n                    $ipv4 = $cfg.IPv4Address |\\n                        ForEach-Object { $_.IPAddress } |\\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\\n                }\\n                $gw = @()\\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\\n                }\\n\\n                $parts = @()\\n                $parts += (Clean-Cell $a.Name)\\n                if ($a.MacAddress) { $parts += \\\"MAC:$($a.MacAddress)\\\" }\\n                if ($ipv4.Count -gt 0) { $parts += (\\\"IPv4:\\\" + ($ipv4 -join \u0027;\u0027)) }\\n                if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n                $items.Add(($parts -join \u0027 \u0027))\\n            }\\n        } catch {\\n            # Fall back to CIM below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\\n            Where-Object { $_.IPEnabled -eq $true }\\n\\n        foreach ($n in $net) {\\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\\n            $mac  = $n.MACAddress\\n            $ips  = @()\\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\\n            $gw   = @()\\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\\n\\n            $parts = @()\\n            $parts += (Clean-Cell $name)\\n            if ($mac) { $parts += \\\"MAC:$mac\\\" }\\n            if ($ips.Count -gt 0) { $parts += (\\\"IP:\\\" + ($ips -join \u0027;\u0027)) }\\n            if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n            $items.Add(($parts -join \u0027 \u0027))\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-GpuInventory {\\n    $gpus = New-Object System.Collections.Generic.List[string]\\n\\n    # CIM GPUs\\n    try {\\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\\n        foreach ($g in $vc) {\\n            $name = Clean-Cell $g.Name\\n            $pnp  = Clean-Cell $g.PNPDeviceID\\n            if ($name -or $pnp) {\\n                $gpus.Add((\\\"{0}{1}\\\" -f $name, $(if ($pnp) { \\\" [ID:$pnp]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    # Optional NVIDIA serials if nvidia-smi exists\\n    try {\\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\\n        if ($nvsmi) {\\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\\n            foreach ($line in @($raw)) {\\n                $t = Clean-Cell $line\\n                if ($t) { $gpus.Add(\\\"NVIDIA $t\\\") }\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-DiskInventory {\\n    $disks = New-Object System.Collections.Generic.List[string]\\n\\n    # Prefer Storage module when available\\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasPhysicalDisk) {\\n        try {\\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\\n                $name = Clean-Cell $d.FriendlyName\\n                $sn   = Clean-Cell $d.SerialNumber\\n                $mt   = Clean-Cell ([string]$d.MediaType)\\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n                $parts = @()\\n                if ($name) { $parts += $name }\\n                if ($sn)   { $parts += \\\"SN:$sn\\\" }\\n                if ($mt)   { $parts += \\\"Type:$mt\\\" }\\n                if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\\n            $model = Clean-Cell $d.Model\\n            $sn = \u0027\u0027\\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\\n            $devId = Clean-Cell $d.DeviceID\\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n            $parts = @()\\n            if ($model) { $parts += $model }\\n            if ($sn)    { $parts += \\\"SN:$sn\\\" }\\n            if ($devId) { $parts += \\\"Dev:$devId\\\" }\\n            if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-PciDeviceInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasGetPnpDevice) {\\n        try {\\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\\n                Where-Object { $_.InstanceId -like \u0027PCI\\\\*\u0027 } |\\n                Sort-Object -Property Class, FriendlyName, Name\\n\\n            foreach ($d in $devs) {\\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\\n                $name = Clean-Cell $name\\n                $cls  = Clean-Cell $d.Class\\n                $id   = Clean-Cell $d.InstanceId\\n                if ($name -or $id) {\\n                    $items.Add((\\\"{0}{1}{2}\\\" -f $name, $(if ($cls) { \\\" [Class:$cls]\\\" } else { \u0027\u0027 }), $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n                }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM Win32_PnPEntity\\n    try {\\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\\\*\u0027 } |\\n            Sort-Object -Property Name\\n\\n        foreach ($d in $devs) {\\n            $name = Clean-Cell $d.Name\\n            $id   = Clean-Cell $d.PNPDeviceID\\n            if ($name -or $id) {\\n                $items.Add((\\\"{0}{1}\\\" -f $name, $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - ANALYSIS\\n# ============================================================================\\n\\nfunction Get-ColumnMap {\\n    param([string[]]$Headers)\\n\\n    $map = @{\\n        Hostname        = \u0027Hostname\u0027\\n        User            = \u0027User\u0027\\n        System_Serial   = \u0027System_Serial\u0027\\n        RAM_GB          = \u0027RAM_GB\u0027\\n        Monitor_Serials = \u0027Monitor_Serials\u0027\\n        Scan_Date       = \u0027Scan_Date\u0027\\n    }\\n\\n    foreach ($k in @($map.Keys)) {\\n        if ($Headers -notcontains $map[$k]) {\\n            $alts = switch ($k) {\\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\\n                default           { @() }\\n            }\\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\\n            if ($found) { $map[$k] = $found }\\n        }\\n    }\\n\\n    return $map\\n}\\n\\nfunction Parse-ScanDate {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    $dt = $null\\n\\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n\\n    if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\\n\\n    return $null\\n}\\n\\nfunction Normalize-Serial {\\n    param([AllowNull()][string]$Serial)\\n\\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\\n    $s = ($Serial.Trim())\\n\\n    $bad = @(\\n        \u0027To Be Filled By O.E.M.\u0027,\\n        \u0027To Be Filled By OEM\u0027,\\n        \u0027Default string\u0027,\\n        \u0027System Serial Number\u0027,\\n        \u0027None\u0027,\\n        \u0027N/A\u0027,\\n        \u0027NA\u0027,\\n        \u00270\u0027,\\n        \u002700000000\u0027,\\n        \u00270000000000\u0027,\\n        \u00270000000000000000\u0027\\n    )\\n\\n    if ($bad -contains $s) { return \u0027\u0027 }\\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\\n\\n    return $s.ToUpperInvariant()\\n}\\n\\nfunction Parse-RamGB {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    $m = [regex]::Match($s, \u0027(\\\\d+)(\\\\.\\\\d+)?\u0027)\\n    if (-not $m.Success) { return $null }\\n\\n    $n = $null\\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\\n        return [int][math]::Round($n, 0)\\n    }\\n\\n    return $null\\n}\\n\\nfunction Is-MonitorMissing {\\n    param([AllowNull()][string]$Value)\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\\n    $t = $Value.Trim()\\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\\n}\\n\\n# ============================================================================\\n# MAIN: COLLECTION\\n# ============================================================================\\n\\nfunction Invoke-Collection {\\n    param([string]$OutPath, [switch]$IncludePci)\\n\\n    $errors = New-Object System.Collections.Generic.List[string]\\n\\n    Write-Host \\\"`n========================================================\\\" -ForegroundColor Cyan\\n    Write-Host \\\"   GATHERING HARDWARE SPECS... PLEASE WAIT\\\" -ForegroundColor Cyan\\n    Write-Host \\\"========================================================\\\" -ForegroundColor Cyan\\n\\n    # --- Collect core system info ---\\n    $sys  = $null\\n    $bios = $null\\n    $cpu  = $null\\n    $os   = $null\\n    $bb   = $null\\n\\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_ComputerSystem: $($_.Exception.Message)\\\") }\\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\\\"Win32_BIOS: $($_.Exception.Message)\\\") }\\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_Processor: $($_.Exception.Message)\\\") }\\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_OperatingSystem: $($_.Exception.Message)\\\") }\\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_BaseBoard: $($_.Exception.Message)\\\") }\\n\\n    # --- Derived values ---\\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\\n\\n    $ramGB = $null\\n    try {\\n        if ($sys -and $sys.TotalPhysicalMemory) {\\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\\n        }\\n    } catch {\\n        $errors.Add(\\\"RAM calc: $($_.Exception.Message)\\\")\\n    }\\n\\n    # --- Other sections ---\\n    $netStr  = \u0027\u0027\\n    $gpuStr  = \u0027\u0027\\n    $diskStr = \u0027\u0027\\n    $monStr  = \u0027\u0027\\n    $pciStr  = \u0027\u0027\\n\\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\\\"Network: $($_.Exception.Message)\\\") }\\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\\\"GPU: $($_.Exception.Message)\\\") }\\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\\\"Disks: $($_.Exception.Message)\\\") }\\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\\\"Monitors: $($_.Exception.Message)\\\") }\\n\\n    if ($IncludePci) {\\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\\\"PCI devices: $($_.Exception.Message)\\\") }\\n    }\\n\\n    # Pre-compute BIOS release date (inline try-catch not reliable in PS 5.1)\\n    $biosReleaseDate = \u0027\u0027\\n    try {\\n        if ($bios -and $bios.ReleaseDate) {\\n            $biosReleaseDate = ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027)\\n        }\\n    } catch {\\n        $biosReleaseDate = \u0027\u0027\\n    }\\n\\n    # --- Build record ---\\n    $record = [pscustomobject]@{\\n        Hostname          = Clean-Cell $hostname\\n        User              = Clean-Cell $env:USERNAME\\n\\n        Make_Model        = Clean-Cell ((\\\"{0} {1}\\\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\\n\\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\\n        Baseboard_Product = Clean-Cell ($bb.Product)\\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\\n\\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\\n        BIOS_ReleaseDate  = Clean-Cell $biosReleaseDate\\n\\n        OS_Caption        = Clean-Cell ($os.Caption)\\n        OS_Version        = Clean-Cell ($os.Version)\\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\\n\\n        CPU               = Clean-Cell ($cpu.Name)\\n        RAM_GB            = $ramGB\\n\\n        Network_Adapters  = Clean-Cell $netStr\\n        GPUs              = Clean-Cell $gpuStr\\n        Disk_Serials      = Clean-Cell $diskStr\\n        Monitor_Serials   = Clean-Cell $monStr\\n\\n        PCI_Devices       = Clean-Cell $pciStr\\n\\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\\n        Collector_Version = \u00272.0\u0027\\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\\n    }\\n\\n    # --- CSV append with header safety ---\\n    $needHeader = $true\\n    if (Test-Path -LiteralPath $OutPath) {\\n        try {\\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\\n            if ($fi.Length -gt 0) { $needHeader = $false }\\n        } catch { $needHeader = $true }\\n    }\\n\\n    if ($needHeader) {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\\n    } else {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\\n    }\\n\\n    Write-Host \\\"`nSUCCESS!\\\" -ForegroundColor Green\\n    Write-Host \\\"Data saved to: $OutPath\\\" -ForegroundColor Gray\\n    if ($record.Errors) {\\n        Write-Host (\\\"Warnings captured in Errors column: {0}\\\" -f $record.Errors) -ForegroundColor Yellow\\n    }\\n}\\n\\n# ============================================================================\\n# MAIN: ANALYSIS\\n# ============================================================================\\n\\nfunction Invoke-Analysis {\\n    param(\\n        [string]$InputPath,\\n        [int]$StaleDaysThreshold,\\n        [int]$MinRam,\\n        [switch]$SkipCsv,\\n        [string]$BaseDir\\n    )\\n\\n    $ReportFile = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.txt\u0027\\n    $IssuesCsv  = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.csv\u0027\\n\\n    if (-not (Test-Path -LiteralPath $InputPath)) {\\n        Write-Warning \\\"Input file not found: $InputPath\\\"\\n        Write-Warning \\\"Run the script without -AnalyzeOnly first to collect data.\\\"\\n        return\\n    }\\n\\n    $raw = Import-Csv -LiteralPath $InputPath\\n    if (-not $raw -or $raw.Count -eq 0) {\\n        Write-Warning \\\"Input file contains no rows: $InputPath\\\"\\n        return\\n    }\\n\\n    $headers = @()\\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\\n    $col = Get-ColumnMap -Headers $headers\\n\\n    $today = Get-Date\\n\\n    # Normalize data and add helper properties\\n    $data = foreach ($r in $raw) {\\n        $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\\n        $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\\n        $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\\n        $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\\n        $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\\n        $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\\n\\n        $serialN = Normalize-Serial $serial\\n        $scanDt  = Parse-ScanDate $scan\\n        $ramGb   = Parse-RamGB $ram\\n\\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\\n\\n        # Asset key: prefer System Serial, fallback to Hostname\\n        $assetKey = \u0027\u0027\\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\\n            $assetKey = $serialN\\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\\n            $assetKey = $h.Trim().ToUpperInvariant()\\n        }\\n\\n        [pscustomobject]@{\\n            Hostname        = $h.Trim()\\n            User            = $u.Trim()\\n            System_Serial   = $serialN\\n            RAM_GB          = $ramGb\\n            Monitor_Serials = $m.Trim()\\n            Scan_Date       = $s.Trim()\\n\\n            ScanDateParsed  = $scanDt\\n            AssetKey        = $assetKey\\n            RawRow          = $r\\n        }\\n    }\\n\\n    # Latest record per asset\\n    $latestByAsset = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\\n        Group-Object -Property AssetKey |\\n        ForEach-Object { $_.Group | Select-Object -First 1 }\\n\\n    $issues = New-Object System.Collections.Generic.List[object]\\n\\n    function Add-Issue {\\n        param(\\n            [Parameter(Mandatory)][string]$IssueType,\\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\\n            [string]$AssetKey,\\n            [string]$Hostname,\\n            [string]$User,\\n            [string]$SystemSerial,\\n            [string]$ScanDate,\\n            [string]$Details\\n        )\\n\\n        $issues.Add([pscustomobject]@{\\n            IssueType     = $IssueType\\n            Severity      = $Severity\\n            AssetKey      = $AssetKey\\n            Hostname      = $Hostname\\n            User          = $User\\n            System_Serial = $SystemSerial\\n            Scan_Date     = $ScanDate\\n            Details       = $Details\\n        })\\n    }\\n\\n    # 0) Data quality (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\\n        }\\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\\n        }\\n        if (-not $pc.ScanDateParsed) {\\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\\n        }\\n    }\\n\\n    # 1) Duplicate serials (all rows; ignore blanks)\\n    $dupeGroups = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\\n        Group-Object -Property System_Serial |\\n        Where-Object { $_.Count -gt 1 }\\n\\n    foreach ($g in $dupeGroups) {\\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\\n\\n        $severity =\\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\\n            else { \u0027Info\u0027 }\\n\\n        $entries = $g.Group |\\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\\n            ForEach-Object {\\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\\n                \\\"{0} ({1})\\\" -f $_.Hostname, $d\\n            }\\n\\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\\\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\\\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\\n    }\\n\\n    # 2) Low RAM (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\\\"RAM_GB={0} (min {1})\\\" -f $pc.RAM_GB, $MinRam)\\n        } elseif ($null -eq $pc.RAM_GB) {\\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\\n        }\\n    }\\n\\n    # 3) Stale assets (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($pc.ScanDateParsed) {\\n            $ageDays = ($today - $pc.ScanDateParsed).Days\\n            if ($ageDays -gt $StaleDaysThreshold) {\\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\\\"Last seen {0} days ago (threshold {1})\\\" -f $ageDays, $StaleDaysThreshold)\\n            }\\n        }\\n    }\\n\\n    # 4) Missing monitor serials (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\\n        }\\n    }\\n\\n    # --- Build text report ---\\n    $generated = Get-Date\\n    $line = (\u0027=\u0027 * 70)\\n\\n    $txt = New-Object System.Collections.Generic.List[string]\\n    $txt.Add($line)\\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\\n    $txt.Add(\\\"Generated: $generated\\\")\\n    $txt.Add(\\\"Input:     $InputPath\\\")\\n    $txt.Add((\\\"Assets:    {0} (latest per asset)\\\" -f $latestByAsset.Count))\\n    $txt.Add((\\\"Rows:      {0} (raw rows in CSV)\\\" -f $data.Count))\\n    $txt.Add((\\\"Settings:  MinRamGB={0}, StaleDays={1}\\\" -f $MinRam, $StaleDaysThreshold))\\n    $txt.Add($line)\\n    $txt.Add(\u0027\u0027)\\n\\n    if ($issues.Count -eq 0) {\\n        $txt.Add(\u0027No issues found.\u0027)\\n    } else {\\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\\n        foreach ($t in $byType) {\\n            $txt.Add((\\\"--- {0} ({1}) ---\\\" -f $t.Name, $t.Count))\\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\\n\\n                $txt.Add((\\\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\\\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\\n            }\\n            $txt.Add(\u0027\u0027)\\n        }\\n    }\\n\\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\\n\\n    if (-not $SkipCsv) {\\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\\n    }\\n\\n    # --- Console summary ---\\n    Write-Host \\\"`n$line\\\" -ForegroundColor Cyan\\n    Write-Host (\\\"Report saved: {0}\\\" -f $ReportFile) -ForegroundColor Green\\n    if (-not $SkipCsv) { Write-Host (\\\"Issues CSV:   {0}\\\" -f $IssuesCsv) -ForegroundColor Green }\\n    Write-Host (\\\"Issues found: {0}\\\" -f $issues.Count) -ForegroundColor Yellow\\n    Write-Host $line -ForegroundColor Cyan\\n\\n    if ($issues.Count -gt 0) {\\n        $sev = $issues | Group-Object Severity | Sort-Object Name\\n        foreach ($s in $sev) {\\n            $c = switch ($s.Name) {\\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\\n                default    { [ConsoleColor]::Gray }\\n            }\\n            Write-Host (\\\"{0}: {1}\\\" -f $s.Name, $s.Count) -ForegroundColor $c\\n        }\\n    }\\n}\\n\\n# ============================================================================\\n# ENTRY POINT\\n# ============================================================================\\n\\nif (-not $AnalyzeOnly) {\\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\\n}\\n\\nif ($Analyze -or $AnalyzeOnly) {\\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv -BaseDir $ScriptDir\\n}\\n\\nif (-not $AnalyzeOnly -and -not $Analyze) {\\n    Write-Host \\\"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\\\" -ForegroundColor DarkGray\\n}\\n\\n\"}"},"checkpointId":"8f90d85a-613b-4114-819a-d421ba04d0ed"},"bubbleId":"e27dce98-9c52-4b61-b735-d0563eb5a91e"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"e4c5b6e9-c97f-430d-8ac6-597927dc5cfa","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:01:17.199Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"af06e54b-e699-4ebe-b525-d1b8fb1c6f58","codeBlocks":[{"uri":{"scheme":"file","authority":"","path":"/c:/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1","query":"","fragment":"","_formatted":"file:///c%3A/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1","_fsPath":"c:\\Users\\user\\Downloads\\Cursor_working_directory_misc\\USB-Inventory.ps1"},"codeblockId":"6e7581de-cba0-43fd-aaba-c0b7ebd82119","codeBlockIdx":0,"content":"#requires -Version 5.1\n\u003c#\n.SYNOPSIS\n    USB-portable PC hardware inventory collection and analysis tool.\n\n.DESCRIPTION\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\n    script. Optionally runs health analysis to detect duplicates, stale assets,\n    low RAM, and missing monitor data.\n\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\n\n.PARAMETER OutputFile\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\n\n.PARAMETER IncludePciDevices\n    Include detailed PCI device enumeration (can produce large output).\n\n.PARAMETER Analyze\n    After collection, run health analysis on the CSV file.\n\n.PARAMETER AnalyzeOnly\n    Skip collection; only run health analysis on existing CSV.\n\n.PARAMETER StaleDays\n    Threshold in days for flagging stale assets. Default: 90.\n\n.PARAMETER MinRamGB\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\n\n.PARAMETER NoCsv\n    Do not output Inventory_Issues_Report.csv (text report only).\n\n.EXAMPLE\n    .\\USB-Inventory.ps1\n    Collect inventory from this PC into PC_Inventory_Master.csv.\n\n.EXAMPLE\n    .\\USB-Inventory.ps1 -IncludePciDevices -Analyze\n    Collect inventory with PCI devices, then run health analysis.\n\n.EXAMPLE\n    .\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\n    Analyze existing CSV with custom thresholds (no new collection).\n#\u003e\n\n[CmdletBinding()]\nparam(\n    [string]$OutputFile,\n    [switch]$IncludePciDevices,\n    [switch]$Analyze,\n    [switch]$AnalyzeOnly,\n    [int]$StaleDays = 90,\n    [int]$MinRamGB = 8,\n    [switch]$NoCsv\n)\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = \u0027Stop\u0027\n\n# Resolve script root (handles -File invocation where $PSScriptRoot may be empty)\n$ScriptDir = $PSScriptRoot\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\n    $ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition\n}\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\n    $ScriptDir = $PWD.Path\n}\n\n# Default OutputFile if not specified\nif ([string]::IsNullOrWhiteSpace($OutputFile)) {\n    $OutputFile = Join-Path -Path $ScriptDir -ChildPath \u0027PC_Inventory_Master.csv\u0027\n}\n\n# ============================================================================\n# HELPER FUNCTIONS - COLLECTION\n# ============================================================================\n\nfunction Clean-Cell {\n    param([AllowNull()][string]$Text)\n    if ($null -eq $Text) { return \u0027\u0027 }\n    return ($Text -replace \"(`r`n|`n|`r|`t)+\", \u0027 \u0027).Trim()\n}\n\nfunction Convert-UShortArrayToString {\n    param([AllowNull()]$Arr)\n    if ($null -eq $Arr) { return \u0027\u0027 }\n    $chars = foreach ($x in $Arr) {\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\n    }\n    return ( -join $chars ).Trim()\n}\n\nfunction Get-MonitorInventory {\n    \u003c#\n      Preferred: root\\wmi:WmiMonitorID (easy, consistent, usually no admin)\n      Fallback: registry EDID decode under HKLM:\\SYSTEM\\CCS\\Enum\\DISPLAY\n    #\u003e\n\n    $results = New-Object System.Collections.Generic.List[string]\n\n    # --- Preferred path: WmiMonitorID ---\n    try {\n        $wmiMons = Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorID -ErrorAction Stop\n        foreach ($m in $wmiMons) {\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\n\n            $label = @()\n            if ($mfg)  { $label += $mfg }\n            if ($name) { $label += $name }\n\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\n            $serialPart  = if ($sn) { \"SN:$sn\" } else { \u0027SN:(none)\u0027 }\n\n            $results.Add(\"$displayName ($serialPart)\")\n        }\n    } catch {\n        # WmiMonitorID not available; fall through to EDID fallback\n    }\n\n    if ($results.Count -gt 0) {\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n    }\n\n    # --- Fallback path: registry EDID decode ---\n    function Get-EdidDescriptorString {\n        param(\n            [byte[]]$Edid,\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\n        )\n\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\n\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\n\n        foreach ($offset in 54,72,90,108) {\n            if (($offset + 18) -gt $Edid.Length) { continue }\n\n            # Descriptor: 00 00 00 {tag} 00 ...\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\n\n                $bytes = $Edid[($offset+5)..($offset+17)]\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\n                $text = ($text -replace \"[`0`n`r]+\", \u0027\u0027).Trim()\n                if ($text) { return $text }\n            }\n        }\n\n        return \u0027\u0027\n    }\n\n    try {\n        $root = \u0027HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\DISPLAY\u0027\n        if (Test-Path -LiteralPath $root) {\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\n                    if (Test-Path -LiteralPath $params) {\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\n                        if ($edid -is [byte[]]) {\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\n\n                            # Numeric serial (bytes 12-15 LE) sometimes present\n                            $num = [BitConverter]::ToUInt32($edid, 12)\n                            $numStr = if ($num -ne 0) { \"NUM:$num\" } else { \u0027\u0027 }\n\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\n                            $serialPart  = if ($sn) { \"SN:$sn\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\n\n                            $results.Add(\"$displayName ($serialPart)\")\n                        }\n                    }\n                }\n            }\n        }\n    } catch {\n        # EDID fallback failed silently\n    }\n\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-NetworkInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\n\n    if ($hasNetAdapter -and $hasNetIpCfg) {\n        try {\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\n            foreach ($a in $adapters) {\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\n                $ipv4 = @()\n                if ($cfg -and $cfg.IPv4Address) {\n                    $ipv4 = $cfg.IPv4Address |\n                        ForEach-Object { $_.IPAddress } |\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\n                }\n                $gw = @()\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\n                }\n\n                $parts = @()\n                $parts += (Clean-Cell $a.Name)\n                if ($a.MacAddress) { $parts += \"MAC:$($a.MacAddress)\" }\n                if ($ipv4.Count -gt 0) { $parts += (\"IPv4:\" + ($ipv4 -join \u0027;\u0027)) }\n                if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n                $items.Add(($parts -join \u0027 \u0027))\n            }\n        } catch {\n            # Fall back to CIM below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\n            Where-Object { $_.IPEnabled -eq $true }\n\n        foreach ($n in $net) {\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\n            $mac  = $n.MACAddress\n            $ips  = @()\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\n            $gw   = @()\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\n\n            $parts = @()\n            $parts += (Clean-Cell $name)\n            if ($mac) { $parts += \"MAC:$mac\" }\n            if ($ips.Count -gt 0) { $parts += (\"IP:\" + ($ips -join \u0027;\u0027)) }\n            if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n            $items.Add(($parts -join \u0027 \u0027))\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-GpuInventory {\n    $gpus = New-Object System.Collections.Generic.List[string]\n\n    # CIM GPUs\n    try {\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\n        foreach ($g in $vc) {\n            $name = Clean-Cell $g.Name\n            $pnp  = Clean-Cell $g.PNPDeviceID\n            if ($name -or $pnp) {\n                $gpus.Add((\"{0}{1}\" -f $name, $(if ($pnp) { \" [ID:$pnp]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    # Optional NVIDIA serials if nvidia-smi exists\n    try {\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\n        if ($nvsmi) {\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\n            foreach ($line in @($raw)) {\n                $t = Clean-Cell $line\n                if ($t) { $gpus.Add(\"NVIDIA $t\") }\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-DiskInventory {\n    $disks = New-Object System.Collections.Generic.List[string]\n\n    # Prefer Storage module when available\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\n    if ($hasPhysicalDisk) {\n        try {\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\n                $name = Clean-Cell $d.FriendlyName\n                $sn   = Clean-Cell $d.SerialNumber\n                $mt   = Clean-Cell ([string]$d.MediaType)\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n                $parts = @()\n                if ($name) { $parts += $name }\n                if ($sn)   { $parts += \"SN:$sn\" }\n                if ($mt)   { $parts += \"Type:$mt\" }\n                if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n            }\n        } catch {\n            # Fall back below\n        }\n    }\n\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\n            $model = Clean-Cell $d.Model\n            $sn = \u0027\u0027\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\n            $devId = Clean-Cell $d.DeviceID\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n            $parts = @()\n            if ($model) { $parts += $model }\n            if ($sn)    { $parts += \"SN:$sn\" }\n            if ($devId) { $parts += \"Dev:$devId\" }\n            if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-PciDeviceInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\n    if ($hasGetPnpDevice) {\n        try {\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\n                Where-Object { $_.InstanceId -like \u0027PCI\\*\u0027 } |\n                Sort-Object -Property Class, FriendlyName, Name\n\n            foreach ($d in $devs) {\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\n                $name = Clean-Cell $name\n                $cls  = Clean-Cell $d.Class\n                $id   = Clean-Cell $d.InstanceId\n                if ($name -or $id) {\n                    $items.Add((\"{0}{1}{2}\" -f $name, $(if ($cls) { \" [Class:$cls]\" } else { \u0027\u0027 }), $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n                }\n            }\n        } catch {\n            # Fall back below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM Win32_PnPEntity\n    try {\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\*\u0027 } |\n            Sort-Object -Property Name\n\n        foreach ($d in $devs) {\n            $name = Clean-Cell $d.Name\n            $id   = Clean-Cell $d.PNPDeviceID\n            if ($name -or $id) {\n                $items.Add((\"{0}{1}\" -f $name, $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\n# ============================================================================\n# HELPER FUNCTIONS - ANALYSIS\n# ============================================================================\n\nfunction Get-ColumnMap {\n    param([string[]]$Headers)\n\n    $map = @{\n        Hostname        = \u0027Hostname\u0027\n        User            = \u0027User\u0027\n        System_Serial   = \u0027System_Serial\u0027\n        RAM_GB          = \u0027RAM_GB\u0027\n        Monitor_Serials = \u0027Monitor_Serials\u0027\n        Scan_Date       = \u0027Scan_Date\u0027\n    }\n\n    foreach ($k in @($map.Keys)) {\n        if ($Headers -notcontains $map[$k]) {\n            $alts = switch ($k) {\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\n                default           { @() }\n            }\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\n            if ($found) { $map[$k] = $found }\n        }\n    }\n\n    return $map\n}\n\nfunction Parse-ScanDate {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    # Try common date formats\n    $formats = @(\u0027yyyy-MM-dd\u0027, \u0027yyyy-MM-dd HH:mm:ss\u0027, \u0027MM/dd/yyyy\u0027, \u0027dd/MM/yyyy\u0027)\n    foreach ($fmt in $formats) {\n        try {\n            $result = [datetime]::ParseExact($s, $fmt, [System.Globalization.CultureInfo]::InvariantCulture)\n            return $result\n        } catch {\n            # Continue to next format\n        }\n    }\n\n    # Fallback: general parse\n    try {\n        return [datetime]::Parse($s)\n    } catch {\n        return $null\n    }\n}\n\nfunction Normalize-Serial {\n    param([AllowNull()][string]$Serial)\n\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\n    $s = ($Serial.Trim())\n\n    $bad = @(\n        \u0027To Be Filled By O.E.M.\u0027,\n        \u0027To Be Filled By OEM\u0027,\n        \u0027Default string\u0027,\n        \u0027System Serial Number\u0027,\n        \u0027None\u0027,\n        \u0027N/A\u0027,\n        \u0027NA\u0027,\n        \u00270\u0027,\n        \u002700000000\u0027,\n        \u00270000000000\u0027,\n        \u00270000000000000000\u0027\n    )\n\n    if ($bad -contains $s) { return \u0027\u0027 }\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\n\n    return $s.ToUpperInvariant()\n}\n\nfunction Parse-RamGB {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    $m = [regex]::Match($s, \u0027(\\d+)(\\.\\d+)?\u0027)\n    if (-not $m.Success) { return $null }\n\n    $n = $null\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\n        return [int][math]::Round($n, 0)\n    }\n\n    return $null\n}\n\nfunction Is-MonitorMissing {\n    param([AllowNull()][string]$Value)\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\n    $t = $Value.Trim()\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\n}\n\n# ============================================================================\n# MAIN: COLLECTION\n# ============================================================================\n\nfunction Invoke-Collection {\n    param([string]$OutPath, [switch]$IncludePci)\n\n    $errors = New-Object System.Collections.Generic.List[string]\n\n    Write-Host \"`n========================================================\" -ForegroundColor Cyan\n    Write-Host \"   GATHERING HARDWARE SPECS... PLEASE WAIT\" -ForegroundColor Cyan\n    Write-Host \"========================================================\" -ForegroundColor Cyan\n\n    # --- Collect core system info ---\n    $sys  = $null\n    $bios = $null\n    $cpu  = $null\n    $os   = $null\n    $bb   = $null\n\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_ComputerSystem: $($_.Exception.Message)\") }\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\"Win32_BIOS: $($_.Exception.Message)\") }\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_Processor: $($_.Exception.Message)\") }\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_OperatingSystem: $($_.Exception.Message)\") }\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_BaseBoard: $($_.Exception.Message)\") }\n\n    # --- Derived values ---\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\n\n    $ramGB = $null\n    try {\n        if ($sys -and $sys.TotalPhysicalMemory) {\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\n        }\n    } catch {\n        $errors.Add(\"RAM calc: $($_.Exception.Message)\")\n    }\n\n    # --- Other sections ---\n    $netStr  = \u0027\u0027\n    $gpuStr  = \u0027\u0027\n    $diskStr = \u0027\u0027\n    $monStr  = \u0027\u0027\n    $pciStr  = \u0027\u0027\n\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\"Network: $($_.Exception.Message)\") }\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\"GPU: $($_.Exception.Message)\") }\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\"Disks: $($_.Exception.Message)\") }\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\"Monitors: $($_.Exception.Message)\") }\n\n    if ($IncludePci) {\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\"PCI devices: $($_.Exception.Message)\") }\n    }\n\n    # Pre-compute BIOS release date (inline try-catch not reliable in PS 5.1)\n    $biosReleaseDate = \u0027\u0027\n    try {\n        if ($bios -and $bios.ReleaseDate) {\n            $biosReleaseDate = ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027)\n        }\n    } catch {\n        $biosReleaseDate = \u0027\u0027\n    }\n\n    # --- Build record ---\n    $record = [pscustomobject]@{\n        Hostname          = Clean-Cell $hostname\n        User              = Clean-Cell $env:USERNAME\n\n        Make_Model        = Clean-Cell ((\"{0} {1}\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\n\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\n        Baseboard_Product = Clean-Cell ($bb.Product)\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\n\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\n        BIOS_ReleaseDate  = Clean-Cell $biosReleaseDate\n\n        OS_Caption        = Clean-Cell ($os.Caption)\n        OS_Version        = Clean-Cell ($os.Version)\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\n\n        CPU               = Clean-Cell ($cpu.Name)\n        RAM_GB            = $ramGB\n\n        Network_Adapters  = Clean-Cell $netStr\n        GPUs              = Clean-Cell $gpuStr\n        Disk_Serials      = Clean-Cell $diskStr\n        Monitor_Serials   = Clean-Cell $monStr\n\n        PCI_Devices       = Clean-Cell $pciStr\n\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\n        Collector_Version = \u00272.0\u0027\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\n    }\n\n    # --- CSV append with header safety ---\n    $needHeader = $true\n    if (Test-Path -LiteralPath $OutPath) {\n        try {\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\n            if ($fi.Length -gt 0) { $needHeader = $false }\n        } catch { $needHeader = $true }\n    }\n\n    if ($needHeader) {\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\n    } else {\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\n    }\n\n    Write-Host \"`nSUCCESS!\" -ForegroundColor Green\n    Write-Host \"Data saved to: $OutPath\" -ForegroundColor Gray\n    if ($record.Errors) {\n        Write-Host (\"Warnings captured in Errors column: {0}\" -f $record.Errors) -ForegroundColor Yellow\n    }\n}\n\n# ============================================================================\n# MAIN: ANALYSIS\n# ============================================================================\n\nfunction Invoke-Analysis {\n    param(\n        [string]$InputPath,\n        [int]$StaleDaysThreshold,\n        [int]$MinRam,\n        [switch]$SkipCsv,\n        [string]$BaseDir\n    )\n\n    $ReportFile = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.txt\u0027\n    $IssuesCsv  = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.csv\u0027\n\n    if (-not (Test-Path -LiteralPath $InputPath)) {\n        Write-Warning \"Input file not found: $InputPath\"\n        Write-Warning \"Run the script without -AnalyzeOnly first to collect data.\"\n        return\n    }\n\n    $raw = Import-Csv -LiteralPath $InputPath\n    if (-not $raw -or $raw.Count -eq 0) {\n        Write-Warning \"Input file contains no rows: $InputPath\"\n        return\n    }\n\n    $headers = @()\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\n    $col = Get-ColumnMap -Headers $headers\n\n    $today = Get-Date\n\n    # Normalize data and add helper properties\n    $data = foreach ($r in $raw) {\n        $hostname = if (@($r.PSObject.Properties.Match($col.Hostname)).Count -gt 0) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\n        $user     = if (@($r.PSObject.Properties.Match($col.User)).Count -gt 0)     { [string]$r.($col.User) } else { \u0027\u0027 }\n        $serial   = if (@($r.PSObject.Properties.Match($col.System_Serial)).Count -gt 0) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\n        $ram      = if (@($r.PSObject.Properties.Match($col.RAM_GB)).Count -gt 0)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\n        $mon      = if (@($r.PSObject.Properties.Match($col.Monitor_Serials)).Count -gt 0) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\n        $scan     = if (@($r.PSObject.Properties.Match($col.Scan_Date)).Count -gt 0) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\n\n        $serialN = Normalize-Serial $serial\n        $scanDt  = Parse-ScanDate $scan\n        $ramGb   = Parse-RamGB $ram\n\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\n\n        # Asset key: prefer System Serial, fallback to Hostname\n        $assetKey = \u0027\u0027\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\n            $assetKey = $serialN\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\n            $assetKey = $h.Trim().ToUpperInvariant()\n        }\n\n        [pscustomobject]@{\n            Hostname        = $h.Trim()\n            User            = $u.Trim()\n            System_Serial   = $serialN\n            RAM_GB          = $ramGb\n            Monitor_Serials = $m.Trim()\n            Scan_Date       = $s.Trim()\n\n            ScanDateParsed  = $scanDt\n            AssetKey        = $assetKey\n            RawRow          = $r\n        }\n    }\n\n    # Latest record per asset\n    $latestByAsset = $data |\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\n        Group-Object -Property AssetKey |\n        ForEach-Object { $_.Group | Select-Object -First 1 }\n\n    $issues = New-Object System.Collections.Generic.List[object]\n\n    function Add-Issue {\n        param(\n            [Parameter(Mandatory)][string]$IssueType,\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\n            [string]$AssetKey,\n            [string]$Hostname,\n            [string]$User,\n            [string]$SystemSerial,\n            [string]$ScanDate,\n            [string]$Details\n        )\n\n        $issues.Add([pscustomobject]@{\n            IssueType     = $IssueType\n            Severity      = $Severity\n            AssetKey      = $AssetKey\n            Hostname      = $Hostname\n            User          = $User\n            System_Serial = $SystemSerial\n            Scan_Date     = $ScanDate\n            Details       = $Details\n        })\n    }\n\n    # 0) Data quality (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\n        }\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\n        }\n        if (-not $pc.ScanDateParsed) {\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\n        }\n    }\n\n    # 1) Duplicate serials (all rows; ignore blanks)\n    $dupeGroups = $data |\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\n        Group-Object -Property System_Serial |\n        Where-Object { $_.Count -gt 1 }\n\n    foreach ($g in $dupeGroups) {\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\n\n        $severity =\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\n            else { \u0027Info\u0027 }\n\n        $entries = $g.Group |\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\n            ForEach-Object {\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\n                \"{0} ({1})\" -f $_.Hostname, $d\n            }\n\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\n    }\n\n    # 2) Low RAM (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\"RAM_GB={0} (min {1})\" -f $pc.RAM_GB, $MinRam)\n        } elseif ($null -eq $pc.RAM_GB) {\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\n        }\n    }\n\n    # 3) Stale assets (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ($pc.ScanDateParsed) {\n            $ageDays = ($today - $pc.ScanDateParsed).Days\n            if ($ageDays -gt $StaleDaysThreshold) {\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\"Last seen {0} days ago (threshold {1})\" -f $ageDays, $StaleDaysThreshold)\n            }\n        }\n    }\n\n    # 4) Missing monitor serials (latest records)\n    foreach ($pc in $latestByAsset) {\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\n        }\n    }\n\n    # --- Build text report ---\n    $generated = Get-Date\n    $line = (\u0027=\u0027 * 70)\n\n    $txt = New-Object System.Collections.Generic.List[string]\n    $txt.Add($line)\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\n    $txt.Add(\"Generated: $generated\")\n    $txt.Add(\"Input:     $InputPath\")\n    $txt.Add((\"Assets:    {0} (latest per asset)\" -f $latestByAsset.Count))\n    $txt.Add((\"Rows:      {0} (raw rows in CSV)\" -f $data.Count))\n    $txt.Add((\"Settings:  MinRamGB={0}, StaleDays={1}\" -f $MinRam, $StaleDaysThreshold))\n    $txt.Add($line)\n    $txt.Add(\u0027\u0027)\n\n    if ($issues.Count -eq 0) {\n        $txt.Add(\u0027No issues found.\u0027)\n    } else {\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\n        foreach ($t in $byType) {\n            $txt.Add((\"--- {0} ({1}) ---\" -f $t.Name, $t.Count))\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\n\n                $txt.Add((\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\n            }\n            $txt.Add(\u0027\u0027)\n        }\n    }\n\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\n\n    if (-not $SkipCsv) {\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\n    }\n\n    # --- Console summary ---\n    Write-Host \"`n$line\" -ForegroundColor Cyan\n    Write-Host (\"Report saved: {0}\" -f $ReportFile) -ForegroundColor Green\n    if (-not $SkipCsv) { Write-Host (\"Issues CSV:   {0}\" -f $IssuesCsv) -ForegroundColor Green }\n    Write-Host (\"Issues found: {0}\" -f $issues.Count) -ForegroundColor Yellow\n    Write-Host $line -ForegroundColor Cyan\n\n    if ($issues.Count -gt 0) {\n        $sev = $issues | Group-Object Severity | Sort-Object Name\n        foreach ($s in $sev) {\n            $c = switch ($s.Name) {\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\n                default    { [ConsoleColor]::Gray }\n            }\n            Write-Host (\"{0}: {1}\" -f $s.Name, $s.Count) -ForegroundColor $c\n        }\n    }\n}\n\n# ============================================================================\n# ENTRY POINT\n# ============================================================================\n\nif (-not $AnalyzeOnly) {\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\n}\n\nif ($Analyze -or $AnalyzeOnly) {\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv -BaseDir $ScriptDir\n}\n\nif (-not $AnalyzeOnly -and -not $Analyze) {\n    Write-Host \"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\" -ForegroundColor DarkGray\n}\n\n","languageId":"powershell"}],"capabilityType":15,"toolFormerData":{"tool":38,"toolCallId":"toolu_vrtx_01Toe8wGUYoaFEmkV2tUX5aL","toolIndex":1,"modelCallId":"0a561ee9-5a3d-4702-8687-02ecfcb98bbd","status":"completed","rawArgs":"{\"file_path\": \"USB-Inventory.ps1\", \"old_string\": \"    $data = foreach ($r in $raw) {\\n        $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\\n        $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\\n        $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\\n        $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\\n        $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\\n        $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\", \"new_string\": \"    $data = foreach ($r in $raw) {\\n        $hostname = if (@($r.PSObject.Properties.Match($col.Hostname)).Count -gt 0) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\\n        $user     = if (@($r.PSObject.Properties.Match($col.User)).Count -gt 0)     { [string]$r.($col.User) } else { \u0027\u0027 }\\n        $serial   = if (@($r.PSObject.Properties.Match($col.System_Serial)).Count -gt 0) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\\n        $ram      = if (@($r.PSObject.Properties.Match($col.RAM_GB)).Count -gt 0)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\\n        $mon      = if (@($r.PSObject.Properties.Match($col.Monitor_Serials)).Count -gt 0) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\\n        $scan     = if (@($r.PSObject.Properties.Match($col.Scan_Date)).Count -gt 0) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\"}","name":"search_replace","params":"{\"relativeWorkspacePath\":\"USB-Inventory.ps1\"}","additionalData":{"codeblockId":"6e7581de-cba0-43fd-aaba-c0b7ebd82119"},"userDecision":"accepted","result":"{\"diff\":{\"chunks\":[{\"diffString\":\"      # Normalize data and add helper properties\\n      $data = foreach ($r in $raw) {\\n-         $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\\n-         $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\\n-         $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\\n-         $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\\n-         $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\\n-         $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\\n+         $hostname = if (@($r.PSObject.Properties.Match($col.Hostname)).Count -gt 0) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\\n+         $user     = if (@($r.PSObject.Properties.Match($col.User)).Count -gt 0)     { [string]$r.($col.User) } else { \u0027\u0027 }\\n+         $serial   = if (@($r.PSObject.Properties.Match($col.System_Serial)).Count -gt 0) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\\n+         $ram      = if (@($r.PSObject.Properties.Match($col.RAM_GB)).Count -gt 0)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\\n+         $mon      = if (@($r.PSObject.Properties.Match($col.Monitor_Serials)).Count -gt 0) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\\n+         $scan     = if (@($r.PSObject.Properties.Match($col.Scan_Date)).Count -gt 0) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\\n  \\n          $serialN = Normalize-Serial $serial\",\"oldStart\":656,\"newStart\":656,\"oldLines\":10,\"newLines\":10,\"linesRemoved\":6,\"linesAdded\":6}],\"editor\":\"EDITOR_AI\"},\"shouldAutoFixLints\":true,\"resultForModel\":\"The file USB-Inventory.ps1 has been updated.\",\"contentsAfterEdit\":\"#requires -Version 5.1\\n\u003c#\\n.SYNOPSIS\\n    USB-portable PC hardware inventory collection and analysis tool.\\n\\n.DESCRIPTION\\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\\n    script. Optionally runs health analysis to detect duplicates, stale assets,\\n    low RAM, and missing monitor data.\\n\\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\\n\\n.PARAMETER OutputFile\\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\\n\\n.PARAMETER IncludePciDevices\\n    Include detailed PCI device enumeration (can produce large output).\\n\\n.PARAMETER Analyze\\n    After collection, run health analysis on the CSV file.\\n\\n.PARAMETER AnalyzeOnly\\n    Skip collection; only run health analysis on existing CSV.\\n\\n.PARAMETER StaleDays\\n    Threshold in days for flagging stale assets. Default: 90.\\n\\n.PARAMETER MinRamGB\\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\\n\\n.PARAMETER NoCsv\\n    Do not output Inventory_Issues_Report.csv (text report only).\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1\\n    Collect inventory from this PC into PC_Inventory_Master.csv.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -IncludePciDevices -Analyze\\n    Collect inventory with PCI devices, then run health analysis.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\\n    Analyze existing CSV with custom thresholds (no new collection).\\n#\u003e\\n\\n[CmdletBinding()]\\nparam(\\n    [string]$OutputFile,\\n    [switch]$IncludePciDevices,\\n    [switch]$Analyze,\\n    [switch]$AnalyzeOnly,\\n    [int]$StaleDays = 90,\\n    [int]$MinRamGB = 8,\\n    [switch]$NoCsv\\n)\\n\\nSet-StrictMode -Version Latest\\n$ErrorActionPreference = \u0027Stop\u0027\\n\\n# Resolve script root (handles -File invocation where $PSScriptRoot may be empty)\\n$ScriptDir = $PSScriptRoot\\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n    $ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition\\n}\\nif ([string]::IsNullOrWhiteSpace($ScriptDir)) {\\n    $ScriptDir = $PWD.Path\\n}\\n\\n# Default OutputFile if not specified\\nif ([string]::IsNullOrWhiteSpace($OutputFile)) {\\n    $OutputFile = Join-Path -Path $ScriptDir -ChildPath \u0027PC_Inventory_Master.csv\u0027\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - COLLECTION\\n# ============================================================================\\n\\nfunction Clean-Cell {\\n    param([AllowNull()][string]$Text)\\n    if ($null -eq $Text) { return \u0027\u0027 }\\n    return ($Text -replace \\\"(`r`n|`n|`r|`t)+\\\", \u0027 \u0027).Trim()\\n}\\n\\nfunction Convert-UShortArrayToString {\\n    param([AllowNull()]$Arr)\\n    if ($null -eq $Arr) { return \u0027\u0027 }\\n    $chars = foreach ($x in $Arr) {\\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\\n    }\\n    return ( -join $chars ).Trim()\\n}\\n\\nfunction Get-MonitorInventory {\\n    \u003c#\\n      Preferred: root\\\\wmi:WmiMonitorID (easy, consistent, usually no admin)\\n      Fallback: registry EDID decode under HKLM:\\\\SYSTEM\\\\CCS\\\\Enum\\\\DISPLAY\\n    #\u003e\\n\\n    $results = New-Object System.Collections.Generic.List[string]\\n\\n    # --- Preferred path: WmiMonitorID ---\\n    try {\\n        $wmiMons = Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorID -ErrorAction Stop\\n        foreach ($m in $wmiMons) {\\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\\n\\n            $label = @()\\n            if ($mfg)  { $label += $mfg }\\n            if ($name) { $label += $name }\\n\\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\\n            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } else { \u0027SN:(none)\u0027 }\\n\\n            $results.Add(\\\"$displayName ($serialPart)\\\")\\n        }\\n    } catch {\\n        # WmiMonitorID not available; fall through to EDID fallback\\n    }\\n\\n    if ($results.Count -gt 0) {\\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n    }\\n\\n    # --- Fallback path: registry EDID decode ---\\n    function Get-EdidDescriptorString {\\n        param(\\n            [byte[]]$Edid,\\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\\n        )\\n\\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\\n\\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\\n\\n        foreach ($offset in 54,72,90,108) {\\n            if (($offset + 18) -gt $Edid.Length) { continue }\\n\\n            # Descriptor: 00 00 00 {tag} 00 ...\\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\\n\\n                $bytes = $Edid[($offset+5)..($offset+17)]\\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\\n                $text = ($text -replace \\\"[`0`n`r]+\\\", \u0027\u0027).Trim()\\n                if ($text) { return $text }\\n            }\\n        }\\n\\n        return \u0027\u0027\\n    }\\n\\n    try {\\n        $root = \u0027HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Enum\\\\DISPLAY\u0027\\n        if (Test-Path -LiteralPath $root) {\\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\\n                    if (Test-Path -LiteralPath $params) {\\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\\n                        if ($edid -is [byte[]]) {\\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\\n\\n                            # Numeric serial (bytes 12-15 LE) sometimes present\\n                            $num = [BitConverter]::ToUInt32($edid, 12)\\n                            $numStr = if ($num -ne 0) { \\\"NUM:$num\\\" } else { \u0027\u0027 }\\n\\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\\n                            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\\n\\n                            $results.Add(\\\"$displayName ($serialPart)\\\")\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    } catch {\\n        # EDID fallback failed silently\\n    }\\n\\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-NetworkInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\\n\\n    if ($hasNetAdapter -and $hasNetIpCfg) {\\n        try {\\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\\n            foreach ($a in $adapters) {\\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\\n                $ipv4 = @()\\n                if ($cfg -and $cfg.IPv4Address) {\\n                    $ipv4 = $cfg.IPv4Address |\\n                        ForEach-Object { $_.IPAddress } |\\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\\n                }\\n                $gw = @()\\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\\n                }\\n\\n                $parts = @()\\n                $parts += (Clean-Cell $a.Name)\\n                if ($a.MacAddress) { $parts += \\\"MAC:$($a.MacAddress)\\\" }\\n                if ($ipv4.Count -gt 0) { $parts += (\\\"IPv4:\\\" + ($ipv4 -join \u0027;\u0027)) }\\n                if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n                $items.Add(($parts -join \u0027 \u0027))\\n            }\\n        } catch {\\n            # Fall back to CIM below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\\n            Where-Object { $_.IPEnabled -eq $true }\\n\\n        foreach ($n in $net) {\\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\\n            $mac  = $n.MACAddress\\n            $ips  = @()\\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\\n            $gw   = @()\\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\\n\\n            $parts = @()\\n            $parts += (Clean-Cell $name)\\n            if ($mac) { $parts += \\\"MAC:$mac\\\" }\\n            if ($ips.Count -gt 0) { $parts += (\\\"IP:\\\" + ($ips -join \u0027;\u0027)) }\\n            if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n            $items.Add(($parts -join \u0027 \u0027))\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-GpuInventory {\\n    $gpus = New-Object System.Collections.Generic.List[string]\\n\\n    # CIM GPUs\\n    try {\\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\\n        foreach ($g in $vc) {\\n            $name = Clean-Cell $g.Name\\n            $pnp  = Clean-Cell $g.PNPDeviceID\\n            if ($name -or $pnp) {\\n                $gpus.Add((\\\"{0}{1}\\\" -f $name, $(if ($pnp) { \\\" [ID:$pnp]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    # Optional NVIDIA serials if nvidia-smi exists\\n    try {\\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\\n        if ($nvsmi) {\\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\\n            foreach ($line in @($raw)) {\\n                $t = Clean-Cell $line\\n                if ($t) { $gpus.Add(\\\"NVIDIA $t\\\") }\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-DiskInventory {\\n    $disks = New-Object System.Collections.Generic.List[string]\\n\\n    # Prefer Storage module when available\\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasPhysicalDisk) {\\n        try {\\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\\n                $name = Clean-Cell $d.FriendlyName\\n                $sn   = Clean-Cell $d.SerialNumber\\n                $mt   = Clean-Cell ([string]$d.MediaType)\\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n                $parts = @()\\n                if ($name) { $parts += $name }\\n                if ($sn)   { $parts += \\\"SN:$sn\\\" }\\n                if ($mt)   { $parts += \\\"Type:$mt\\\" }\\n                if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\\n            $model = Clean-Cell $d.Model\\n            $sn = \u0027\u0027\\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\\n            $devId = Clean-Cell $d.DeviceID\\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n            $parts = @()\\n            if ($model) { $parts += $model }\\n            if ($sn)    { $parts += \\\"SN:$sn\\\" }\\n            if ($devId) { $parts += \\\"Dev:$devId\\\" }\\n            if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-PciDeviceInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasGetPnpDevice) {\\n        try {\\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\\n                Where-Object { $_.InstanceId -like \u0027PCI\\\\*\u0027 } |\\n                Sort-Object -Property Class, FriendlyName, Name\\n\\n            foreach ($d in $devs) {\\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\\n                $name = Clean-Cell $name\\n                $cls  = Clean-Cell $d.Class\\n                $id   = Clean-Cell $d.InstanceId\\n                if ($name -or $id) {\\n                    $items.Add((\\\"{0}{1}{2}\\\" -f $name, $(if ($cls) { \\\" [Class:$cls]\\\" } else { \u0027\u0027 }), $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n                }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM Win32_PnPEntity\\n    try {\\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\\\*\u0027 } |\\n            Sort-Object -Property Name\\n\\n        foreach ($d in $devs) {\\n            $name = Clean-Cell $d.Name\\n            $id   = Clean-Cell $d.PNPDeviceID\\n            if ($name -or $id) {\\n                $items.Add((\\\"{0}{1}\\\" -f $name, $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - ANALYSIS\\n# ============================================================================\\n\\nfunction Get-ColumnMap {\\n    param([string[]]$Headers)\\n\\n    $map = @{\\n        Hostname        = \u0027Hostname\u0027\\n        User            = \u0027User\u0027\\n        System_Serial   = \u0027System_Serial\u0027\\n        RAM_GB          = \u0027RAM_GB\u0027\\n        Monitor_Serials = \u0027Monitor_Serials\u0027\\n        Scan_Date       = \u0027Scan_Date\u0027\\n    }\\n\\n    foreach ($k in @($map.Keys)) {\\n        if ($Headers -notcontains $map[$k]) {\\n            $alts = switch ($k) {\\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\\n                default           { @() }\\n            }\\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\\n            if ($found) { $map[$k] = $found }\\n        }\\n    }\\n\\n    return $map\\n}\\n\\nfunction Parse-ScanDate {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    # Try common date formats\\n    $formats = @(\u0027yyyy-MM-dd\u0027, \u0027yyyy-MM-dd HH:mm:ss\u0027, \u0027MM/dd/yyyy\u0027, \u0027dd/MM/yyyy\u0027)\\n    foreach ($fmt in $formats) {\\n        try {\\n            $result = [datetime]::ParseExact($s, $fmt, [System.Globalization.CultureInfo]::InvariantCulture)\\n            return $result\\n        } catch {\\n            # Continue to next format\\n        }\\n    }\\n\\n    # Fallback: general parse\\n    try {\\n        return [datetime]::Parse($s)\\n    } catch {\\n        return $null\\n    }\\n}\\n\\nfunction Normalize-Serial {\\n    param([AllowNull()][string]$Serial)\\n\\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\\n    $s = ($Serial.Trim())\\n\\n    $bad = @(\\n        \u0027To Be Filled By O.E.M.\u0027,\\n        \u0027To Be Filled By OEM\u0027,\\n        \u0027Default string\u0027,\\n        \u0027System Serial Number\u0027,\\n        \u0027None\u0027,\\n        \u0027N/A\u0027,\\n        \u0027NA\u0027,\\n        \u00270\u0027,\\n        \u002700000000\u0027,\\n        \u00270000000000\u0027,\\n        \u00270000000000000000\u0027\\n    )\\n\\n    if ($bad -contains $s) { return \u0027\u0027 }\\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\\n\\n    return $s.ToUpperInvariant()\\n}\\n\\nfunction Parse-RamGB {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    $m = [regex]::Match($s, \u0027(\\\\d+)(\\\\.\\\\d+)?\u0027)\\n    if (-not $m.Success) { return $null }\\n\\n    $n = $null\\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\\n        return [int][math]::Round($n, 0)\\n    }\\n\\n    return $null\\n}\\n\\nfunction Is-MonitorMissing {\\n    param([AllowNull()][string]$Value)\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\\n    $t = $Value.Trim()\\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\\n}\\n\\n# ============================================================================\\n# MAIN: COLLECTION\\n# ============================================================================\\n\\nfunction Invoke-Collection {\\n    param([string]$OutPath, [switch]$IncludePci)\\n\\n    $errors = New-Object System.Collections.Generic.List[string]\\n\\n    Write-Host \\\"`n========================================================\\\" -ForegroundColor Cyan\\n    Write-Host \\\"   GATHERING HARDWARE SPECS... PLEASE WAIT\\\" -ForegroundColor Cyan\\n    Write-Host \\\"========================================================\\\" -ForegroundColor Cyan\\n\\n    # --- Collect core system info ---\\n    $sys  = $null\\n    $bios = $null\\n    $cpu  = $null\\n    $os   = $null\\n    $bb   = $null\\n\\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_ComputerSystem: $($_.Exception.Message)\\\") }\\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\\\"Win32_BIOS: $($_.Exception.Message)\\\") }\\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_Processor: $($_.Exception.Message)\\\") }\\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_OperatingSystem: $($_.Exception.Message)\\\") }\\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_BaseBoard: $($_.Exception.Message)\\\") }\\n\\n    # --- Derived values ---\\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\\n\\n    $ramGB = $null\\n    try {\\n        if ($sys -and $sys.TotalPhysicalMemory) {\\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\\n        }\\n    } catch {\\n        $errors.Add(\\\"RAM calc: $($_.Exception.Message)\\\")\\n    }\\n\\n    # --- Other sections ---\\n    $netStr  = \u0027\u0027\\n    $gpuStr  = \u0027\u0027\\n    $diskStr = \u0027\u0027\\n    $monStr  = \u0027\u0027\\n    $pciStr  = \u0027\u0027\\n\\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\\\"Network: $($_.Exception.Message)\\\") }\\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\\\"GPU: $($_.Exception.Message)\\\") }\\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\\\"Disks: $($_.Exception.Message)\\\") }\\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\\\"Monitors: $($_.Exception.Message)\\\") }\\n\\n    if ($IncludePci) {\\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\\\"PCI devices: $($_.Exception.Message)\\\") }\\n    }\\n\\n    # Pre-compute BIOS release date (inline try-catch not reliable in PS 5.1)\\n    $biosReleaseDate = \u0027\u0027\\n    try {\\n        if ($bios -and $bios.ReleaseDate) {\\n            $biosReleaseDate = ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027)\\n        }\\n    } catch {\\n        $biosReleaseDate = \u0027\u0027\\n    }\\n\\n    # --- Build record ---\\n    $record = [pscustomobject]@{\\n        Hostname          = Clean-Cell $hostname\\n        User              = Clean-Cell $env:USERNAME\\n\\n        Make_Model        = Clean-Cell ((\\\"{0} {1}\\\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\\n\\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\\n        Baseboard_Product = Clean-Cell ($bb.Product)\\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\\n\\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\\n        BIOS_ReleaseDate  = Clean-Cell $biosReleaseDate\\n\\n        OS_Caption        = Clean-Cell ($os.Caption)\\n        OS_Version        = Clean-Cell ($os.Version)\\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\\n\\n        CPU               = Clean-Cell ($cpu.Name)\\n        RAM_GB            = $ramGB\\n\\n        Network_Adapters  = Clean-Cell $netStr\\n        GPUs              = Clean-Cell $gpuStr\\n        Disk_Serials      = Clean-Cell $diskStr\\n        Monitor_Serials   = Clean-Cell $monStr\\n\\n        PCI_Devices       = Clean-Cell $pciStr\\n\\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\\n        Collector_Version = \u00272.0\u0027\\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\\n    }\\n\\n    # --- CSV append with header safety ---\\n    $needHeader = $true\\n    if (Test-Path -LiteralPath $OutPath) {\\n        try {\\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\\n            if ($fi.Length -gt 0) { $needHeader = $false }\\n        } catch { $needHeader = $true }\\n    }\\n\\n    if ($needHeader) {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\\n    } else {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\\n    }\\n\\n    Write-Host \\\"`nSUCCESS!\\\" -ForegroundColor Green\\n    Write-Host \\\"Data saved to: $OutPath\\\" -ForegroundColor Gray\\n    if ($record.Errors) {\\n        Write-Host (\\\"Warnings captured in Errors column: {0}\\\" -f $record.Errors) -ForegroundColor Yellow\\n    }\\n}\\n\\n# ============================================================================\\n# MAIN: ANALYSIS\\n# ============================================================================\\n\\nfunction Invoke-Analysis {\\n    param(\\n        [string]$InputPath,\\n        [int]$StaleDaysThreshold,\\n        [int]$MinRam,\\n        [switch]$SkipCsv,\\n        [string]$BaseDir\\n    )\\n\\n    $ReportFile = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.txt\u0027\\n    $IssuesCsv  = Join-Path -Path $BaseDir -ChildPath \u0027Inventory_Issues_Report.csv\u0027\\n\\n    if (-not (Test-Path -LiteralPath $InputPath)) {\\n        Write-Warning \\\"Input file not found: $InputPath\\\"\\n        Write-Warning \\\"Run the script without -AnalyzeOnly first to collect data.\\\"\\n        return\\n    }\\n\\n    $raw = Import-Csv -LiteralPath $InputPath\\n    if (-not $raw -or $raw.Count -eq 0) {\\n        Write-Warning \\\"Input file contains no rows: $InputPath\\\"\\n        return\\n    }\\n\\n    $headers = @()\\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\\n    $col = Get-ColumnMap -Headers $headers\\n\\n    $today = Get-Date\\n\\n    # Normalize data and add helper properties\\n    $data = foreach ($r in $raw) {\\n        $hostname = if (@($r.PSObject.Properties.Match($col.Hostname)).Count -gt 0) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\\n        $user     = if (@($r.PSObject.Properties.Match($col.User)).Count -gt 0)     { [string]$r.($col.User) } else { \u0027\u0027 }\\n        $serial   = if (@($r.PSObject.Properties.Match($col.System_Serial)).Count -gt 0) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\\n        $ram      = if (@($r.PSObject.Properties.Match($col.RAM_GB)).Count -gt 0)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\\n        $mon      = if (@($r.PSObject.Properties.Match($col.Monitor_Serials)).Count -gt 0) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\\n        $scan     = if (@($r.PSObject.Properties.Match($col.Scan_Date)).Count -gt 0) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\\n\\n        $serialN = Normalize-Serial $serial\\n        $scanDt  = Parse-ScanDate $scan\\n        $ramGb   = Parse-RamGB $ram\\n\\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\\n\\n        # Asset key: prefer System Serial, fallback to Hostname\\n        $assetKey = \u0027\u0027\\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\\n            $assetKey = $serialN\\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\\n            $assetKey = $h.Trim().ToUpperInvariant()\\n        }\\n\\n        [pscustomobject]@{\\n            Hostname        = $h.Trim()\\n            User            = $u.Trim()\\n            System_Serial   = $serialN\\n            RAM_GB          = $ramGb\\n            Monitor_Serials = $m.Trim()\\n            Scan_Date       = $s.Trim()\\n\\n            ScanDateParsed  = $scanDt\\n            AssetKey        = $assetKey\\n            RawRow          = $r\\n        }\\n    }\\n\\n    # Latest record per asset\\n    $latestByAsset = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\\n        Group-Object -Property AssetKey |\\n        ForEach-Object { $_.Group | Select-Object -First 1 }\\n\\n    $issues = New-Object System.Collections.Generic.List[object]\\n\\n    function Add-Issue {\\n        param(\\n            [Parameter(Mandatory)][string]$IssueType,\\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\\n            [string]$AssetKey,\\n            [string]$Hostname,\\n            [string]$User,\\n            [string]$SystemSerial,\\n            [string]$ScanDate,\\n            [string]$Details\\n        )\\n\\n        $issues.Add([pscustomobject]@{\\n            IssueType     = $IssueType\\n            Severity      = $Severity\\n            AssetKey      = $AssetKey\\n            Hostname      = $Hostname\\n            User          = $User\\n            System_Serial = $SystemSerial\\n            Scan_Date     = $ScanDate\\n            Details       = $Details\\n        })\\n    }\\n\\n    # 0) Data quality (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\\n        }\\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\\n        }\\n        if (-not $pc.ScanDateParsed) {\\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\\n        }\\n    }\\n\\n    # 1) Duplicate serials (all rows; ignore blanks)\\n    $dupeGroups = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\\n        Group-Object -Property System_Serial |\\n        Where-Object { $_.Count -gt 1 }\\n\\n    foreach ($g in $dupeGroups) {\\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\\n\\n        $severity =\\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\\n            else { \u0027Info\u0027 }\\n\\n        $entries = $g.Group |\\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\\n            ForEach-Object {\\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\\n                \\\"{0} ({1})\\\" -f $_.Hostname, $d\\n            }\\n\\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\\\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\\\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\\n    }\\n\\n    # 2) Low RAM (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\\\"RAM_GB={0} (min {1})\\\" -f $pc.RAM_GB, $MinRam)\\n        } elseif ($null -eq $pc.RAM_GB) {\\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\\n        }\\n    }\\n\\n    # 3) Stale assets (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($pc.ScanDateParsed) {\\n            $ageDays = ($today - $pc.ScanDateParsed).Days\\n            if ($ageDays -gt $StaleDaysThreshold) {\\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\\\"Last seen {0} days ago (threshold {1})\\\" -f $ageDays, $StaleDaysThreshold)\\n            }\\n        }\\n    }\\n\\n    # 4) Missing monitor serials (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\\n        }\\n    }\\n\\n    # --- Build text report ---\\n    $generated = Get-Date\\n    $line = (\u0027=\u0027 * 70)\\n\\n    $txt = New-Object System.Collections.Generic.List[string]\\n    $txt.Add($line)\\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\\n    $txt.Add(\\\"Generated: $generated\\\")\\n    $txt.Add(\\\"Input:     $InputPath\\\")\\n    $txt.Add((\\\"Assets:    {0} (latest per asset)\\\" -f $latestByAsset.Count))\\n    $txt.Add((\\\"Rows:      {0} (raw rows in CSV)\\\" -f $data.Count))\\n    $txt.Add((\\\"Settings:  MinRamGB={0}, StaleDays={1}\\\" -f $MinRam, $StaleDaysThreshold))\\n    $txt.Add($line)\\n    $txt.Add(\u0027\u0027)\\n\\n    if ($issues.Count -eq 0) {\\n        $txt.Add(\u0027No issues found.\u0027)\\n    } else {\\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\\n        foreach ($t in $byType) {\\n            $txt.Add((\\\"--- {0} ({1}) ---\\\" -f $t.Name, $t.Count))\\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\\n\\n                $txt.Add((\\\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\\\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\\n            }\\n            $txt.Add(\u0027\u0027)\\n        }\\n    }\\n\\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\\n\\n    if (-not $SkipCsv) {\\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\\n    }\\n\\n    # --- Console summary ---\\n    Write-Host \\\"`n$line\\\" -ForegroundColor Cyan\\n    Write-Host (\\\"Report saved: {0}\\\" -f $ReportFile) -ForegroundColor Green\\n    if (-not $SkipCsv) { Write-Host (\\\"Issues CSV:   {0}\\\" -f $IssuesCsv) -ForegroundColor Green }\\n    Write-Host (\\\"Issues found: {0}\\\" -f $issues.Count) -ForegroundColor Yellow\\n    Write-Host $line -ForegroundColor Cyan\\n\\n    if ($issues.Count -gt 0) {\\n        $sev = $issues | Group-Object Severity | Sort-Object Name\\n        foreach ($s in $sev) {\\n            $c = switch ($s.Name) {\\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\\n                default    { [ConsoleColor]::Gray }\\n            }\\n            Write-Host (\\\"{0}: {1}\\\" -f $s.Name, $s.Count) -ForegroundColor $c\\n        }\\n    }\\n}\\n\\n# ============================================================================\\n# ENTRY POINT\\n# ============================================================================\\n\\nif (-not $AnalyzeOnly) {\\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\\n}\\n\\nif ($Analyze -or $AnalyzeOnly) {\\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv -BaseDir $ScriptDir\\n}\\n\\nif (-not $AnalyzeOnly -and -not $Analyze) {\\n    Write-Host \\\"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\\\" -ForegroundColor DarkGray\\n}\\n\\n\"}"},"checkpointId":"db65e1e6-2548-4062-bbd4-6b1a6bb2d61e"},"bubbleId":"e4c5b6e9-c97f-430d-8ac6-597927dc5cfa"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"e8cf0a6a-34b9-4b99-8f2f-ce0b4da071ed","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:00:49.284Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"f740e2cb-3184-4952-9a4e-1cab367db224","usageUuid":"60f0ece2-b461-4053-ab52-4d2da6a10c7a","capabilityType":30,"thinking":{"text":"Now let\u0027s test the -Analyze functionality again.","signature":"EtoBCkgICxACGAIqQJH3TzeJ6vIjX6BXPUpeIS7TwB2DtWkjPm5yCXJBPxSlY9xdz5cbIeambe1GTvEw4+2uxZgP38eC9Q/knqUfzUUSDG8Rx3t/UtIITuA8YBoMDVEbXMU5CDjA1r+xIjAh4v/4bMVkjX0DfxidWboXP1xlswD1miRef1Wh+OI3X6E0dT+bQLERUWNg3r1PM2QqQAjhW11FKWdNomnot8izgMM/nV43odqjq8koCmOvtQB1KRlAsn5wiN6MveKWTXv5TqeGiDvcucRqf/Y61RaXyTYYAQ=="},"thinkingStyle":1,"thinkingDurationMs":951},"bubbleId":"e8cf0a6a-34b9-4b99-8f2f-ce0b4da071ed"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"f316d17a-81cd-4005-97af-41ab339c2420","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T01:00:07.720Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"e3553be1-1c81-4b61-bdd0-a53f844e2e68","usageUuid":"2d531f96-080b-4694-8c51-844012b6dfbd","capabilityType":30,"thinking":{"text":"I need to fix the inline try-catch that PowerShell 5.1 doesn\u0027t like. Let me compute BIOS_ReleaseDate before the hashtable.","signature":"EqUCCkgICxACGAIqQE0x7Bwcg1Mo4w8ZbGBP8hDKsdttCibBA+VlOFdcWFRgg+USXourOI9+izqX+XEWEq+8oRqRcHDa19+KN2ZxpvgSDB490Tq+46sipyCA6BoM/dZCqsTANpIcvdnJIjATVC+gnVCaqz7KbUZeZ8zYMT4ENtXMGIuMd8qFvChpgc4efqodDmsfix/0K2PLvY0qigF1l9rN5DaCMrxkkQY+p++ogSQ+bSkPoL0FfFnbLvXfyUNHp33J6KKFRWaZxfzs93m1JvYIa/P27+L8bMkiKOHiX7Lk6lv34MkjzYHeaN0XGZNTmJLeothq9tQAVEc/167ld8bYbGFcgDslywjQxIbGoHDgEE5FaUcldAWOhCSyNpzH8+bTpuwVjBgYAQ=="},"thinkingStyle":1,"thinkingDurationMs":1273},"bubbleId":"f316d17a-81cd-4005-97af-41ab339c2420"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"f9c9c60f-5ce5-44e6-b0ae-9dda0fddbf51","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:59:14.987Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"codeBlocks":[],"text":"","serverBubbleId":"915b0b69-81b0-4eda-b2aa-6a51e155f54c","usageUuid":"bdd3d57c-9e19-4d02-b932-ab4804ad6503","capabilityType":30,"thinking":{"text":"The issue is that `$PSScriptRoot` is empty when the script is run with `powershell -File` from the command line. I need to handle the case where `$PSScriptRoot` is empty by falling back to `$PWD` or the current directory.\n\nLet me fix this by adding a fallback for `$PSScriptRoot`.","signature":"EsMDCkgICxACGAIqQL+h+6jlaLhySwWwJ9g9NMdUE2xLil58nyAMUL+oMUKIOWzT7jJBULQbWd80cV2qRnYA1huiBIWqRN1GIGDCkn4SDAmxg5Gh8BS9O11CmxoMEwXzBnag2vNvT/1AIjDj6YS3nOcXjk11EGtxojJ2hitKWuRvbg6Q3TngPt5/HXZxvDA1LyMcdUH5RCEwaTUqqALERlKJrAJm8O00jP1c46B8CLElZHXcNRxr65h3eX2WQEzIVQvLvs2IrjCDmRoMDOf1pzeqNXBVXURA6V+O5sqwqWyBYxUIWK/gx4Sa9T6Fb+wM3KChF+euQYK2NjKcHrA7fMKFP/+oaZ53y1iyqlkMdRzVwQ1pTqvkxxTuGg+6M0YiGKM0qoXaDRNoXl8iqDwBd0sUwAu8Fn1WCqhQ/Fi480qlWQzmXpM3JlWCKfY6kOxnwiRjIDErNadJU3WCRpeqxpMZ9x7mDnJ/M+W1UBrU+Au8wrkxEEhxg9hBwOo31+sGZVRQYtHe0DS4+7jfEqj003vqydVol0rGpvbZBBsjKxmRSwAhG3oKJwX+ZJ0Wha8lQDfB6oADSA2NJRIOtSOV2xDcYTakzhgB"},"thinkingStyle":1,"thinkingDurationMs":1855},"bubbleId":"f9c9c60f-5ce5-44e6-b0ae-9dda0fddbf51"}
{"data":{"_v":3,"type":2,"approximateLintErrors":[],"lints":[],"codebaseContextChunks":[],"commits":[],"pullRequests":[],"attachedCodeChunks":[],"assistantSuggestedDiffs":[],"gitDiffs":[],"interpreterResults":[],"images":[],"attachedFolders":[],"attachedFoldersNew":[],"bubbleId":"fb5d46c6-e348-4214-9006-58dba5a10810","userResponsesToSuggestedCodeBlocks":[],"suggestedCodeBlocks":[],"diffsForCompressingFiles":[],"relevantFiles":[],"toolResults":[],"notepads":[],"capabilities":[],"capabilityStatuses":{"mutate-request":[],"start-submit-chat":[],"before-submit-chat":[],"chat-stream-finished":[],"before-apply":[],"after-apply":[],"accept-all-edits":[],"composer-done":[],"process-stream":[],"add-pending-action":[]},"multiFileLinterErrors":[],"diffHistories":[],"recentLocationsHistory":[],"recentlyViewedFiles":[],"isAgentic":false,"fileDiffTrajectories":[],"existedSubsequentTerminalCommand":false,"existedPreviousTerminalCommand":false,"docsReferences":[],"webReferences":[],"aiWebSearchResults":[],"requestId":"","attachedFoldersListDirResults":[],"humanChanges":[],"attachedHumanChanges":false,"summarizedComposers":[],"cursorRules":[],"contextPieces":[],"editTrailContexts":[],"allThinkingBlocks":[],"diffsSinceLastApply":[],"deletedFiles":[],"supportedTools":[],"tokenCount":{"inputTokens":0,"outputTokens":0},"attachedFileCodeChunksMetadataOnly":[],"consoleLogs":[],"uiElementPicked":[],"isRefunded":false,"knowledgeItems":[],"documentationSelections":[],"externalLinks":[],"useWeb":false,"projectLayouts":[],"unifiedMode":2,"capabilityContexts":[],"todos":[],"createdAt":"2025-12-29T00:55:53.700Z","isQuickSearchQuery":false,"mcpDescriptors":[],"workspaceUris":[],"text":"","usageUuid":"45d7fab2-f5b9-4af9-b2c2-66d4e1bd1674","codeBlocks":[{"uri":{"scheme":"file","authority":"","path":"/c:/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1","query":"","fragment":"","_formatted":"file:///c%3A/Users/user/Downloads/Cursor_working_directory_misc/USB-Inventory.ps1","_fsPath":"c:\\Users\\user\\Downloads\\Cursor_working_directory_misc\\USB-Inventory.ps1"},"codeblockId":"42a82eb6-01bb-43cb-8c7c-022862dd15b9","codeBlockIdx":0,"content":"#requires -Version 5.1\n\u003c#\n.SYNOPSIS\n    USB-portable PC hardware inventory collection and analysis tool.\n\n.DESCRIPTION\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\n    script. Optionally runs health analysis to detect duplicates, stale assets,\n    low RAM, and missing monitor data.\n\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\n\n.PARAMETER OutputFile\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\n\n.PARAMETER IncludePciDevices\n    Include detailed PCI device enumeration (can produce large output).\n\n.PARAMETER Analyze\n    After collection, run health analysis on the CSV file.\n\n.PARAMETER AnalyzeOnly\n    Skip collection; only run health analysis on existing CSV.\n\n.PARAMETER StaleDays\n    Threshold in days for flagging stale assets. Default: 90.\n\n.PARAMETER MinRamGB\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\n\n.PARAMETER NoCsv\n    Do not output Inventory_Issues_Report.csv (text report only).\n\n.EXAMPLE\n    .\\USB-Inventory.ps1\n    Collect inventory from this PC into PC_Inventory_Master.csv.\n\n.EXAMPLE\n    .\\USB-Inventory.ps1 -IncludePciDevices -Analyze\n    Collect inventory with PCI devices, then run health analysis.\n\n.EXAMPLE\n    .\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\n    Analyze existing CSV with custom thresholds (no new collection).\n#\u003e\n\n[CmdletBinding()]\nparam(\n    [string]$OutputFile = (Join-Path -Path $PSScriptRoot -ChildPath \u0027PC_Inventory_Master.csv\u0027),\n    [switch]$IncludePciDevices,\n    [switch]$Analyze,\n    [switch]$AnalyzeOnly,\n    [int]$StaleDays = 90,\n    [int]$MinRamGB = 8,\n    [switch]$NoCsv\n)\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = \u0027Stop\u0027\n\n# ============================================================================\n# HELPER FUNCTIONS - COLLECTION\n# ============================================================================\n\nfunction Clean-Cell {\n    param([AllowNull()][string]$Text)\n    if ($null -eq $Text) { return \u0027\u0027 }\n    return ($Text -replace \"(`r`n|`n|`r|`t)+\", \u0027 \u0027).Trim()\n}\n\nfunction Convert-UShortArrayToString {\n    param([AllowNull()]$Arr)\n    if ($null -eq $Arr) { return \u0027\u0027 }\n    $chars = foreach ($x in $Arr) {\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\n    }\n    return ( -join $chars ).Trim()\n}\n\nfunction Get-MonitorInventory {\n    \u003c#\n      Preferred: root\\wmi:WmiMonitorID (easy, consistent, usually no admin)\n      Fallback: registry EDID decode under HKLM:\\SYSTEM\\CCS\\Enum\\DISPLAY\n    #\u003e\n\n    $results = New-Object System.Collections.Generic.List[string]\n\n    # --- Preferred path: WmiMonitorID ---\n    try {\n        $wmiMons = Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorID -ErrorAction Stop\n        foreach ($m in $wmiMons) {\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\n\n            $label = @()\n            if ($mfg)  { $label += $mfg }\n            if ($name) { $label += $name }\n\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\n            $serialPart  = if ($sn) { \"SN:$sn\" } else { \u0027SN:(none)\u0027 }\n\n            $results.Add(\"$displayName ($serialPart)\")\n        }\n    } catch {\n        # WmiMonitorID not available; fall through to EDID fallback\n    }\n\n    if ($results.Count -gt 0) {\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n    }\n\n    # --- Fallback path: registry EDID decode ---\n    function Get-EdidDescriptorString {\n        param(\n            [byte[]]$Edid,\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\n        )\n\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\n\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\n\n        foreach ($offset in 54,72,90,108) {\n            if (($offset + 18) -gt $Edid.Length) { continue }\n\n            # Descriptor: 00 00 00 {tag} 00 ...\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\n\n                $bytes = $Edid[($offset+5)..($offset+17)]\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\n                $text = ($text -replace \"[`0`n`r]+\", \u0027\u0027).Trim()\n                if ($text) { return $text }\n            }\n        }\n\n        return \u0027\u0027\n    }\n\n    try {\n        $root = \u0027HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\DISPLAY\u0027\n        if (Test-Path -LiteralPath $root) {\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\n                    if (Test-Path -LiteralPath $params) {\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\n                        if ($edid -is [byte[]]) {\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\n\n                            # Numeric serial (bytes 12-15 LE) sometimes present\n                            $num = [BitConverter]::ToUInt32($edid, 12)\n                            $numStr = if ($num -ne 0) { \"NUM:$num\" } else { \u0027\u0027 }\n\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\n                            $serialPart  = if ($sn) { \"SN:$sn\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\n\n                            $results.Add(\"$displayName ($serialPart)\")\n                        }\n                    }\n                }\n            }\n        }\n    } catch {\n        # EDID fallback failed silently\n    }\n\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-NetworkInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\n\n    if ($hasNetAdapter -and $hasNetIpCfg) {\n        try {\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\n            foreach ($a in $adapters) {\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\n                $ipv4 = @()\n                if ($cfg -and $cfg.IPv4Address) {\n                    $ipv4 = $cfg.IPv4Address |\n                        ForEach-Object { $_.IPAddress } |\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\n                }\n                $gw = @()\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\n                }\n\n                $parts = @()\n                $parts += (Clean-Cell $a.Name)\n                if ($a.MacAddress) { $parts += \"MAC:$($a.MacAddress)\" }\n                if ($ipv4.Count -gt 0) { $parts += (\"IPv4:\" + ($ipv4 -join \u0027;\u0027)) }\n                if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n                $items.Add(($parts -join \u0027 \u0027))\n            }\n        } catch {\n            # Fall back to CIM below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\n            Where-Object { $_.IPEnabled -eq $true }\n\n        foreach ($n in $net) {\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\n            $mac  = $n.MACAddress\n            $ips  = @()\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\n            $gw   = @()\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\n\n            $parts = @()\n            $parts += (Clean-Cell $name)\n            if ($mac) { $parts += \"MAC:$mac\" }\n            if ($ips.Count -gt 0) { $parts += (\"IP:\" + ($ips -join \u0027;\u0027)) }\n            if ($gw.Count -gt 0) { $parts += (\"GW:\" + ($gw -join \u0027;\u0027)) }\n\n            $items.Add(($parts -join \u0027 \u0027))\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-GpuInventory {\n    $gpus = New-Object System.Collections.Generic.List[string]\n\n    # CIM GPUs\n    try {\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\n        foreach ($g in $vc) {\n            $name = Clean-Cell $g.Name\n            $pnp  = Clean-Cell $g.PNPDeviceID\n            if ($name -or $pnp) {\n                $gpus.Add((\"{0}{1}\" -f $name, $(if ($pnp) { \" [ID:$pnp]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    # Optional NVIDIA serials if nvidia-smi exists\n    try {\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\n        if ($nvsmi) {\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\n            foreach ($line in @($raw)) {\n                $t = Clean-Cell $line\n                if ($t) { $gpus.Add(\"NVIDIA $t\") }\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-DiskInventory {\n    $disks = New-Object System.Collections.Generic.List[string]\n\n    # Prefer Storage module when available\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\n    if ($hasPhysicalDisk) {\n        try {\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\n                $name = Clean-Cell $d.FriendlyName\n                $sn   = Clean-Cell $d.SerialNumber\n                $mt   = Clean-Cell ([string]$d.MediaType)\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n                $parts = @()\n                if ($name) { $parts += $name }\n                if ($sn)   { $parts += \"SN:$sn\" }\n                if ($mt)   { $parts += \"Type:$mt\" }\n                if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n            }\n        } catch {\n            # Fall back below\n        }\n    }\n\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM\n    try {\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\n            $model = Clean-Cell $d.Model\n            $sn = \u0027\u0027\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\n            $devId = Clean-Cell $d.DeviceID\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\n\n            $parts = @()\n            if ($model) { $parts += $model }\n            if ($sn)    { $parts += \"SN:$sn\" }\n            if ($devId) { $parts += \"Dev:$devId\" }\n            if ($null -ne $sz) { $parts += \"GB:$sz\" }\n\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\nfunction Get-PciDeviceInventory {\n    $items = New-Object System.Collections.Generic.List[string]\n\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\n    if ($hasGetPnpDevice) {\n        try {\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\n                Where-Object { $_.InstanceId -like \u0027PCI\\*\u0027 } |\n                Sort-Object -Property Class, FriendlyName, Name\n\n            foreach ($d in $devs) {\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\n                $name = Clean-Cell $name\n                $cls  = Clean-Cell $d.Class\n                $id   = Clean-Cell $d.InstanceId\n                if ($name -or $id) {\n                    $items.Add((\"{0}{1}{2}\" -f $name, $(if ($cls) { \" [Class:$cls]\" } else { \u0027\u0027 }), $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n                }\n            }\n        } catch {\n            # Fall back below\n        }\n    }\n\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\n\n    # Fallback: CIM Win32_PnPEntity\n    try {\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\*\u0027 } |\n            Sort-Object -Property Name\n\n        foreach ($d in $devs) {\n            $name = Clean-Cell $d.Name\n            $id   = Clean-Cell $d.PNPDeviceID\n            if ($name -or $id) {\n                $items.Add((\"{0}{1}\" -f $name, $(if ($id) { \" [ID:$id]\" } else { \u0027\u0027 })))\n            }\n        }\n    } catch {\n        # Ignore\n    }\n\n    if ($items.Count -eq 0) { return \u0027\u0027 }\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\n}\n\n# ============================================================================\n# HELPER FUNCTIONS - ANALYSIS\n# ============================================================================\n\nfunction Get-ColumnMap {\n    param([string[]]$Headers)\n\n    $map = @{\n        Hostname        = \u0027Hostname\u0027\n        User            = \u0027User\u0027\n        System_Serial   = \u0027System_Serial\u0027\n        RAM_GB          = \u0027RAM_GB\u0027\n        Monitor_Serials = \u0027Monitor_Serials\u0027\n        Scan_Date       = \u0027Scan_Date\u0027\n    }\n\n    foreach ($k in @($map.Keys)) {\n        if ($Headers -notcontains $map[$k]) {\n            $alts = switch ($k) {\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\n                default           { @() }\n            }\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\n            if ($found) { $map[$k] = $found }\n        }\n    }\n\n    return $map\n}\n\nfunction Parse-ScanDate {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    $dt = $null\n\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\n\n    if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\n\n    return $null\n}\n\nfunction Normalize-Serial {\n    param([AllowNull()][string]$Serial)\n\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\n    $s = ($Serial.Trim())\n\n    $bad = @(\n        \u0027To Be Filled By O.E.M.\u0027,\n        \u0027To Be Filled By OEM\u0027,\n        \u0027Default string\u0027,\n        \u0027System Serial Number\u0027,\n        \u0027None\u0027,\n        \u0027N/A\u0027,\n        \u0027NA\u0027,\n        \u00270\u0027,\n        \u002700000000\u0027,\n        \u00270000000000\u0027,\n        \u00270000000000000000\u0027\n    )\n\n    if ($bad -contains $s) { return \u0027\u0027 }\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\n\n    return $s.ToUpperInvariant()\n}\n\nfunction Parse-RamGB {\n    param([AllowNull()][string]$Value)\n\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\n    $s = $Value.Trim()\n\n    $m = [regex]::Match($s, \u0027(\\d+)(\\.\\d+)?\u0027)\n    if (-not $m.Success) { return $null }\n\n    $n = $null\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\n        return [int][math]::Round($n, 0)\n    }\n\n    return $null\n}\n\nfunction Is-MonitorMissing {\n    param([AllowNull()][string]$Value)\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\n    $t = $Value.Trim()\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\n}\n\n# ============================================================================\n# MAIN: COLLECTION\n# ============================================================================\n\nfunction Invoke-Collection {\n    param([string]$OutPath, [switch]$IncludePci)\n\n    $errors = New-Object System.Collections.Generic.List[string]\n\n    Write-Host \"`n========================================================\" -ForegroundColor Cyan\n    Write-Host \"   GATHERING HARDWARE SPECS... PLEASE WAIT\" -ForegroundColor Cyan\n    Write-Host \"========================================================\" -ForegroundColor Cyan\n\n    # --- Collect core system info ---\n    $sys  = $null\n    $bios = $null\n    $cpu  = $null\n    $os   = $null\n    $bb   = $null\n\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_ComputerSystem: $($_.Exception.Message)\") }\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\"Win32_BIOS: $($_.Exception.Message)\") }\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_Processor: $($_.Exception.Message)\") }\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\"Win32_OperatingSystem: $($_.Exception.Message)\") }\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\"Win32_BaseBoard: $($_.Exception.Message)\") }\n\n    # --- Derived values ---\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\n\n    $ramGB = $null\n    try {\n        if ($sys -and $sys.TotalPhysicalMemory) {\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\n        }\n    } catch {\n        $errors.Add(\"RAM calc: $($_.Exception.Message)\")\n    }\n\n    # --- Other sections ---\n    $netStr  = \u0027\u0027\n    $gpuStr  = \u0027\u0027\n    $diskStr = \u0027\u0027\n    $monStr  = \u0027\u0027\n    $pciStr  = \u0027\u0027\n\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\"Network: $($_.Exception.Message)\") }\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\"GPU: $($_.Exception.Message)\") }\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\"Disks: $($_.Exception.Message)\") }\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\"Monitors: $($_.Exception.Message)\") }\n\n    if ($IncludePci) {\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\"PCI devices: $($_.Exception.Message)\") }\n    }\n\n    # --- Build record ---\n    $record = [pscustomobject]@{\n        Hostname          = Clean-Cell $hostname\n        User              = Clean-Cell $env:USERNAME\n\n        Make_Model        = Clean-Cell ((\"{0} {1}\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\n\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\n        Baseboard_Product = Clean-Cell ($bb.Product)\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\n\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\n        BIOS_ReleaseDate  = Clean-Cell (try { ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027) } catch { \u0027\u0027 })\n\n        OS_Caption        = Clean-Cell ($os.Caption)\n        OS_Version        = Clean-Cell ($os.Version)\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\n\n        CPU               = Clean-Cell ($cpu.Name)\n        RAM_GB            = $ramGB\n\n        Network_Adapters  = Clean-Cell $netStr\n        GPUs              = Clean-Cell $gpuStr\n        Disk_Serials      = Clean-Cell $diskStr\n        Monitor_Serials   = Clean-Cell $monStr\n\n        PCI_Devices       = Clean-Cell $pciStr\n\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\n        Collector_Version = \u00272.0\u0027\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\n    }\n\n    # --- CSV append with header safety ---\n    $needHeader = $true\n    if (Test-Path -LiteralPath $OutPath) {\n        try {\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\n            if ($fi.Length -gt 0) { $needHeader = $false }\n        } catch { $needHeader = $true }\n    }\n\n    if ($needHeader) {\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\n    } else {\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\n    }\n\n    Write-Host \"`nSUCCESS!\" -ForegroundColor Green\n    Write-Host \"Data saved to: $OutPath\" -ForegroundColor Gray\n    if ($record.Errors) {\n        Write-Host (\"Warnings captured in Errors column: {0}\" -f $record.Errors) -ForegroundColor Yellow\n    }\n}\n\n# ============================================================================\n# MAIN: ANALYSIS\n# ============================================================================\n\nfunction Invoke-Analysis {\n    param(\n        [string]$InputPath,\n        [int]$StaleDaysThreshold,\n        [int]$MinRam,\n        [switch]$SkipCsv\n    )\n\n    $ReportFile = Join-Path -Path $PSScriptRoot -ChildPath \u0027Inventory_Issues_Report.txt\u0027\n    $IssuesCsv  = Join-Path -Path $PSScriptRoot -ChildPath \u0027Inventory_Issues_Report.csv\u0027\n\n    if (-not (Test-Path -LiteralPath $InputPath)) {\n        Write-Warning \"Input file not found: $InputPath\"\n        Write-Warning \"Run the script without -AnalyzeOnly first to collect data.\"\n        return\n    }\n\n    $raw = Import-Csv -LiteralPath $InputPath\n    if (-not $raw -or $raw.Count -eq 0) {\n        Write-Warning \"Input file contains no rows: $InputPath\"\n        return\n    }\n\n    $headers = @()\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\n    $col = Get-ColumnMap -Headers $headers\n\n    $today = Get-Date\n\n    # Normalize data and add helper properties\n    $data = foreach ($r in $raw) {\n        $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\n        $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\n        $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\n        $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\n        $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\n        $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\n\n        $serialN = Normalize-Serial $serial\n        $scanDt  = Parse-ScanDate $scan\n        $ramGb   = Parse-RamGB $ram\n\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\n\n        # Asset key: prefer System Serial, fallback to Hostname\n        $assetKey = \u0027\u0027\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\n            $assetKey = $serialN\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\n            $assetKey = $h.Trim().ToUpperInvariant()\n        }\n\n        [pscustomobject]@{\n            Hostname        = $h.Trim()\n            User            = $u.Trim()\n            System_Serial   = $serialN\n            RAM_GB          = $ramGb\n            Monitor_Serials = $m.Trim()\n            Scan_Date       = $s.Trim()\n\n            ScanDateParsed  = $scanDt\n            AssetKey        = $assetKey\n            RawRow          = $r\n        }\n    }\n\n    # Latest record per asset\n    $latestByAsset = $data |\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\n        Group-Object -Property AssetKey |\n        ForEach-Object { $_.Group | Select-Object -First 1 }\n\n    $issues = New-Object System.Collections.Generic.List[object]\n\n    function Add-Issue {\n        param(\n            [Parameter(Mandatory)][string]$IssueType,\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\n            [string]$AssetKey,\n            [string]$Hostname,\n            [string]$User,\n            [string]$SystemSerial,\n            [string]$ScanDate,\n            [string]$Details\n        )\n\n        $issues.Add([pscustomobject]@{\n            IssueType     = $IssueType\n            Severity      = $Severity\n            AssetKey      = $AssetKey\n            Hostname      = $Hostname\n            User          = $User\n            System_Serial = $SystemSerial\n            Scan_Date     = $ScanDate\n            Details       = $Details\n        })\n    }\n\n    # 0) Data quality (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\n        }\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\n        }\n        if (-not $pc.ScanDateParsed) {\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\n        }\n    }\n\n    # 1) Duplicate serials (all rows; ignore blanks)\n    $dupeGroups = $data |\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\n        Group-Object -Property System_Serial |\n        Where-Object { $_.Count -gt 1 }\n\n    foreach ($g in $dupeGroups) {\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\n\n        $severity =\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\n            else { \u0027Info\u0027 }\n\n        $entries = $g.Group |\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\n            ForEach-Object {\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\n                \"{0} ({1})\" -f $_.Hostname, $d\n            }\n\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\n    }\n\n    # 2) Low RAM (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\"RAM_GB={0} (min {1})\" -f $pc.RAM_GB, $MinRam)\n        } elseif ($null -eq $pc.RAM_GB) {\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\n        }\n    }\n\n    # 3) Stale assets (latest records)\n    foreach ($pc in $latestByAsset) {\n        if ($pc.ScanDateParsed) {\n            $ageDays = ($today - $pc.ScanDateParsed).Days\n            if ($ageDays -gt $StaleDaysThreshold) {\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\"Last seen {0} days ago (threshold {1})\" -f $ageDays, $StaleDaysThreshold)\n            }\n        }\n    }\n\n    # 4) Missing monitor serials (latest records)\n    foreach ($pc in $latestByAsset) {\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\n        }\n    }\n\n    # --- Build text report ---\n    $generated = Get-Date\n    $line = (\u0027=\u0027 * 70)\n\n    $txt = New-Object System.Collections.Generic.List[string]\n    $txt.Add($line)\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\n    $txt.Add(\"Generated: $generated\")\n    $txt.Add(\"Input:     $InputPath\")\n    $txt.Add((\"Assets:    {0} (latest per asset)\" -f $latestByAsset.Count))\n    $txt.Add((\"Rows:      {0} (raw rows in CSV)\" -f $data.Count))\n    $txt.Add((\"Settings:  MinRamGB={0}, StaleDays={1}\" -f $MinRam, $StaleDaysThreshold))\n    $txt.Add($line)\n    $txt.Add(\u0027\u0027)\n\n    if ($issues.Count -eq 0) {\n        $txt.Add(\u0027No issues found.\u0027)\n    } else {\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\n        foreach ($t in $byType) {\n            $txt.Add((\"--- {0} ({1}) ---\" -f $t.Name, $t.Count))\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\n\n                $txt.Add((\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\n            }\n            $txt.Add(\u0027\u0027)\n        }\n    }\n\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\n\n    if (-not $SkipCsv) {\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\n    }\n\n    # --- Console summary ---\n    Write-Host \"`n$line\" -ForegroundColor Cyan\n    Write-Host (\"Report saved: {0}\" -f $ReportFile) -ForegroundColor Green\n    if (-not $SkipCsv) { Write-Host (\"Issues CSV:   {0}\" -f $IssuesCsv) -ForegroundColor Green }\n    Write-Host (\"Issues found: {0}\" -f $issues.Count) -ForegroundColor Yellow\n    Write-Host $line -ForegroundColor Cyan\n\n    if ($issues.Count -gt 0) {\n        $sev = $issues | Group-Object Severity | Sort-Object Name\n        foreach ($s in $sev) {\n            $c = switch ($s.Name) {\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\n                default    { [ConsoleColor]::Gray }\n            }\n            Write-Host (\"{0}: {1}\" -f $s.Name, $s.Count) -ForegroundColor $c\n        }\n    }\n}\n\n# ============================================================================\n# ENTRY POINT\n# ============================================================================\n\nif (-not $AnalyzeOnly) {\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\n}\n\nif ($Analyze -or $AnalyzeOnly) {\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv\n}\n\nif (-not $AnalyzeOnly -and -not $Analyze) {\n    Write-Host \"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\" -ForegroundColor DarkGray\n}\n","languageId":"powershell"}],"capabilityType":15,"toolFormerData":{"tool":38,"toolCallId":"toolu_vrtx_01JpN4sVvzLEamGVcuaywSHe","toolIndex":1,"modelCallId":"4e844b1d-c55e-40e5-9b33-bd2e4f055592","status":"completed","rawArgs":"{\"file_path\": \"USB-Inventory.ps1\", \"contents\": \"#requires -Version 5.1\\n\u003c#\\n.SYNOPSIS\\n    USB-portable PC hardware inventory collection and analysis tool.\\n\\n.DESCRIPTION\\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\\n    script. Optionally runs health analysis to detect duplicates, stale assets,\\n    low RAM, and missing monitor data.\\n\\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\\n\\n.PARAMETER OutputFile\\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\\n\\n.PARAMETER IncludePciDevices\\n    Include detailed PCI device enumeration (can produce large output).\\n\\n.PARAMETER Analyze\\n    After collection, run health analysis on the CSV file.\\n\\n.PARAMETER AnalyzeOnly\\n    Skip collection; only run health analysis on existing CSV.\\n\\n.PARAMETER StaleDays\\n    Threshold in days for flagging stale assets. Default: 90.\\n\\n.PARAMETER MinRamGB\\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\\n\\n.PARAMETER NoCsv\\n    Do not output Inventory_Issues_Report.csv (text report only).\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1\\n    Collect inventory from this PC into PC_Inventory_Master.csv.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -IncludePciDevices -Analyze\\n    Collect inventory with PCI devices, then run health analysis.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\\n    Analyze existing CSV with custom thresholds (no new collection).\\n#\u003e\\n\\n[CmdletBinding()]\\nparam(\\n    [string]$OutputFile = (Join-Path -Path $PSScriptRoot -ChildPath \u0027PC_Inventory_Master.csv\u0027),\\n    [switch]$IncludePciDevices,\\n    [switch]$Analyze,\\n    [switch]$AnalyzeOnly,\\n    [int]$StaleDays = 90,\\n    [int]$MinRamGB = 8,\\n    [switch]$NoCsv\\n)\\n\\nSet-StrictMode -Version Latest\\n$ErrorActionPreference = \u0027Stop\u0027\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - COLLECTION\\n# ============================================================================\\n\\nfunction Clean-Cell {\\n    param([AllowNull()][string]$Text)\\n    if ($null -eq $Text) { return \u0027\u0027 }\\n    return ($Text -replace \\\"(`r`n|`n|`r|`t)+\\\", \u0027 \u0027).Trim()\\n}\\n\\nfunction Convert-UShortArrayToString {\\n    param([AllowNull()]$Arr)\\n    if ($null -eq $Arr) { return \u0027\u0027 }\\n    $chars = foreach ($x in $Arr) {\\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\\n    }\\n    return ( -join $chars ).Trim()\\n}\\n\\nfunction Get-MonitorInventory {\\n    \u003c#\\n      Preferred: root\\\\wmi:WmiMonitorID (easy, consistent, usually no admin)\\n      Fallback: registry EDID decode under HKLM:\\\\SYSTEM\\\\CCS\\\\Enum\\\\DISPLAY\\n    #\u003e\\n\\n    $results = New-Object System.Collections.Generic.List[string]\\n\\n    # --- Preferred path: WmiMonitorID ---\\n    try {\\n        $wmiMons = Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorID -ErrorAction Stop\\n        foreach ($m in $wmiMons) {\\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\\n\\n            $label = @()\\n            if ($mfg)  { $label += $mfg }\\n            if ($name) { $label += $name }\\n\\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\\n            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } else { \u0027SN:(none)\u0027 }\\n\\n            $results.Add(\\\"$displayName ($serialPart)\\\")\\n        }\\n    } catch {\\n        # WmiMonitorID not available; fall through to EDID fallback\\n    }\\n\\n    if ($results.Count -gt 0) {\\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n    }\\n\\n    # --- Fallback path: registry EDID decode ---\\n    function Get-EdidDescriptorString {\\n        param(\\n            [byte[]]$Edid,\\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\\n        )\\n\\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\\n\\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\\n\\n        foreach ($offset in 54,72,90,108) {\\n            if (($offset + 18) -gt $Edid.Length) { continue }\\n\\n            # Descriptor: 00 00 00 {tag} 00 ...\\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\\n\\n                $bytes = $Edid[($offset+5)..($offset+17)]\\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\\n                $text = ($text -replace \\\"[`0`n`r]+\\\", \u0027\u0027).Trim()\\n                if ($text) { return $text }\\n            }\\n        }\\n\\n        return \u0027\u0027\\n    }\\n\\n    try {\\n        $root = \u0027HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Enum\\\\DISPLAY\u0027\\n        if (Test-Path -LiteralPath $root) {\\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\\n                    if (Test-Path -LiteralPath $params) {\\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\\n                        if ($edid -is [byte[]]) {\\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\\n\\n                            # Numeric serial (bytes 12-15 LE) sometimes present\\n                            $num = [BitConverter]::ToUInt32($edid, 12)\\n                            $numStr = if ($num -ne 0) { \\\"NUM:$num\\\" } else { \u0027\u0027 }\\n\\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\\n                            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\\n\\n                            $results.Add(\\\"$displayName ($serialPart)\\\")\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    } catch {\\n        # EDID fallback failed silently\\n    }\\n\\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-NetworkInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\\n\\n    if ($hasNetAdapter -and $hasNetIpCfg) {\\n        try {\\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\\n            foreach ($a in $adapters) {\\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\\n                $ipv4 = @()\\n                if ($cfg -and $cfg.IPv4Address) {\\n                    $ipv4 = $cfg.IPv4Address |\\n                        ForEach-Object { $_.IPAddress } |\\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\\n                }\\n                $gw = @()\\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\\n                }\\n\\n                $parts = @()\\n                $parts += (Clean-Cell $a.Name)\\n                if ($a.MacAddress) { $parts += \\\"MAC:$($a.MacAddress)\\\" }\\n                if ($ipv4.Count -gt 0) { $parts += (\\\"IPv4:\\\" + ($ipv4 -join \u0027;\u0027)) }\\n                if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n                $items.Add(($parts -join \u0027 \u0027))\\n            }\\n        } catch {\\n            # Fall back to CIM below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\\n            Where-Object { $_.IPEnabled -eq $true }\\n\\n        foreach ($n in $net) {\\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\\n            $mac  = $n.MACAddress\\n            $ips  = @()\\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\\n            $gw   = @()\\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\\n\\n            $parts = @()\\n            $parts += (Clean-Cell $name)\\n            if ($mac) { $parts += \\\"MAC:$mac\\\" }\\n            if ($ips.Count -gt 0) { $parts += (\\\"IP:\\\" + ($ips -join \u0027;\u0027)) }\\n            if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n            $items.Add(($parts -join \u0027 \u0027))\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-GpuInventory {\\n    $gpus = New-Object System.Collections.Generic.List[string]\\n\\n    # CIM GPUs\\n    try {\\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\\n        foreach ($g in $vc) {\\n            $name = Clean-Cell $g.Name\\n            $pnp  = Clean-Cell $g.PNPDeviceID\\n            if ($name -or $pnp) {\\n                $gpus.Add((\\\"{0}{1}\\\" -f $name, $(if ($pnp) { \\\" [ID:$pnp]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    # Optional NVIDIA serials if nvidia-smi exists\\n    try {\\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\\n        if ($nvsmi) {\\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\\n            foreach ($line in @($raw)) {\\n                $t = Clean-Cell $line\\n                if ($t) { $gpus.Add(\\\"NVIDIA $t\\\") }\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-DiskInventory {\\n    $disks = New-Object System.Collections.Generic.List[string]\\n\\n    # Prefer Storage module when available\\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasPhysicalDisk) {\\n        try {\\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\\n                $name = Clean-Cell $d.FriendlyName\\n                $sn   = Clean-Cell $d.SerialNumber\\n                $mt   = Clean-Cell ([string]$d.MediaType)\\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n                $parts = @()\\n                if ($name) { $parts += $name }\\n                if ($sn)   { $parts += \\\"SN:$sn\\\" }\\n                if ($mt)   { $parts += \\\"Type:$mt\\\" }\\n                if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\\n            $model = Clean-Cell $d.Model\\n            $sn = \u0027\u0027\\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\\n            $devId = Clean-Cell $d.DeviceID\\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n            $parts = @()\\n            if ($model) { $parts += $model }\\n            if ($sn)    { $parts += \\\"SN:$sn\\\" }\\n            if ($devId) { $parts += \\\"Dev:$devId\\\" }\\n            if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-PciDeviceInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasGetPnpDevice) {\\n        try {\\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\\n                Where-Object { $_.InstanceId -like \u0027PCI\\\\*\u0027 } |\\n                Sort-Object -Property Class, FriendlyName, Name\\n\\n            foreach ($d in $devs) {\\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\\n                $name = Clean-Cell $name\\n                $cls  = Clean-Cell $d.Class\\n                $id   = Clean-Cell $d.InstanceId\\n                if ($name -or $id) {\\n                    $items.Add((\\\"{0}{1}{2}\\\" -f $name, $(if ($cls) { \\\" [Class:$cls]\\\" } else { \u0027\u0027 }), $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n                }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM Win32_PnPEntity\\n    try {\\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\\\*\u0027 } |\\n            Sort-Object -Property Name\\n\\n        foreach ($d in $devs) {\\n            $name = Clean-Cell $d.Name\\n            $id   = Clean-Cell $d.PNPDeviceID\\n            if ($name -or $id) {\\n                $items.Add((\\\"{0}{1}\\\" -f $name, $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - ANALYSIS\\n# ============================================================================\\n\\nfunction Get-ColumnMap {\\n    param([string[]]$Headers)\\n\\n    $map = @{\\n        Hostname        = \u0027Hostname\u0027\\n        User            = \u0027User\u0027\\n        System_Serial   = \u0027System_Serial\u0027\\n        RAM_GB          = \u0027RAM_GB\u0027\\n        Monitor_Serials = \u0027Monitor_Serials\u0027\\n        Scan_Date       = \u0027Scan_Date\u0027\\n    }\\n\\n    foreach ($k in @($map.Keys)) {\\n        if ($Headers -notcontains $map[$k]) {\\n            $alts = switch ($k) {\\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\\n                default           { @() }\\n            }\\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\\n            if ($found) { $map[$k] = $found }\\n        }\\n    }\\n\\n    return $map\\n}\\n\\nfunction Parse-ScanDate {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    $dt = $null\\n\\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n\\n    if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\\n\\n    return $null\\n}\\n\\nfunction Normalize-Serial {\\n    param([AllowNull()][string]$Serial)\\n\\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\\n    $s = ($Serial.Trim())\\n\\n    $bad = @(\\n        \u0027To Be Filled By O.E.M.\u0027,\\n        \u0027To Be Filled By OEM\u0027,\\n        \u0027Default string\u0027,\\n        \u0027System Serial Number\u0027,\\n        \u0027None\u0027,\\n        \u0027N/A\u0027,\\n        \u0027NA\u0027,\\n        \u00270\u0027,\\n        \u002700000000\u0027,\\n        \u00270000000000\u0027,\\n        \u00270000000000000000\u0027\\n    )\\n\\n    if ($bad -contains $s) { return \u0027\u0027 }\\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\\n\\n    return $s.ToUpperInvariant()\\n}\\n\\nfunction Parse-RamGB {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    $m = [regex]::Match($s, \u0027(\\\\d+)(\\\\.\\\\d+)?\u0027)\\n    if (-not $m.Success) { return $null }\\n\\n    $n = $null\\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\\n        return [int][math]::Round($n, 0)\\n    }\\n\\n    return $null\\n}\\n\\nfunction Is-MonitorMissing {\\n    param([AllowNull()][string]$Value)\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\\n    $t = $Value.Trim()\\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\\n}\\n\\n# ============================================================================\\n# MAIN: COLLECTION\\n# ============================================================================\\n\\nfunction Invoke-Collection {\\n    param([string]$OutPath, [switch]$IncludePci)\\n\\n    $errors = New-Object System.Collections.Generic.List[string]\\n\\n    Write-Host \\\"`n========================================================\\\" -ForegroundColor Cyan\\n    Write-Host \\\"   GATHERING HARDWARE SPECS... PLEASE WAIT\\\" -ForegroundColor Cyan\\n    Write-Host \\\"========================================================\\\" -ForegroundColor Cyan\\n\\n    # --- Collect core system info ---\\n    $sys  = $null\\n    $bios = $null\\n    $cpu  = $null\\n    $os   = $null\\n    $bb   = $null\\n\\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_ComputerSystem: $($_.Exception.Message)\\\") }\\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\\\"Win32_BIOS: $($_.Exception.Message)\\\") }\\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_Processor: $($_.Exception.Message)\\\") }\\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_OperatingSystem: $($_.Exception.Message)\\\") }\\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_BaseBoard: $($_.Exception.Message)\\\") }\\n\\n    # --- Derived values ---\\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\\n\\n    $ramGB = $null\\n    try {\\n        if ($sys -and $sys.TotalPhysicalMemory) {\\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\\n        }\\n    } catch {\\n        $errors.Add(\\\"RAM calc: $($_.Exception.Message)\\\")\\n    }\\n\\n    # --- Other sections ---\\n    $netStr  = \u0027\u0027\\n    $gpuStr  = \u0027\u0027\\n    $diskStr = \u0027\u0027\\n    $monStr  = \u0027\u0027\\n    $pciStr  = \u0027\u0027\\n\\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\\\"Network: $($_.Exception.Message)\\\") }\\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\\\"GPU: $($_.Exception.Message)\\\") }\\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\\\"Disks: $($_.Exception.Message)\\\") }\\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\\\"Monitors: $($_.Exception.Message)\\\") }\\n\\n    if ($IncludePci) {\\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\\\"PCI devices: $($_.Exception.Message)\\\") }\\n    }\\n\\n    # --- Build record ---\\n    $record = [pscustomobject]@{\\n        Hostname          = Clean-Cell $hostname\\n        User              = Clean-Cell $env:USERNAME\\n\\n        Make_Model        = Clean-Cell ((\\\"{0} {1}\\\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\\n\\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\\n        Baseboard_Product = Clean-Cell ($bb.Product)\\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\\n\\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\\n        BIOS_ReleaseDate  = Clean-Cell (try { ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027) } catch { \u0027\u0027 })\\n\\n        OS_Caption        = Clean-Cell ($os.Caption)\\n        OS_Version        = Clean-Cell ($os.Version)\\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\\n\\n        CPU               = Clean-Cell ($cpu.Name)\\n        RAM_GB            = $ramGB\\n\\n        Network_Adapters  = Clean-Cell $netStr\\n        GPUs              = Clean-Cell $gpuStr\\n        Disk_Serials      = Clean-Cell $diskStr\\n        Monitor_Serials   = Clean-Cell $monStr\\n\\n        PCI_Devices       = Clean-Cell $pciStr\\n\\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\\n        Collector_Version = \u00272.0\u0027\\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\\n    }\\n\\n    # --- CSV append with header safety ---\\n    $needHeader = $true\\n    if (Test-Path -LiteralPath $OutPath) {\\n        try {\\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\\n            if ($fi.Length -gt 0) { $needHeader = $false }\\n        } catch { $needHeader = $true }\\n    }\\n\\n    if ($needHeader) {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\\n    } else {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\\n    }\\n\\n    Write-Host \\\"`nSUCCESS!\\\" -ForegroundColor Green\\n    Write-Host \\\"Data saved to: $OutPath\\\" -ForegroundColor Gray\\n    if ($record.Errors) {\\n        Write-Host (\\\"Warnings captured in Errors column: {0}\\\" -f $record.Errors) -ForegroundColor Yellow\\n    }\\n}\\n\\n# ============================================================================\\n# MAIN: ANALYSIS\\n# ============================================================================\\n\\nfunction Invoke-Analysis {\\n    param(\\n        [string]$InputPath,\\n        [int]$StaleDaysThreshold,\\n        [int]$MinRam,\\n        [switch]$SkipCsv\\n    )\\n\\n    $ReportFile = Join-Path -Path $PSScriptRoot -ChildPath \u0027Inventory_Issues_Report.txt\u0027\\n    $IssuesCsv  = Join-Path -Path $PSScriptRoot -ChildPath \u0027Inventory_Issues_Report.csv\u0027\\n\\n    if (-not (Test-Path -LiteralPath $InputPath)) {\\n        Write-Warning \\\"Input file not found: $InputPath\\\"\\n        Write-Warning \\\"Run the script without -AnalyzeOnly first to collect data.\\\"\\n        return\\n    }\\n\\n    $raw = Import-Csv -LiteralPath $InputPath\\n    if (-not $raw -or $raw.Count -eq 0) {\\n        Write-Warning \\\"Input file contains no rows: $InputPath\\\"\\n        return\\n    }\\n\\n    $headers = @()\\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\\n    $col = Get-ColumnMap -Headers $headers\\n\\n    $today = Get-Date\\n\\n    # Normalize data and add helper properties\\n    $data = foreach ($r in $raw) {\\n        $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\\n        $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\\n        $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\\n        $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\\n        $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\\n        $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\\n\\n        $serialN = Normalize-Serial $serial\\n        $scanDt  = Parse-ScanDate $scan\\n        $ramGb   = Parse-RamGB $ram\\n\\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\\n\\n        # Asset key: prefer System Serial, fallback to Hostname\\n        $assetKey = \u0027\u0027\\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\\n            $assetKey = $serialN\\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\\n            $assetKey = $h.Trim().ToUpperInvariant()\\n        }\\n\\n        [pscustomobject]@{\\n            Hostname        = $h.Trim()\\n            User            = $u.Trim()\\n            System_Serial   = $serialN\\n            RAM_GB          = $ramGb\\n            Monitor_Serials = $m.Trim()\\n            Scan_Date       = $s.Trim()\\n\\n            ScanDateParsed  = $scanDt\\n            AssetKey        = $assetKey\\n            RawRow          = $r\\n        }\\n    }\\n\\n    # Latest record per asset\\n    $latestByAsset = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\\n        Group-Object -Property AssetKey |\\n        ForEach-Object { $_.Group | Select-Object -First 1 }\\n\\n    $issues = New-Object System.Collections.Generic.List[object]\\n\\n    function Add-Issue {\\n        param(\\n            [Parameter(Mandatory)][string]$IssueType,\\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\\n            [string]$AssetKey,\\n            [string]$Hostname,\\n            [string]$User,\\n            [string]$SystemSerial,\\n            [string]$ScanDate,\\n            [string]$Details\\n        )\\n\\n        $issues.Add([pscustomobject]@{\\n            IssueType     = $IssueType\\n            Severity      = $Severity\\n            AssetKey      = $AssetKey\\n            Hostname      = $Hostname\\n            User          = $User\\n            System_Serial = $SystemSerial\\n            Scan_Date     = $ScanDate\\n            Details       = $Details\\n        })\\n    }\\n\\n    # 0) Data quality (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\\n        }\\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\\n        }\\n        if (-not $pc.ScanDateParsed) {\\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\\n        }\\n    }\\n\\n    # 1) Duplicate serials (all rows; ignore blanks)\\n    $dupeGroups = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\\n        Group-Object -Property System_Serial |\\n        Where-Object { $_.Count -gt 1 }\\n\\n    foreach ($g in $dupeGroups) {\\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\\n\\n        $severity =\\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\\n            else { \u0027Info\u0027 }\\n\\n        $entries = $g.Group |\\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\\n            ForEach-Object {\\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\\n                \\\"{0} ({1})\\\" -f $_.Hostname, $d\\n            }\\n\\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\\\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\\\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\\n    }\\n\\n    # 2) Low RAM (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\\\"RAM_GB={0} (min {1})\\\" -f $pc.RAM_GB, $MinRam)\\n        } elseif ($null -eq $pc.RAM_GB) {\\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\\n        }\\n    }\\n\\n    # 3) Stale assets (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($pc.ScanDateParsed) {\\n            $ageDays = ($today - $pc.ScanDateParsed).Days\\n            if ($ageDays -gt $StaleDaysThreshold) {\\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\\\"Last seen {0} days ago (threshold {1})\\\" -f $ageDays, $StaleDaysThreshold)\\n            }\\n        }\\n    }\\n\\n    # 4) Missing monitor serials (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\\n        }\\n    }\\n\\n    # --- Build text report ---\\n    $generated = Get-Date\\n    $line = (\u0027=\u0027 * 70)\\n\\n    $txt = New-Object System.Collections.Generic.List[string]\\n    $txt.Add($line)\\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\\n    $txt.Add(\\\"Generated: $generated\\\")\\n    $txt.Add(\\\"Input:     $InputPath\\\")\\n    $txt.Add((\\\"Assets:    {0} (latest per asset)\\\" -f $latestByAsset.Count))\\n    $txt.Add((\\\"Rows:      {0} (raw rows in CSV)\\\" -f $data.Count))\\n    $txt.Add((\\\"Settings:  MinRamGB={0}, StaleDays={1}\\\" -f $MinRam, $StaleDaysThreshold))\\n    $txt.Add($line)\\n    $txt.Add(\u0027\u0027)\\n\\n    if ($issues.Count -eq 0) {\\n        $txt.Add(\u0027No issues found.\u0027)\\n    } else {\\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\\n        foreach ($t in $byType) {\\n            $txt.Add((\\\"--- {0} ({1}) ---\\\" -f $t.Name, $t.Count))\\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\\n\\n                $txt.Add((\\\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\\\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\\n            }\\n            $txt.Add(\u0027\u0027)\\n        }\\n    }\\n\\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\\n\\n    if (-not $SkipCsv) {\\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\\n    }\\n\\n    # --- Console summary ---\\n    Write-Host \\\"`n$line\\\" -ForegroundColor Cyan\\n    Write-Host (\\\"Report saved: {0}\\\" -f $ReportFile) -ForegroundColor Green\\n    if (-not $SkipCsv) { Write-Host (\\\"Issues CSV:   {0}\\\" -f $IssuesCsv) -ForegroundColor Green }\\n    Write-Host (\\\"Issues found: {0}\\\" -f $issues.Count) -ForegroundColor Yellow\\n    Write-Host $line -ForegroundColor Cyan\\n\\n    if ($issues.Count -gt 0) {\\n        $sev = $issues | Group-Object Severity | Sort-Object Name\\n        foreach ($s in $sev) {\\n            $c = switch ($s.Name) {\\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\\n                default    { [ConsoleColor]::Gray }\\n            }\\n            Write-Host (\\\"{0}: {1}\\\" -f $s.Name, $s.Count) -ForegroundColor $c\\n        }\\n    }\\n}\\n\\n# ============================================================================\\n# ENTRY POINT\\n# ============================================================================\\n\\nif (-not $AnalyzeOnly) {\\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\\n}\\n\\nif ($Analyze -or $AnalyzeOnly) {\\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv\\n}\\n\\nif (-not $AnalyzeOnly -and -not $Analyze) {\\n    Write-Host \\\"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\\\" -ForegroundColor DarkGray\\n}\\n\"}","name":"write","params":"{\"relativeWorkspacePath\":\"USB-Inventory.ps1\",\"code\":{\"code\":\"#\"}}","additionalData":{"codeblockId":"42a82eb6-01bb-43cb-8c7c-022862dd15b9"},"userDecision":"accepted","result":"{\"diff\":{\"chunks\":[{\"diffString\":\"- \\n+ #requires -Version 5.1\\n+ \u003c#\\n+ .SYNOPSIS\\n+     USB-portable PC hardware inventory collection and analysis tool.\\n+ \\n+ .DESCRIPTION\\n+     Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\\n+     current PC and appends it to PC_Inventory_Master.csv in the same folder as the\\n+     script. Optionally runs health analysis to detect duplicates, stale assets,\\n+     low RAM, and missing monitor data.\\n+ \\n+     Run this script from a USB drive to inventory multiple PCs into a single CSV.\\n+ \\n+ .PARAMETER OutputFile\\n+     Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\\n+ \\n+ .PARAMETER IncludePciDevices\\n+     Include detailed PCI device enumeration (can produce large output).\\n+ \\n+ .PARAMETER Analyze\\n+     After collection, run health analysis on the CSV file.\\n+ \\n+ .PARAMETER AnalyzeOnly\\n+     Skip collection; only run health analysis on existing CSV.\\n+ \\n+ .PARAMETER StaleDays\\n+     Threshold in days for flagging stale assets. Default: 90.\\n+ \\n+ .PARAMETER MinRamGB\\n+     Minimum RAM in GB; systems below this are flagged. Default: 8.\\n+ \\n+ .PARAMETER NoCsv\\n+     Do not output Inventory_Issues_Report.csv (text report only).\\n+ \\n+ .EXAMPLE\\n+     .\\\\USB-Inventory.ps1\\n+     Collect inventory from this PC into PC_Inventory_Master.csv.\\n+ \\n+ .EXAMPLE\\n+     .\\\\USB-Inventory.ps1 -IncludePciDevices -Analyze\\n+     Collect inventory with PCI devices, then run health analysis.\\n+ \\n+ .EXAMPLE\\n+     .\\\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\\n+     Analyze existing CSV with custom thresholds (no new collection).\\n+ #\u003e\\n+ \\n+ [CmdletBinding()]\\n+ param(\\n+     [string]$OutputFile = (Join-Path -Path $PSScriptRoot -ChildPath \u0027PC_Inventory_Master.csv\u0027),\\n+     [switch]$IncludePciDevices,\\n+     [switch]$Analyze,\\n+     [switch]$AnalyzeOnly,\\n+     [int]$StaleDays = 90,\\n+     [int]$MinRamGB = 8,\\n+     [switch]$NoCsv\\n+ )\\n+ \\n+ Set-StrictMode -Version Latest\\n+ $ErrorActionPreference = \u0027Stop\u0027\\n+ \\n+ # ============================================================================\\n+ # HELPER FUNCTIONS - COLLECTION\\n+ # ============================================================================\\n+ \\n+ function Clean-Cell {\\n+     param([AllowNull()][string]$Text)\\n+     if ($null -eq $Text) { return \u0027\u0027 }\\n+     return ($Text -replace \\\"(`r`n|`n|`r|`t)+\\\", \u0027 \u0027).Trim()\\n+ }\\n+ \\n+ function Convert-UShortArrayToString {\\n+     param([AllowNull()]$Arr)\\n+     if ($null -eq $Arr) { return \u0027\u0027 }\\n+     $chars = foreach ($x in $Arr) {\\n+         if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\\n+     }\\n+     return ( -join $chars ).Trim()\\n+ }\\n+ \\n+ function Get-MonitorInventory {\\n+     \u003c#\\n+       Preferred: root\\\\wmi:WmiMonitorID (easy, consistent, usually no admin)\\n+       Fallback: registry EDID decode under HKLM:\\\\SYSTEM\\\\CCS\\\\Enum\\\\DISPLAY\\n+     #\u003e\\n+ \\n+     $results = New-Object System.Collections.Generic.List[string]\\n+ \\n+     # --- Preferred path: WmiMonitorID ---\\n+     try {\\n+         $wmiMons = Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorID -ErrorAction Stop\\n+         foreach ($m in $wmiMons) {\\n+             $mfg  = Convert-UShortArrayToString $m.ManufacturerName\\n+             $name = Convert-UShortArrayToString $m.UserFriendlyName\\n+             $sn   = Convert-UShortArrayToString $m.SerialNumberID\\n+ \\n+             $label = @()\\n+             if ($mfg)  { $label += $mfg }\\n+             if ($name) { $label += $name }\\n+ \\n+             $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\\n+             $serialPart  = if ($sn) { \\\"SN:$sn\\\" } else { \u0027SN:(none)\u0027 }\\n+ \\n+             $results.Add(\\\"$displayName ($serialPart)\\\")\\n+         }\\n+     } catch {\\n+         # WmiMonitorID not available; fall through to EDID fallback\\n+     }\\n+ \\n+     if ($results.Count -gt 0) {\\n+         return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n+     }\\n+ \\n+     # --- Fallback path: registry EDID decode ---\\n+     function Get-EdidDescriptorString {\\n+         param(\\n+             [byte[]]$Edid,\\n+             [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\\n+         )\\n+ \\n+         if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\\n+ \\n+         $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\\n+ \\n+         foreach ($offset in 54,72,90,108) {\\n+             if (($offset + 18) -gt $Edid.Length) { continue }\\n+ \\n+             # Descriptor: 00 00 00 {tag} 00 ...\\n+             if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\\n+                 $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\\n+ \\n+                 $bytes = $Edid[($offset+5)..($offset+17)]\\n+                 $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\\n+                 $text = ($text -replace \\\"[`0`n`r]+\\\", \u0027\u0027).Trim()\\n+                 if ($text) { return $text }\\n+             }\\n+         }\\n+ \\n+         return \u0027\u0027\\n+     }\\n+ \\n+     try {\\n+         $root = \u0027HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Enum\\\\DISPLAY\u0027\\n+         if (Test-Path -LiteralPath $root) {\\n+             Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\\n+                 Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\\n+                     $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\\n+                     if (Test-Path -LiteralPath $params) {\\n+                         $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\\n+                         if ($edid -is [byte[]]) {\\n+                             $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\\n+                             $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\\n+ \\n+                             # Numeric serial (bytes 12-15 LE) sometimes present\\n+                             $num = [BitConverter]::ToUInt32($edid, 12)\\n+                             $numStr = if ($num -ne 0) { \\\"NUM:$num\\\" } else { \u0027\u0027 }\\n+ \\n+                             $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\\n+                             $serialPart  = if ($sn) { \\\"SN:$sn\\\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\\n+ \\n+                             $results.Add(\\\"$displayName ($serialPart)\\\")\\n+                         }\\n+                     }\\n+                 }\\n+             }\\n+         }\\n+     } catch {\\n+         # EDID fallback failed silently\\n+     }\\n+ \\n+     if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\\n+     return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n+ }\\n+ \\n+ function Get-NetworkInventory {\\n+     $items = New-Object System.Collections.Generic.List[string]\\n+ \\n+     $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\\n+     $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\\n+ \\n+     if ($hasNetAdapter -and $hasNetIpCfg) {\\n+         try {\\n+             $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\\n+             foreach ($a in $adapters) {\\n+                 $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\\n+                 $ipv4 = @()\\n+                 if ($cfg -and $cfg.IPv4Address) {\\n+                     $ipv4 = $cfg.IPv4Address |\\n+                         ForEach-Object { $_.IPAddress } |\\n+                         Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\\n+                 }\\n+                 $gw = @()\\n+                 if ($cfg -and $cfg.IPv4DefaultGateway) {\\n+                     $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\\n+                 }\\n+ \\n+                 $parts = @()\\n+                 $parts += (Clean-Cell $a.Name)\\n+                 if ($a.MacAddress) { $parts += \\\"MAC:$($a.MacAddress)\\\" }\\n+                 if ($ipv4.Count -gt 0) { $parts += (\\\"IPv4:\\\" + ($ipv4 -join \u0027;\u0027)) }\\n+                 if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n+ \\n+                 $items.Add(($parts -join \u0027 \u0027))\\n+             }\\n+         } catch {\\n+             # Fall back to CIM below\\n+         }\\n+     }\\n+ \\n+     if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n+ \\n+     # Fallback: CIM\\n+     try {\\n+         $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\\n+             Where-Object { $_.IPEnabled -eq $true }\\n+ \\n+         foreach ($n in $net) {\\n+             $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\\n+             $mac  = $n.MACAddress\\n+             $ips  = @()\\n+             if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\\n+             $gw   = @()\\n+             if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\\n+ \\n+             $parts = @()\\n+             $parts += (Clean-Cell $name)\\n+             if ($mac) { $parts += \\\"MAC:$mac\\\" }\\n+             if ($ips.Count -gt 0) { $parts += (\\\"IP:\\\" + ($ips -join \u0027;\u0027)) }\\n+             if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n+ \\n+             $items.Add(($parts -join \u0027 \u0027))\\n+         }\\n+     } catch {\\n+         # Ignore\\n+     }\\n+ \\n+     if ($items.Count -eq 0) { return \u0027\u0027 }\\n+     return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n+ }\\n+ \\n+ function Get-GpuInventory {\\n+     $gpus = New-Object System.Collections.Generic.List[string]\\n+ \\n+     # CIM GPUs\\n+     try {\\n+         $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\\n+         foreach ($g in $vc) {\\n+             $name = Clean-Cell $g.Name\\n+             $pnp  = Clean-Cell $g.PNPDeviceID\\n+             if ($name -or $pnp) {\\n+                 $gpus.Add((\\\"{0}{1}\\\" -f $name, $(if ($pnp) { \\\" [ID:$pnp]\\\" } else { \u0027\u0027 })))\\n+             }\\n+         }\\n+     } catch {\\n+         # Ignore\\n+     }\\n+ \\n+     # Optional NVIDIA serials if nvidia-smi exists\\n+     try {\\n+         $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\\n+         if ($nvsmi) {\\n+             $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\\n+             foreach ($line in @($raw)) {\\n+                 $t = Clean-Cell $line\\n+                 if ($t) { $gpus.Add(\\\"NVIDIA $t\\\") }\\n+             }\\n+         }\\n+     } catch {\\n+         # Ignore\\n+     }\\n+ \\n+     if ($gpus.Count -eq 0) { return \u0027\u0027 }\\n+     return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\\n+ }\\n+ \\n+ function Get-DiskInventory {\\n+     $disks = New-Object System.Collections.Generic.List[string]\\n+ \\n+     # Prefer Storage module when available\\n+     $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\\n+     if ($hasPhysicalDisk) {\\n+         try {\\n+             foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\\n+                 $name = Clean-Cell $d.FriendlyName\\n+                 $sn   = Clean-Cell $d.SerialNumber\\n+                 $mt   = Clean-Cell ([string]$d.MediaType)\\n+                 $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n+ \\n+                 $parts = @()\\n+                 if ($name) { $parts += $name }\\n+                 if ($sn)   { $parts += \\\"SN:$sn\\\" }\\n+                 if ($mt)   { $parts += \\\"Type:$mt\\\" }\\n+                 if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n+ \\n+                 if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n+             }\\n+         } catch {\\n+             # Fall back below\\n+         }\\n+     }\\n+ \\n+     if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n+ \\n+     # Fallback: CIM\\n+     try {\\n+         foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\\n+             $model = Clean-Cell $d.Model\\n+             $sn = \u0027\u0027\\n+             try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\\n+             $devId = Clean-Cell $d.DeviceID\\n+             $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n+ \\n+             $parts = @()\\n+             if ($model) { $parts += $model }\\n+             if ($sn)    { $parts += \\\"SN:$sn\\\" }\\n+             if ($devId) { $parts += \\\"Dev:$devId\\\" }\\n+             if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n+ \\n+             if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n+         }\\n+     } catch {\\n+         # Ignore\\n+     }\\n+ \\n+     if ($disks.Count -eq 0) { return \u0027\u0027 }\\n+     return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\\n+ }\\n+ \\n+ function Get-PciDeviceInventory {\\n+     $items = New-Object System.Collections.Generic.List[string]\\n+ \\n+     $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\\n+     if ($hasGetPnpDevice) {\\n+         try {\\n+             $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\\n+                 Where-Object { $_.InstanceId -like \u0027PCI\\\\*\u0027 } |\\n+                 Sort-Object -Property Class, FriendlyName, Name\\n+ \\n+             foreach ($d in $devs) {\\n+                 $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\\n+                 $name = Clean-Cell $name\\n+                 $cls  = Clean-Cell $d.Class\\n+                 $id   = Clean-Cell $d.InstanceId\\n+                 if ($name -or $id) {\\n+                     $items.Add((\\\"{0}{1}{2}\\\" -f $name, $(if ($cls) { \\\" [Class:$cls]\\\" } else { \u0027\u0027 }), $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n+                 }\\n+             }\\n+         } catch {\\n+             # Fall back below\\n+         }\\n+     }\\n+ \\n+     if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n+ \\n+     # Fallback: CIM Win32_PnPEntity\\n+     try {\\n+         $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\\n+             Where-Object { $_.PNPDeviceID -like \u0027PCI\\\\*\u0027 } |\\n+             Sort-Object -Property Name\\n+ \\n+         foreach ($d in $devs) {\\n+             $name = Clean-Cell $d.Name\\n+             $id   = Clean-Cell $d.PNPDeviceID\\n+             if ($name -or $id) {\\n+                 $items.Add((\\\"{0}{1}\\\" -f $name, $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n+             }\\n+         }\\n+     } catch {\\n+         # Ignore\\n+     }\\n+ \\n+     if ($items.Count -eq 0) { return \u0027\u0027 }\\n+     return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n+ }\\n+ \\n+ # ============================================================================\\n+ # HELPER FUNCTIONS - ANALYSIS\\n+ # ============================================================================\\n+ \\n+ function Get-ColumnMap {\\n+     param([string[]]$Headers)\\n+ \\n+     $map = @{\\n+         Hostname        = \u0027Hostname\u0027\\n+         User            = \u0027User\u0027\\n+         System_Serial   = \u0027System_Serial\u0027\\n+         RAM_GB          = \u0027RAM_GB\u0027\\n+         Monitor_Serials = \u0027Monitor_Serials\u0027\\n+         Scan_Date       = \u0027Scan_Date\u0027\\n+     }\\n+ \\n+     foreach ($k in @($map.Keys)) {\\n+         if ($Headers -notcontains $map[$k]) {\\n+             $alts = switch ($k) {\\n+                 \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\\n+                 \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\\n+                 \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\\n+                 \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\\n+                 \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\\n+                 \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\\n+                 default           { @() }\\n+             }\\n+             $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\\n+             if ($found) { $map[$k] = $found }\\n+         }\\n+     }\\n+ \\n+     return $map\\n+ }\\n+ \\n+ function Parse-ScanDate {\\n+     param([AllowNull()][string]$Value)\\n+ \\n+     if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n+     $s = $Value.Trim()\\n+ \\n+     $dt = $null\\n+ \\n+     if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n+     if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n+ \\n+     if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\\n+ \\n+     return $null\\n+ }\\n+ \\n+ function Normalize-Serial {\\n+     param([AllowNull()][string]$Serial)\\n+ \\n+     if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\\n+     $s = ($Serial.Trim())\\n+ \\n+     $bad = @(\\n+         \u0027To Be Filled By O.E.M.\u0027,\\n+         \u0027To Be Filled By OEM\u0027,\\n+         \u0027Default string\u0027,\\n+         \u0027System Serial Number\u0027,\\n+         \u0027None\u0027,\\n+         \u0027N/A\u0027,\\n+         \u0027NA\u0027,\\n+         \u00270\u0027,\\n+         \u002700000000\u0027,\\n+         \u00270000000000\u0027,\\n+         \u00270000000000000000\u0027\\n+     )\\n+ \\n+     if ($bad -contains $s) { return \u0027\u0027 }\\n+     if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\\n+ \\n+     return $s.ToUpperInvariant()\\n+ }\\n+ \\n+ function Parse-RamGB {\\n+     param([AllowNull()][string]$Value)\\n+ \\n+     if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n+     $s = $Value.Trim()\\n+ \\n+     $m = [regex]::Match($s, \u0027(\\\\d+)(\\\\.\\\\d+)?\u0027)\\n+     if (-not $m.Success) { return $null }\\n+ \\n+     $n = $null\\n+     if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\\n+         return [int][math]::Round($n, 0)\\n+     }\\n+ \\n+     return $null\\n+ }\\n+ \\n+ function Is-MonitorMissing {\\n+     param([AllowNull()][string]$Value)\\n+     if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\\n+     $t = $Value.Trim()\\n+     return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\\n+ }\\n+ \\n+ # ============================================================================\\n+ # MAIN: COLLECTION\\n+ # ============================================================================\\n+ \\n+ function Invoke-Collection {\\n+     param([string]$OutPath, [switch]$IncludePci)\\n+ \\n+     $errors = New-Object System.Collections.Generic.List[string]\\n+ \\n+     Write-Host \\\"`n========================================================\\\" -ForegroundColor Cyan\\n+     Write-Host \\\"   GATHERING HARDWARE SPECS... PLEASE WAIT\\\" -ForegroundColor Cyan\\n+     Write-Host \\\"========================================================\\\" -ForegroundColor Cyan\\n+ \\n+     # --- Collect core system info ---\\n+     $sys  = $null\\n+     $bios = $null\\n+     $cpu  = $null\\n+     $os   = $null\\n+     $bb   = $null\\n+ \\n+     try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_ComputerSystem: $($_.Exception.Message)\\\") }\\n+     try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\\\"Win32_BIOS: $($_.Exception.Message)\\\") }\\n+     try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_Processor: $($_.Exception.Message)\\\") }\\n+     try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_OperatingSystem: $($_.Exception.Message)\\\") }\\n+     try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_BaseBoard: $($_.Exception.Message)\\\") }\\n+ \\n+     # --- Derived values ---\\n+     $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\\n+     if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\\n+ \\n+     $ramGB = $null\\n+     try {\\n+         if ($sys -and $sys.TotalPhysicalMemory) {\\n+             $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\\n+         }\\n+     } catch {\\n+         $errors.Add(\\\"RAM calc: $($_.Exception.Message)\\\")\\n+     }\\n+ \\n+     # --- Other sections ---\\n+     $netStr  = \u0027\u0027\\n+     $gpuStr  = \u0027\u0027\\n+     $diskStr = \u0027\u0027\\n+     $monStr  = \u0027\u0027\\n+     $pciStr  = \u0027\u0027\\n+ \\n+     try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\\\"Network: $($_.Exception.Message)\\\") }\\n+     try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\\\"GPU: $($_.Exception.Message)\\\") }\\n+     try { $diskStr = Get-DiskInventory } catch { $errors.Add(\\\"Disks: $($_.Exception.Message)\\\") }\\n+     try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\\\"Monitors: $($_.Exception.Message)\\\") }\\n+ \\n+     if ($IncludePci) {\\n+         try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\\\"PCI devices: $($_.Exception.Message)\\\") }\\n+     }\\n+ \\n+     # --- Build record ---\\n+     $record = [pscustomobject]@{\\n+         Hostname          = Clean-Cell $hostname\\n+         User              = Clean-Cell $env:USERNAME\\n+ \\n+         Make_Model        = Clean-Cell ((\\\"{0} {1}\\\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\\n+         System_Serial     = Clean-Cell ($bios.SerialNumber)\\n+ \\n+         Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\\n+         Baseboard_Product = Clean-Cell ($bb.Product)\\n+         Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\\n+ \\n+         BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\\n+         BIOS_ReleaseDate  = Clean-Cell (try { ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027) } catch { \u0027\u0027 })\\n+ \\n+         OS_Caption        = Clean-Cell ($os.Caption)\\n+         OS_Version        = Clean-Cell ($os.Version)\\n+         OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\\n+ \\n+         CPU               = Clean-Cell ($cpu.Name)\\n+         RAM_GB            = $ramGB\\n+ \\n+         Network_Adapters  = Clean-Cell $netStr\\n+         GPUs              = Clean-Cell $gpuStr\\n+         Disk_Serials      = Clean-Cell $diskStr\\n+         Monitor_Serials   = Clean-Cell $monStr\\n+ \\n+         PCI_Devices       = Clean-Cell $pciStr\\n+ \\n+         Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\\n+         Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\\n+         Collector_Version = \u00272.0\u0027\\n+         Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\\n+     }\\n+ \\n+     # --- CSV append with header safety ---\\n+     $needHeader = $true\\n+     if (Test-Path -LiteralPath $OutPath) {\\n+         try {\\n+             $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\\n+             if ($fi.Length -gt 0) { $needHeader = $false }\\n+         } catch { $needHeader = $true }\\n+     }\\n+ \\n+     if ($needHeader) {\\n+         $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\\n+     } else {\\n+         $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\\n+     }\\n+ \\n+     Write-Host \\\"`nSUCCESS!\\\" -ForegroundColor Green\\n+     Write-Host \\\"Data saved to: $OutPath\\\" -ForegroundColor Gray\\n+     if ($record.Errors) {\\n+         Write-Host (\\\"Warnings captured in Errors column: {0}\\\" -f $record.Errors) -ForegroundColor Yellow\\n+     }\\n+ }\\n+ \\n+ # ============================================================================\\n+ # MAIN: ANALYSIS\\n+ # ============================================================================\\n+ \\n+ function Invoke-Analysis {\\n+     param(\\n+         [string]$InputPath,\\n+         [int]$StaleDaysThreshold,\\n+         [int]$MinRam,\\n+         [switch]$SkipCsv\\n+     )\\n+ \\n+     $ReportFile = Join-Path -Path $PSScriptRoot -ChildPath \u0027Inventory_Issues_Report.txt\u0027\\n+     $IssuesCsv  = Join-Path -Path $PSScriptRoot -ChildPath \u0027Inventory_Issues_Report.csv\u0027\\n+ \\n+     if (-not (Test-Path -LiteralPath $InputPath)) {\\n+         Write-Warning \\\"Input file not found: $InputPath\\\"\\n+         Write-Warning \\\"Run the script without -AnalyzeOnly first to collect data.\\\"\\n+         return\\n+     }\\n+ \\n+     $raw = Import-Csv -LiteralPath $InputPath\\n+     if (-not $raw -or $raw.Count -eq 0) {\\n+         Write-Warning \\\"Input file contains no rows: $InputPath\\\"\\n+         return\\n+     }\\n+ \\n+     $headers = @()\\n+     try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\\n+     $col = Get-ColumnMap -Headers $headers\\n+ \\n+     $today = Get-Date\\n+ \\n+     # Normalize data and add helper properties\\n+     $data = foreach ($r in $raw) {\\n+         $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\\n+         $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\\n+         $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\\n+         $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\\n+         $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\\n+         $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\\n+ \\n+         $serialN = Normalize-Serial $serial\\n+         $scanDt  = Parse-ScanDate $scan\\n+         $ramGb   = Parse-RamGB $ram\\n+ \\n+         $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\\n+         $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\\n+         $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\\n+         $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\\n+ \\n+         # Asset key: prefer System Serial, fallback to Hostname\\n+         $assetKey = \u0027\u0027\\n+         if (-not [string]::IsNullOrWhiteSpace($serialN)) {\\n+             $assetKey = $serialN\\n+         } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\\n+             $assetKey = $h.Trim().ToUpperInvariant()\\n+         }\\n+ \\n+         [pscustomobject]@{\\n+             Hostname        = $h.Trim()\\n+             User            = $u.Trim()\\n+             System_Serial   = $serialN\\n+             RAM_GB          = $ramGb\\n+             Monitor_Serials = $m.Trim()\\n+             Scan_Date       = $s.Trim()\\n+ \\n+             ScanDateParsed  = $scanDt\\n+             AssetKey        = $assetKey\\n+             RawRow          = $r\\n+         }\\n+     }\\n+ \\n+     # Latest record per asset\\n+     $latestByAsset = $data |\\n+         Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\\n+         Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\\n+         Group-Object -Property AssetKey |\\n+         ForEach-Object { $_.Group | Select-Object -First 1 }\\n+ \\n+     $issues = New-Object System.Collections.Generic.List[object]\\n+ \\n+     function Add-Issue {\\n+         param(\\n+             [Parameter(Mandatory)][string]$IssueType,\\n+             [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\\n+             [string]$AssetKey,\\n+             [string]$Hostname,\\n+             [string]$User,\\n+             [string]$SystemSerial,\\n+             [string]$ScanDate,\\n+             [string]$Details\\n+         )\\n+ \\n+         $issues.Add([pscustomobject]@{\\n+             IssueType     = $IssueType\\n+             Severity      = $Severity\\n+             AssetKey      = $AssetKey\\n+             Hostname      = $Hostname\\n+             User          = $User\\n+             System_Serial = $SystemSerial\\n+             Scan_Date     = $ScanDate\\n+             Details       = $Details\\n+         })\\n+     }\\n+ \\n+     # 0) Data quality (latest records)\\n+     foreach ($pc in $latestByAsset) {\\n+         if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\\n+             Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\\n+         }\\n+         if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\\n+             Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\\n+         }\\n+         if (-not $pc.ScanDateParsed) {\\n+             Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\\n+         }\\n+     }\\n+ \\n+     # 1) Duplicate serials (all rows; ignore blanks)\\n+     $dupeGroups = $data |\\n+         Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\\n+         Group-Object -Property System_Serial |\\n+         Where-Object { $_.Count -gt 1 }\\n+ \\n+     foreach ($g in $dupeGroups) {\\n+         $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\\n+         $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\\n+ \\n+         $severity =\\n+             if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\\n+             else { \u0027Info\u0027 }\\n+ \\n+         $entries = $g.Group |\\n+             Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\\n+             ForEach-Object {\\n+                 $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\\n+                 \\\"{0} ({1})\\\" -f $_.Hostname, $d\\n+             }\\n+ \\n+         Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\\\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\\\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\\n+     }\\n+ \\n+     # 2) Low RAM (latest records)\\n+     foreach ($pc in $latestByAsset) {\\n+         if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\\n+             Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\\\"RAM_GB={0} (min {1})\\\" -f $pc.RAM_GB, $MinRam)\\n+         } elseif ($null -eq $pc.RAM_GB) {\\n+             Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\\n+         }\\n+     }\\n+ \\n+     # 3) Stale assets (latest records)\\n+     foreach ($pc in $latestByAsset) {\\n+         if ($pc.ScanDateParsed) {\\n+             $ageDays = ($today - $pc.ScanDateParsed).Days\\n+             if ($ageDays -gt $StaleDaysThreshold) {\\n+                 Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\\\"Last seen {0} days ago (threshold {1})\\\" -f $ageDays, $StaleDaysThreshold)\\n+             }\\n+         }\\n+     }\\n+ \\n+     # 4) Missing monitor serials (latest records)\\n+     foreach ($pc in $latestByAsset) {\\n+         if (Is-MonitorMissing $pc.Monitor_Serials) {\\n+             Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\\n+         }\\n+     }\\n+ \\n+     # --- Build text report ---\\n+     $generated = Get-Date\\n+     $line = (\u0027=\u0027 * 70)\\n+ \\n+     $txt = New-Object System.Collections.Generic.List[string]\\n+     $txt.Add($line)\\n+     $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\\n+     $txt.Add(\\\"Generated: $generated\\\")\\n+     $txt.Add(\\\"Input:     $InputPath\\\")\\n+     $txt.Add((\\\"Assets:    {0} (latest per asset)\\\" -f $latestByAsset.Count))\\n+     $txt.Add((\\\"Rows:      {0} (raw rows in CSV)\\\" -f $data.Count))\\n+     $txt.Add((\\\"Settings:  MinRamGB={0}, StaleDays={1}\\\" -f $MinRam, $StaleDaysThreshold))\\n+     $txt.Add($line)\\n+     $txt.Add(\u0027\u0027)\\n+ \\n+     if ($issues.Count -eq 0) {\\n+         $txt.Add(\u0027No issues found.\u0027)\\n+     } else {\\n+         $byType = $issues | Group-Object IssueType | Sort-Object Name\\n+         foreach ($t in $byType) {\\n+             $txt.Add((\\\"--- {0} ({1}) ---\\\" -f $t.Name, $t.Count))\\n+             foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\\n+                 $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\\n+                 $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\\n+                 $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\\n+                 $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\\n+                 $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\\n+ \\n+                 $txt.Add((\\\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\\\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\\n+             }\\n+             $txt.Add(\u0027\u0027)\\n+         }\\n+     }\\n+ \\n+     $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\\n+ \\n+     if (-not $SkipCsv) {\\n+         $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\\n+             Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\\n+     }\\n+ \\n+     # --- Console summary ---\\n+     Write-Host \\\"`n$line\\\" -ForegroundColor Cyan\\n+     Write-Host (\\\"Report saved: {0}\\\" -f $ReportFile) -ForegroundColor Green\\n+     if (-not $SkipCsv) { Write-Host (\\\"Issues CSV:   {0}\\\" -f $IssuesCsv) -ForegroundColor Green }\\n+     Write-Host (\\\"Issues found: {0}\\\" -f $issues.Count) -ForegroundColor Yellow\\n+     Write-Host $line -ForegroundColor Cyan\\n+ \\n+     if ($issues.Count -gt 0) {\\n+         $sev = $issues | Group-Object Severity | Sort-Object Name\\n+         foreach ($s in $sev) {\\n+             $c = switch ($s.Name) {\\n+                 \u0027Critical\u0027 { [ConsoleColor]::Red }\\n+                 \u0027Warning\u0027  { [ConsoleColor]::Yellow }\\n+                 default    { [ConsoleColor]::Gray }\\n+             }\\n+             Write-Host (\\\"{0}: {1}\\\" -f $s.Name, $s.Count) -ForegroundColor $c\\n+         }\\n+     }\\n+ }\\n+ \\n+ # ============================================================================\\n+ # ENTRY POINT\\n+ # ============================================================================\\n+ \\n+ if (-not $AnalyzeOnly) {\\n+     Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\\n+ }\\n+ \\n+ if ($Analyze -or $AnalyzeOnly) {\\n+     Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv\\n+ }\\n+ \\n+ if (-not $AnalyzeOnly -and -not $Analyze) {\\n+     Write-Host \\\"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\\\" -ForegroundColor DarkGray\\n+ }\\n+ \",\"oldStart\":1,\"newStart\":1,\"oldLines\":1,\"newLines\":834,\"linesRemoved\":1,\"linesAdded\":834}],\"editor\":\"EDITOR_AI\"},\"shouldAutoFixLints\":true,\"resultForModel\":\"Wrote contents to USB-Inventory.ps1.\",\"contentsAfterEdit\":\"#requires -Version 5.1\\n\u003c#\\n.SYNOPSIS\\n    USB-portable PC hardware inventory collection and analysis tool.\\n\\n.DESCRIPTION\\n    Collects hardware inventory (System, Network, GPU, Storage, Monitors) from the\\n    current PC and appends it to PC_Inventory_Master.csv in the same folder as the\\n    script. Optionally runs health analysis to detect duplicates, stale assets,\\n    low RAM, and missing monitor data.\\n\\n    Run this script from a USB drive to inventory multiple PCs into a single CSV.\\n\\n.PARAMETER OutputFile\\n    Path to the master CSV file. Defaults to PC_Inventory_Master.csv in $PSScriptRoot.\\n\\n.PARAMETER IncludePciDevices\\n    Include detailed PCI device enumeration (can produce large output).\\n\\n.PARAMETER Analyze\\n    After collection, run health analysis on the CSV file.\\n\\n.PARAMETER AnalyzeOnly\\n    Skip collection; only run health analysis on existing CSV.\\n\\n.PARAMETER StaleDays\\n    Threshold in days for flagging stale assets. Default: 90.\\n\\n.PARAMETER MinRamGB\\n    Minimum RAM in GB; systems below this are flagged. Default: 8.\\n\\n.PARAMETER NoCsv\\n    Do not output Inventory_Issues_Report.csv (text report only).\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1\\n    Collect inventory from this PC into PC_Inventory_Master.csv.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -IncludePciDevices -Analyze\\n    Collect inventory with PCI devices, then run health analysis.\\n\\n.EXAMPLE\\n    .\\\\USB-Inventory.ps1 -AnalyzeOnly -MinRamGB 16 -StaleDays 60\\n    Analyze existing CSV with custom thresholds (no new collection).\\n#\u003e\\n\\n[CmdletBinding()]\\nparam(\\n    [string]$OutputFile = (Join-Path -Path $PSScriptRoot -ChildPath \u0027PC_Inventory_Master.csv\u0027),\\n    [switch]$IncludePciDevices,\\n    [switch]$Analyze,\\n    [switch]$AnalyzeOnly,\\n    [int]$StaleDays = 90,\\n    [int]$MinRamGB = 8,\\n    [switch]$NoCsv\\n)\\n\\nSet-StrictMode -Version Latest\\n$ErrorActionPreference = \u0027Stop\u0027\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - COLLECTION\\n# ============================================================================\\n\\nfunction Clean-Cell {\\n    param([AllowNull()][string]$Text)\\n    if ($null -eq $Text) { return \u0027\u0027 }\\n    return ($Text -replace \\\"(`r`n|`n|`r|`t)+\\\", \u0027 \u0027).Trim()\\n}\\n\\nfunction Convert-UShortArrayToString {\\n    param([AllowNull()]$Arr)\\n    if ($null -eq $Arr) { return \u0027\u0027 }\\n    $chars = foreach ($x in $Arr) {\\n        if ($null -ne $x -and [int]$x -ne 0) { [char][int]$x }\\n    }\\n    return ( -join $chars ).Trim()\\n}\\n\\nfunction Get-MonitorInventory {\\n    \u003c#\\n      Preferred: root\\\\wmi:WmiMonitorID (easy, consistent, usually no admin)\\n      Fallback: registry EDID decode under HKLM:\\\\SYSTEM\\\\CCS\\\\Enum\\\\DISPLAY\\n    #\u003e\\n\\n    $results = New-Object System.Collections.Generic.List[string]\\n\\n    # --- Preferred path: WmiMonitorID ---\\n    try {\\n        $wmiMons = Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorID -ErrorAction Stop\\n        foreach ($m in $wmiMons) {\\n            $mfg  = Convert-UShortArrayToString $m.ManufacturerName\\n            $name = Convert-UShortArrayToString $m.UserFriendlyName\\n            $sn   = Convert-UShortArrayToString $m.SerialNumberID\\n\\n            $label = @()\\n            if ($mfg)  { $label += $mfg }\\n            if ($name) { $label += $name }\\n\\n            $displayName = if ($label.Count -gt 0) { ($label -join \u0027 \u0027) } else { \u0027Monitor\u0027 }\\n            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } else { \u0027SN:(none)\u0027 }\\n\\n            $results.Add(\\\"$displayName ($serialPart)\\\")\\n        }\\n    } catch {\\n        # WmiMonitorID not available; fall through to EDID fallback\\n    }\\n\\n    if ($results.Count -gt 0) {\\n        return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n    }\\n\\n    # --- Fallback path: registry EDID decode ---\\n    function Get-EdidDescriptorString {\\n        param(\\n            [byte[]]$Edid,\\n            [ValidateSet(\u0027Serial\u0027,\u0027Name\u0027)][string]$Kind\\n        )\\n\\n        if ($null -eq $Edid -or $Edid.Length -lt 128) { return \u0027\u0027 }\\n\\n        $tag = if ($Kind -eq \u0027Serial\u0027) { 0xFF } else { 0xFC }\\n\\n        foreach ($offset in 54,72,90,108) {\\n            if (($offset + 18) -gt $Edid.Length) { continue }\\n\\n            # Descriptor: 00 00 00 {tag} 00 ...\\n            if ($Edid[$offset] -eq 0x00 -and $Edid[$offset+1] -eq 0x00 -and $Edid[$offset+2] -eq 0x00 -and\\n                $Edid[$offset+3] -eq $tag -and $Edid[$offset+4] -eq 0x00) {\\n\\n                $bytes = $Edid[($offset+5)..($offset+17)]\\n                $text = ([System.Text.Encoding]::ASCII.GetString($bytes)).Trim()\\n                $text = ($text -replace \\\"[`0`n`r]+\\\", \u0027\u0027).Trim()\\n                if ($text) { return $text }\\n            }\\n        }\\n\\n        return \u0027\u0027\\n    }\\n\\n    try {\\n        $root = \u0027HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Enum\\\\DISPLAY\u0027\\n        if (Test-Path -LiteralPath $root) {\\n            Get-ChildItem -LiteralPath $root -ErrorAction Stop | ForEach-Object {\\n                Get-ChildItem -LiteralPath $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {\\n                    $params = Join-Path -Path $_.PSPath -ChildPath \u0027Device Parameters\u0027\\n                    if (Test-Path -LiteralPath $params) {\\n                        $edid = (Get-ItemProperty -LiteralPath $params -ErrorAction SilentlyContinue).EDID\\n                        if ($edid -is [byte[]]) {\\n                            $sn = Get-EdidDescriptorString -Edid $edid -Kind Serial\\n                            $nm = Get-EdidDescriptorString -Edid $edid -Kind Name\\n\\n                            # Numeric serial (bytes 12-15 LE) sometimes present\\n                            $num = [BitConverter]::ToUInt32($edid, 12)\\n                            $numStr = if ($num -ne 0) { \\\"NUM:$num\\\" } else { \u0027\u0027 }\\n\\n                            $displayName = if ($nm) { $nm } else { \u0027Monitor\u0027 }\\n                            $serialPart  = if ($sn) { \\\"SN:$sn\\\" } elseif ($numStr) { $numStr } else { \u0027SN:(none)\u0027 }\\n\\n                            $results.Add(\\\"$displayName ($serialPart)\\\")\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    } catch {\\n        # EDID fallback failed silently\\n    }\\n\\n    if ($results.Count -eq 0) { return \u0027None Detected/Generic\u0027 }\\n    return (Clean-Cell (($results | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-NetworkInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasNetAdapter = (Get-Command Get-NetAdapter -ErrorAction SilentlyContinue) -ne $null\\n    $hasNetIpCfg   = (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) -ne $null\\n\\n    if ($hasNetAdapter -and $hasNetIpCfg) {\\n        try {\\n            $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Sort-Object -Property Name\\n            foreach ($a in $adapters) {\\n                $cfg = Get-NetIPConfiguration -InterfaceIndex $a.ifIndex -ErrorAction SilentlyContinue\\n                $ipv4 = @()\\n                if ($cfg -and $cfg.IPv4Address) {\\n                    $ipv4 = $cfg.IPv4Address |\\n                        ForEach-Object { $_.IPAddress } |\\n                        Where-Object { $_ -and ($_ -notlike \u0027169.254.*\u0027) }\\n                }\\n                $gw = @()\\n                if ($cfg -and $cfg.IPv4DefaultGateway) {\\n                    $gw = $cfg.IPv4DefaultGateway | ForEach-Object { $_.NextHop } | Where-Object { $_ }\\n                }\\n\\n                $parts = @()\\n                $parts += (Clean-Cell $a.Name)\\n                if ($a.MacAddress) { $parts += \\\"MAC:$($a.MacAddress)\\\" }\\n                if ($ipv4.Count -gt 0) { $parts += (\\\"IPv4:\\\" + ($ipv4 -join \u0027;\u0027)) }\\n                if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n                $items.Add(($parts -join \u0027 \u0027))\\n            }\\n        } catch {\\n            # Fall back to CIM below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        $net = Get-CimInstance -ClassName Win32_NetworkAdapterConfiguration -ErrorAction Stop |\\n            Where-Object { $_.IPEnabled -eq $true }\\n\\n        foreach ($n in $net) {\\n            $name = if ($n.Description) { $n.Description } else { \u0027Adapter\u0027 }\\n            $mac  = $n.MACAddress\\n            $ips  = @()\\n            if ($n.IPAddress) { $ips = @($n.IPAddress) | Where-Object { $_ -and ($_ -notlike \u0027fe80:*\u0027) -and ($_ -notlike \u0027169.254.*\u0027) } }\\n            $gw   = @()\\n            if ($n.DefaultIPGateway) { $gw = @($n.DefaultIPGateway) | Where-Object { $_ } }\\n\\n            $parts = @()\\n            $parts += (Clean-Cell $name)\\n            if ($mac) { $parts += \\\"MAC:$mac\\\" }\\n            if ($ips.Count -gt 0) { $parts += (\\\"IP:\\\" + ($ips -join \u0027;\u0027)) }\\n            if ($gw.Count -gt 0) { $parts += (\\\"GW:\\\" + ($gw -join \u0027;\u0027)) }\\n\\n            $items.Add(($parts -join \u0027 \u0027))\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-GpuInventory {\\n    $gpus = New-Object System.Collections.Generic.List[string]\\n\\n    # CIM GPUs\\n    try {\\n        $vc = Get-CimInstance -ClassName Win32_VideoController -ErrorAction Stop\\n        foreach ($g in $vc) {\\n            $name = Clean-Cell $g.Name\\n            $pnp  = Clean-Cell $g.PNPDeviceID\\n            if ($name -or $pnp) {\\n                $gpus.Add((\\\"{0}{1}\\\" -f $name, $(if ($pnp) { \\\" [ID:$pnp]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    # Optional NVIDIA serials if nvidia-smi exists\\n    try {\\n        $nvsmi = Get-Command nvidia-smi.exe -ErrorAction SilentlyContinue\\n        if ($nvsmi) {\\n            $raw = \u0026 $nvsmi.Source --query-gpu=name,serial --format=csv,noheader 2\u003e$null\\n            foreach ($line in @($raw)) {\\n                $t = Clean-Cell $line\\n                if ($t) { $gpus.Add(\\\"NVIDIA $t\\\") }\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($gpus.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($gpus | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-DiskInventory {\\n    $disks = New-Object System.Collections.Generic.List[string]\\n\\n    # Prefer Storage module when available\\n    $hasPhysicalDisk = (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasPhysicalDisk) {\\n        try {\\n            foreach ($d in (Get-PhysicalDisk -ErrorAction Stop)) {\\n                $name = Clean-Cell $d.FriendlyName\\n                $sn   = Clean-Cell $d.SerialNumber\\n                $mt   = Clean-Cell ([string]$d.MediaType)\\n                $sz   = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n                $parts = @()\\n                if ($name) { $parts += $name }\\n                if ($sn)   { $parts += \\\"SN:$sn\\\" }\\n                if ($mt)   { $parts += \\\"Type:$mt\\\" }\\n                if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n                if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($disks.Count -gt 0) { return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM\\n    try {\\n        foreach ($d in (Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction Stop)) {\\n            $model = Clean-Cell $d.Model\\n            $sn = \u0027\u0027\\n            try { $sn = Clean-Cell ([string]$d.SerialNumber) } catch { $sn = \u0027\u0027 }\\n            $devId = Clean-Cell $d.DeviceID\\n            $sz = if ($d.Size) { [math]::Round(($d.Size / 1GB), 0) } else { $null }\\n\\n            $parts = @()\\n            if ($model) { $parts += $model }\\n            if ($sn)    { $parts += \\\"SN:$sn\\\" }\\n            if ($devId) { $parts += \\\"Dev:$devId\\\" }\\n            if ($null -ne $sz) { $parts += \\\"GB:$sz\\\" }\\n\\n            if ($parts.Count -gt 0) { $disks.Add(($parts -join \u0027 \u0027)) }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($disks.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($disks | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\nfunction Get-PciDeviceInventory {\\n    $items = New-Object System.Collections.Generic.List[string]\\n\\n    $hasGetPnpDevice = (Get-Command Get-PnpDevice -ErrorAction SilentlyContinue) -ne $null\\n    if ($hasGetPnpDevice) {\\n        try {\\n            $devs = Get-PnpDevice -PresentOnly -ErrorAction Stop |\\n                Where-Object { $_.InstanceId -like \u0027PCI\\\\*\u0027 } |\\n                Sort-Object -Property Class, FriendlyName, Name\\n\\n            foreach ($d in $devs) {\\n                $name = if ($d.FriendlyName) { $d.FriendlyName } else { $d.Name }\\n                $name = Clean-Cell $name\\n                $cls  = Clean-Cell $d.Class\\n                $id   = Clean-Cell $d.InstanceId\\n                if ($name -or $id) {\\n                    $items.Add((\\\"{0}{1}{2}\\\" -f $name, $(if ($cls) { \\\" [Class:$cls]\\\" } else { \u0027\u0027 }), $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n                }\\n            }\\n        } catch {\\n            # Fall back below\\n        }\\n    }\\n\\n    if ($items.Count -gt 0) { return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027)) }\\n\\n    # Fallback: CIM Win32_PnPEntity\\n    try {\\n        $devs = Get-CimInstance -ClassName Win32_PnPEntity -ErrorAction Stop |\\n            Where-Object { $_.PNPDeviceID -like \u0027PCI\\\\*\u0027 } |\\n            Sort-Object -Property Name\\n\\n        foreach ($d in $devs) {\\n            $name = Clean-Cell $d.Name\\n            $id   = Clean-Cell $d.PNPDeviceID\\n            if ($name -or $id) {\\n                $items.Add((\\\"{0}{1}\\\" -f $name, $(if ($id) { \\\" [ID:$id]\\\" } else { \u0027\u0027 })))\\n            }\\n        }\\n    } catch {\\n        # Ignore\\n    }\\n\\n    if ($items.Count -eq 0) { return \u0027\u0027 }\\n    return (Clean-Cell (($items | Sort-Object -Unique) -join \u0027 | \u0027))\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS - ANALYSIS\\n# ============================================================================\\n\\nfunction Get-ColumnMap {\\n    param([string[]]$Headers)\\n\\n    $map = @{\\n        Hostname        = \u0027Hostname\u0027\\n        User            = \u0027User\u0027\\n        System_Serial   = \u0027System_Serial\u0027\\n        RAM_GB          = \u0027RAM_GB\u0027\\n        Monitor_Serials = \u0027Monitor_Serials\u0027\\n        Scan_Date       = \u0027Scan_Date\u0027\\n    }\\n\\n    foreach ($k in @($map.Keys)) {\\n        if ($Headers -notcontains $map[$k]) {\\n            $alts = switch ($k) {\\n                \u0027System_Serial\u0027   { @(\u0027Serial Number\u0027,\u0027Serial\u0027,\u0027System Serial\u0027,\u0027SystemSerial\u0027) }\\n                \u0027RAM_GB\u0027          { @(\u0027RAM (GB)\u0027,\u0027RAM\u0027,\u0027Memory_GB\u0027,\u0027MemoryGB\u0027) }\\n                \u0027Monitor_Serials\u0027 { @(\u0027Monitor Serials\u0027,\u0027MonitorSerials\u0027,\u0027Monitors\u0027) }\\n                \u0027Scan_Date\u0027       { @(\u0027Date Scanned\u0027,\u0027ScanDate\u0027,\u0027Scan Date\u0027,\u0027Scan_Timestamp\u0027) }\\n                \u0027Hostname\u0027        { @(\u0027ComputerName\u0027,\u0027Computer\u0027,\u0027Host\u0027) }\\n                \u0027User\u0027            { @(\u0027Username\u0027,\u0027LoggedOnUser\u0027,\u0027Logged On User\u0027) }\\n                default           { @() }\\n            }\\n            $found = $alts | Where-Object { $Headers -contains $_ } | Select-Object -First 1\\n            if ($found) { $map[$k] = $found }\\n        }\\n    }\\n\\n    return $map\\n}\\n\\nfunction Parse-ScanDate {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    $dt = $null\\n\\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n    if ([datetime]::TryParseExact($s, \u0027yyyy-MM-dd HH:mm:ss\u0027, [Globalization.CultureInfo]::InvariantCulture, [Globalization.DateTimeStyles]::AssumeLocal, [ref]$dt)) { return $dt }\\n\\n    if ([datetime]::TryParse($s, [ref]$dt)) { return $dt }\\n\\n    return $null\\n}\\n\\nfunction Normalize-Serial {\\n    param([AllowNull()][string]$Serial)\\n\\n    if ([string]::IsNullOrWhiteSpace($Serial)) { return \u0027\u0027 }\\n    $s = ($Serial.Trim())\\n\\n    $bad = @(\\n        \u0027To Be Filled By O.E.M.\u0027,\\n        \u0027To Be Filled By OEM\u0027,\\n        \u0027Default string\u0027,\\n        \u0027System Serial Number\u0027,\\n        \u0027None\u0027,\\n        \u0027N/A\u0027,\\n        \u0027NA\u0027,\\n        \u00270\u0027,\\n        \u002700000000\u0027,\\n        \u00270000000000\u0027,\\n        \u00270000000000000000\u0027\\n    )\\n\\n    if ($bad -contains $s) { return \u0027\u0027 }\\n    if ($s -match \u0027^(0+)$\u0027) { return \u0027\u0027 }\\n\\n    return $s.ToUpperInvariant()\\n}\\n\\nfunction Parse-RamGB {\\n    param([AllowNull()][string]$Value)\\n\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $null }\\n    $s = $Value.Trim()\\n\\n    $m = [regex]::Match($s, \u0027(\\\\d+)(\\\\.\\\\d+)?\u0027)\\n    if (-not $m.Success) { return $null }\\n\\n    $n = $null\\n    if ([double]::TryParse($m.Value, [Globalization.NumberStyles]::Float, [Globalization.CultureInfo]::InvariantCulture, [ref]$n)) {\\n        return [int][math]::Round($n, 0)\\n    }\\n\\n    return $null\\n}\\n\\nfunction Is-MonitorMissing {\\n    param([AllowNull()][string]$Value)\\n    if ([string]::IsNullOrWhiteSpace($Value)) { return $true }\\n    $t = $Value.Trim()\\n    return ($t -match \u0027^(none detected|none detected/generic|generic|n/a|na)$\u0027 -or $t -match \u0027None Detected\u0027)\\n}\\n\\n# ============================================================================\\n# MAIN: COLLECTION\\n# ============================================================================\\n\\nfunction Invoke-Collection {\\n    param([string]$OutPath, [switch]$IncludePci)\\n\\n    $errors = New-Object System.Collections.Generic.List[string]\\n\\n    Write-Host \\\"`n========================================================\\\" -ForegroundColor Cyan\\n    Write-Host \\\"   GATHERING HARDWARE SPECS... PLEASE WAIT\\\" -ForegroundColor Cyan\\n    Write-Host \\\"========================================================\\\" -ForegroundColor Cyan\\n\\n    # --- Collect core system info ---\\n    $sys  = $null\\n    $bios = $null\\n    $cpu  = $null\\n    $os   = $null\\n    $bb   = $null\\n\\n    try { $sys  = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_ComputerSystem: $($_.Exception.Message)\\\") }\\n    try { $bios = Get-CimInstance -ClassName Win32_BIOS -ErrorAction Stop } catch { $errors.Add(\\\"Win32_BIOS: $($_.Exception.Message)\\\") }\\n    try { $cpu  = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_Processor: $($_.Exception.Message)\\\") }\\n    try { $os   = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop } catch { $errors.Add(\\\"Win32_OperatingSystem: $($_.Exception.Message)\\\") }\\n    try { $bb   = Get-CimInstance -ClassName Win32_BaseBoard -ErrorAction Stop | Select-Object -First 1 } catch { $errors.Add(\\\"Win32_BaseBoard: $($_.Exception.Message)\\\") }\\n\\n    # --- Derived values ---\\n    $hostname = try { [System.Net.Dns]::GetHostName() } catch { $env:COMPUTERNAME }\\n    if ($sys -and $sys.DNSHostName) { $hostname = $sys.DNSHostName }\\n\\n    $ramGB = $null\\n    try {\\n        if ($sys -and $sys.TotalPhysicalMemory) {\\n            $ramGB = [int][math]::Round(($sys.TotalPhysicalMemory / 1GB), 0)\\n        }\\n    } catch {\\n        $errors.Add(\\\"RAM calc: $($_.Exception.Message)\\\")\\n    }\\n\\n    # --- Other sections ---\\n    $netStr  = \u0027\u0027\\n    $gpuStr  = \u0027\u0027\\n    $diskStr = \u0027\u0027\\n    $monStr  = \u0027\u0027\\n    $pciStr  = \u0027\u0027\\n\\n    try { $netStr  = Get-NetworkInventory } catch { $errors.Add(\\\"Network: $($_.Exception.Message)\\\") }\\n    try { $gpuStr  = Get-GpuInventory } catch { $errors.Add(\\\"GPU: $($_.Exception.Message)\\\") }\\n    try { $diskStr = Get-DiskInventory } catch { $errors.Add(\\\"Disks: $($_.Exception.Message)\\\") }\\n    try { $monStr  = Get-MonitorInventory } catch { $errors.Add(\\\"Monitors: $($_.Exception.Message)\\\") }\\n\\n    if ($IncludePci) {\\n        try { $pciStr = Get-PciDeviceInventory } catch { $errors.Add(\\\"PCI devices: $($_.Exception.Message)\\\") }\\n    }\\n\\n    # --- Build record ---\\n    $record = [pscustomobject]@{\\n        Hostname          = Clean-Cell $hostname\\n        User              = Clean-Cell $env:USERNAME\\n\\n        Make_Model        = Clean-Cell ((\\\"{0} {1}\\\" -f ($sys.Manufacturer), ($sys.Model)).Trim())\\n        System_Serial     = Clean-Cell ($bios.SerialNumber)\\n\\n        Baseboard_Make    = Clean-Cell ($bb.Manufacturer)\\n        Baseboard_Product = Clean-Cell ($bb.Product)\\n        Baseboard_Serial  = Clean-Cell ($bb.SerialNumber)\\n\\n        BIOS_Version      = Clean-Cell ((@($bios.SMBIOSBIOSVersion, $bios.Version) | Where-Object { $_ } | Select-Object -First 1))\\n        BIOS_ReleaseDate  = Clean-Cell (try { ([Management.ManagementDateTimeConverter]::ToDateTime($bios.ReleaseDate)).ToString(\u0027yyyy-MM-dd\u0027) } catch { \u0027\u0027 })\\n\\n        OS_Caption        = Clean-Cell ($os.Caption)\\n        OS_Version        = Clean-Cell ($os.Version)\\n        OS_BuildNumber    = Clean-Cell ($os.BuildNumber)\\n\\n        CPU               = Clean-Cell ($cpu.Name)\\n        RAM_GB            = $ramGB\\n\\n        Network_Adapters  = Clean-Cell $netStr\\n        GPUs              = Clean-Cell $gpuStr\\n        Disk_Serials      = Clean-Cell $diskStr\\n        Monitor_Serials   = Clean-Cell $monStr\\n\\n        PCI_Devices       = Clean-Cell $pciStr\\n\\n        Scan_Date         = (Get-Date -Format \u0027yyyy-MM-dd\u0027)\\n        Scan_Timestamp    = (Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027)\\n        Collector_Version = \u00272.0\u0027\\n        Errors            = Clean-Cell (($errors | Select-Object -Unique) -join \u0027 | \u0027)\\n    }\\n\\n    # --- CSV append with header safety ---\\n    $needHeader = $true\\n    if (Test-Path -LiteralPath $OutPath) {\\n        try {\\n            $fi = Get-Item -LiteralPath $OutPath -ErrorAction Stop\\n            if ($fi.Length -gt 0) { $needHeader = $false }\\n        } catch { $needHeader = $true }\\n    }\\n\\n    if ($needHeader) {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Force\\n    } else {\\n        $record | Export-Csv -LiteralPath $OutPath -NoTypeInformation -Encoding UTF8 -Append\\n    }\\n\\n    Write-Host \\\"`nSUCCESS!\\\" -ForegroundColor Green\\n    Write-Host \\\"Data saved to: $OutPath\\\" -ForegroundColor Gray\\n    if ($record.Errors) {\\n        Write-Host (\\\"Warnings captured in Errors column: {0}\\\" -f $record.Errors) -ForegroundColor Yellow\\n    }\\n}\\n\\n# ============================================================================\\n# MAIN: ANALYSIS\\n# ============================================================================\\n\\nfunction Invoke-Analysis {\\n    param(\\n        [string]$InputPath,\\n        [int]$StaleDaysThreshold,\\n        [int]$MinRam,\\n        [switch]$SkipCsv\\n    )\\n\\n    $ReportFile = Join-Path -Path $PSScriptRoot -ChildPath \u0027Inventory_Issues_Report.txt\u0027\\n    $IssuesCsv  = Join-Path -Path $PSScriptRoot -ChildPath \u0027Inventory_Issues_Report.csv\u0027\\n\\n    if (-not (Test-Path -LiteralPath $InputPath)) {\\n        Write-Warning \\\"Input file not found: $InputPath\\\"\\n        Write-Warning \\\"Run the script without -AnalyzeOnly first to collect data.\\\"\\n        return\\n    }\\n\\n    $raw = Import-Csv -LiteralPath $InputPath\\n    if (-not $raw -or $raw.Count -eq 0) {\\n        Write-Warning \\\"Input file contains no rows: $InputPath\\\"\\n        return\\n    }\\n\\n    $headers = @()\\n    try { $headers = $raw[0].PSObject.Properties.Name } catch { $headers = @() }\\n    $col = Get-ColumnMap -Headers $headers\\n\\n    $today = Get-Date\\n\\n    # Normalize data and add helper properties\\n    $data = foreach ($r in $raw) {\\n        $hostname = if ($r.PSObject.Properties.Match($col.Hostname).Count) { [string]$r.($col.Hostname) } else { \u0027\u0027 }\\n        $user     = if ($r.PSObject.Properties.Match($col.User).Count)     { [string]$r.($col.User) } else { \u0027\u0027 }\\n        $serial   = if ($r.PSObject.Properties.Match($col.System_Serial).Count) { [string]$r.($col.System_Serial) } else { \u0027\u0027 }\\n        $ram      = if ($r.PSObject.Properties.Match($col.RAM_GB).Count)   { [string]$r.($col.RAM_GB) } else { \u0027\u0027 }\\n        $mon      = if ($r.PSObject.Properties.Match($col.Monitor_Serials).Count) { [string]$r.($col.Monitor_Serials) } else { \u0027\u0027 }\\n        $scan     = if ($r.PSObject.Properties.Match($col.Scan_Date).Count) { [string]$r.($col.Scan_Date) } else { \u0027\u0027 }\\n\\n        $serialN = Normalize-Serial $serial\\n        $scanDt  = Parse-ScanDate $scan\\n        $ramGb   = Parse-RamGB $ram\\n\\n        $h = if ($null -ne $hostname) { $hostname } else { \u0027\u0027 }\\n        $u = if ($null -ne $user) { $user } else { \u0027\u0027 }\\n        $m = if ($null -ne $mon) { $mon } else { \u0027\u0027 }\\n        $s = if ($null -ne $scan) { $scan } else { \u0027\u0027 }\\n\\n        # Asset key: prefer System Serial, fallback to Hostname\\n        $assetKey = \u0027\u0027\\n        if (-not [string]::IsNullOrWhiteSpace($serialN)) {\\n            $assetKey = $serialN\\n        } elseif (-not [string]::IsNullOrWhiteSpace($h)) {\\n            $assetKey = $h.Trim().ToUpperInvariant()\\n        }\\n\\n        [pscustomobject]@{\\n            Hostname        = $h.Trim()\\n            User            = $u.Trim()\\n            System_Serial   = $serialN\\n            RAM_GB          = $ramGb\\n            Monitor_Serials = $m.Trim()\\n            Scan_Date       = $s.Trim()\\n\\n            ScanDateParsed  = $scanDt\\n            AssetKey        = $assetKey\\n            RawRow          = $r\\n        }\\n    }\\n\\n    # Latest record per asset\\n    $latestByAsset = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.AssetKey) } |\\n        Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true }, @{ Expression = { $_.Hostname }; Descending = $false } |\\n        Group-Object -Property AssetKey |\\n        ForEach-Object { $_.Group | Select-Object -First 1 }\\n\\n    $issues = New-Object System.Collections.Generic.List[object]\\n\\n    function Add-Issue {\\n        param(\\n            [Parameter(Mandatory)][string]$IssueType,\\n            [Parameter(Mandatory)][ValidateSet(\u0027Info\u0027,\u0027Warning\u0027,\u0027Critical\u0027)][string]$Severity,\\n            [string]$AssetKey,\\n            [string]$Hostname,\\n            [string]$User,\\n            [string]$SystemSerial,\\n            [string]$ScanDate,\\n            [string]$Details\\n        )\\n\\n        $issues.Add([pscustomobject]@{\\n            IssueType     = $IssueType\\n            Severity      = $Severity\\n            AssetKey      = $AssetKey\\n            Hostname      = $Hostname\\n            User          = $User\\n            System_Serial = $SystemSerial\\n            Scan_Date     = $ScanDate\\n            Details       = $Details\\n        })\\n    }\\n\\n    # 0) Data quality (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ([string]::IsNullOrWhiteSpace($pc.Hostname)) {\\n            Add-Issue -IssueType \u0027Missing Hostname\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Hostname is blank in latest record.\u0027\\n        }\\n        if ([string]::IsNullOrWhiteSpace($pc.System_Serial)) {\\n            Add-Issue -IssueType \u0027Missing System Serial\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027System serial is blank/invalid (common on some systems/VMs).\u0027\\n        }\\n        if (-not $pc.ScanDateParsed) {\\n            Add-Issue -IssueType \u0027Invalid Scan Date\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027Scan_Date missing or not parseable. Expected yyyy-MM-dd (or yyyy-MM-dd HH:mm:ss).\u0027\\n        }\\n    }\\n\\n    # 1) Duplicate serials (all rows; ignore blanks)\\n    $dupeGroups = $data |\\n        Where-Object { -not [string]::IsNullOrWhiteSpace($_.System_Serial) } |\\n        Group-Object -Property System_Serial |\\n        Where-Object { $_.Count -gt 1 }\\n\\n    foreach ($g in $dupeGroups) {\\n        $uniqHosts = @($g.Group | ForEach-Object { $_.Hostname } | Where-Object { $_ } | Select-Object -Unique)\\n        $uniqUsers = @($g.Group | ForEach-Object { $_.User } | Where-Object { $_ } | Select-Object -Unique)\\n\\n        $severity =\\n            if ($uniqHosts.Count -gt 1 -or $uniqUsers.Count -gt 1) { \u0027Warning\u0027 }\\n            else { \u0027Info\u0027 }\\n\\n        $entries = $g.Group |\\n            Sort-Object -Property @{ Expression = { $_.ScanDateParsed }; Descending = $true } |\\n            ForEach-Object {\\n                $d = if ($_.ScanDateParsed) { $_.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) } else { $_.Scan_Date }\\n                \\\"{0} ({1})\\\" -f $_.Hostname, $d\\n            }\\n\\n        Add-Issue -IssueType \u0027Duplicate System Serial\u0027 -Severity $severity -AssetKey $g.Name -Hostname \u0027\u0027 -User \u0027\u0027 -SystemSerial $g.Name -ScanDate \u0027\u0027 -Details (\\\"Serial appears {0} times; Hosts={1}; Users={2}; Entries: {3}\\\" -f $g.Count, ($uniqHosts -join \u0027,\u0027), ($uniqUsers -join \u0027,\u0027), ($entries -join \u0027; \u0027))\\n    }\\n\\n    # 2) Low RAM (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($null -ne $pc.RAM_GB -and $pc.RAM_GB -lt $MinRam) {\\n            Add-Issue -IssueType \u0027Low RAM\u0027 -Severity \u0027Critical\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details (\\\"RAM_GB={0} (min {1})\\\" -f $pc.RAM_GB, $MinRam)\\n        } elseif ($null -eq $pc.RAM_GB) {\\n            Add-Issue -IssueType \u0027Missing RAM\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027RAM_GB not present or not parseable.\u0027\\n        }\\n    }\\n\\n    # 3) Stale assets (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if ($pc.ScanDateParsed) {\\n            $ageDays = ($today - $pc.ScanDateParsed).Days\\n            if ($ageDays -gt $StaleDaysThreshold) {\\n                Add-Issue -IssueType \u0027Stale Asset\u0027 -Severity \u0027Warning\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.ScanDateParsed.ToString(\u0027yyyy-MM-dd\u0027) -Details (\\\"Last seen {0} days ago (threshold {1})\\\" -f $ageDays, $StaleDaysThreshold)\\n            }\\n        }\\n    }\\n\\n    # 4) Missing monitor serials (latest records)\\n    foreach ($pc in $latestByAsset) {\\n        if (Is-MonitorMissing $pc.Monitor_Serials) {\\n            Add-Issue -IssueType \u0027Missing Monitor Serials\u0027 -Severity \u0027Info\u0027 -AssetKey $pc.AssetKey -Hostname $pc.Hostname -User $pc.User -SystemSerial $pc.System_Serial -ScanDate $pc.Scan_Date -Details \u0027No monitor serials recorded (could be laptop panel, EDID blocked by dock/KVM, or permissions/driver limitation).\u0027\\n        }\\n    }\\n\\n    # --- Build text report ---\\n    $generated = Get-Date\\n    $line = (\u0027=\u0027 * 70)\\n\\n    $txt = New-Object System.Collections.Generic.List[string]\\n    $txt.Add($line)\\n    $txt.Add(\u0027IT INVENTORY HEALTH REPORT\u0027)\\n    $txt.Add(\\\"Generated: $generated\\\")\\n    $txt.Add(\\\"Input:     $InputPath\\\")\\n    $txt.Add((\\\"Assets:    {0} (latest per asset)\\\" -f $latestByAsset.Count))\\n    $txt.Add((\\\"Rows:      {0} (raw rows in CSV)\\\" -f $data.Count))\\n    $txt.Add((\\\"Settings:  MinRamGB={0}, StaleDays={1}\\\" -f $MinRam, $StaleDaysThreshold))\\n    $txt.Add($line)\\n    $txt.Add(\u0027\u0027)\\n\\n    if ($issues.Count -eq 0) {\\n        $txt.Add(\u0027No issues found.\u0027)\\n    } else {\\n        $byType = $issues | Group-Object IssueType | Sort-Object Name\\n        foreach ($t in $byType) {\\n            $txt.Add((\\\"--- {0} ({1}) ---\\\" -f $t.Name, $t.Count))\\n            foreach ($i in ($t.Group | Sort-Object Severity, AssetKey, Hostname)) {\\n                $asset = if ($i.AssetKey) { $i.AssetKey } else { \u0027(no key)\u0027 }\\n                $host_  = if ($i.Hostname) { $i.Hostname } else { \u0027(no hostname)\u0027 }\\n                $scan_  = if ($i.Scan_Date) { $i.Scan_Date } else { \u0027\u0027 }\\n                $ser   = if ($i.System_Serial) { $i.System_Serial } else { \u0027\u0027 }\\n                $usr   = if ($i.User) { $i.User } else { \u0027\u0027 }\\n\\n                $txt.Add((\\\"{0} | {1} | Host={2} User={3} Serial={4} Scan={5} | {6}\\\" -f $i.Severity, $asset, $host_, $usr, $ser, $scan_, $i.Details))\\n            }\\n            $txt.Add(\u0027\u0027)\\n        }\\n    }\\n\\n    $txt | Out-File -LiteralPath $ReportFile -Encoding UTF8\\n\\n    if (-not $SkipCsv) {\\n        $issues | Sort-Object Severity, IssueType, AssetKey, Hostname |\\n            Export-Csv -LiteralPath $IssuesCsv -NoTypeInformation -Encoding UTF8\\n    }\\n\\n    # --- Console summary ---\\n    Write-Host \\\"`n$line\\\" -ForegroundColor Cyan\\n    Write-Host (\\\"Report saved: {0}\\\" -f $ReportFile) -ForegroundColor Green\\n    if (-not $SkipCsv) { Write-Host (\\\"Issues CSV:   {0}\\\" -f $IssuesCsv) -ForegroundColor Green }\\n    Write-Host (\\\"Issues found: {0}\\\" -f $issues.Count) -ForegroundColor Yellow\\n    Write-Host $line -ForegroundColor Cyan\\n\\n    if ($issues.Count -gt 0) {\\n        $sev = $issues | Group-Object Severity | Sort-Object Name\\n        foreach ($s in $sev) {\\n            $c = switch ($s.Name) {\\n                \u0027Critical\u0027 { [ConsoleColor]::Red }\\n                \u0027Warning\u0027  { [ConsoleColor]::Yellow }\\n                default    { [ConsoleColor]::Gray }\\n            }\\n            Write-Host (\\\"{0}: {1}\\\" -f $s.Name, $s.Count) -ForegroundColor $c\\n        }\\n    }\\n}\\n\\n# ============================================================================\\n# ENTRY POINT\\n# ============================================================================\\n\\nif (-not $AnalyzeOnly) {\\n    Invoke-Collection -OutPath $OutputFile -IncludePci:$IncludePciDevices\\n}\\n\\nif ($Analyze -or $AnalyzeOnly) {\\n    Invoke-Analysis -InputPath $OutputFile -StaleDaysThreshold $StaleDays -MinRam $MinRamGB -SkipCsv:$NoCsv\\n}\\n\\nif (-not $AnalyzeOnly -and -not $Analyze) {\\n    Write-Host \\\"`nTip: Run with -Analyze to check for duplicates, stale assets, and low specs.\\\" -ForegroundColor DarkGray\\n}\\n\\n\"}"},"checkpointId":"37008f86-b6ee-4aa2-b6a4-4a72b44005df"},"bubbleId":"fb5d46c6-e348-4214-9006-58dba5a10810"}
